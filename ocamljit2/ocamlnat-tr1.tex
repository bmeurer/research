\documentclass[10pt,a4paper,draft,twocolumn]{article}

\usepackage{amssymb}
\usepackage[english]{babel}
\usepackage{color}
\usepackage[colorlinks=false,%
            pdfkeywords={OCaml, Just In Time compilation, machine code generation},%
            pdftitle={Towards a native toplevel for OCaml},%
            pdfauthor={Marcell Fischbach, Benedikt Meurer},%
            pdfsubject={},%
            pdfdisplaydoctitle=true]{hyperref}
\usepackage{tikz}
\usepackage{varwidth}

\usetikzlibrary{arrows}
\usetikzlibrary{trees}
\usetikzlibrary{arrows,backgrounds,decorations.pathmorphing,fit,matrix,positioning}
\tikzset{
  phase/.style={
      rectangle,
      inner sep=1mm,
      rounded corners=1mm,
      minimum size=6mm,
      very thick,
      draw=blue!50!black!50,
      top color=white,
      bottom color=blue!50!black!20
  }
}

\begin{document}

\title{%
  Towards a native toplevel for OCaml
}
\author{%
  Marcell Fischbach\thanks{
    Universit\"at Siegen,
    D-57068 Siegen,
    Germany,
    \url{marcellfischbach@googlemail.com}
  }
  \and
  Benedikt Meurer\thanks{
    Compilerbau und Softwareanalyse,
    Naturwissenschaftl.-Technische Fakult\"at,
    Universit\"at Siegen,
    D-57068 Siegen,
    Germany,
    \url{meurer@informatik.uni-siegen.de}
  }
}
\date{}

\maketitle

\begin{abstract}
  TODO
\end{abstract}


%% Introduction
\section{Introduction}

The OCaml \cite{Leroy11,Remy02} system is the main implementation of the Caml
language \cite{Caml11}, featuring a powerful module system
combined with a full-fledged object-oriented layer. It comes with an optimizing native
code compiler \texttt{ocamlopt}, for high performance; a byte code compiler \texttt{ocamlc}
and interpreter \texttt{ocamlrun}, for increased portability; and an interactive top-level
\texttt{ocaml} based on the byte code runtime, for interactive use of OCaml through a
read-eval-print loop.

\texttt{ocamlc} and \texttt{ocaml} translate the source code into a sequence of byte code
instructions for the OCaml virtual machine \texttt{ocamlrun}, which is based on the ZINC
machine \cite{Leroy90} originally developed for Caml Light \cite{Leroy02}. The optimizing
native code compiler \texttt{ocamlopt} produces fast machine code for the supported targets
(at the time of this writing, these are Alpha, ARM, Itanum, Motorola 68k, MIPS, PA-RISC, PowerPC,
Sparc, and x86/x86-64), but is currently only applicable to \emph{static program compilation}.
For example, it cannot yet be used with multi-stage programming in MetaOCaml \cite{Taha03,Taha06},
the Coq proof assistant \cite{Bertot04,Coq10}, or the interactive toplevel \texttt{ocaml}.

This paper presents our work on a new native OCaml toplevel, called \texttt{ocamlnat}, which is
based on the native runtime, the compilation engine of the optimizing native code compiler and
an earlier prototype implementation of a native toplevel by Alain Frisch.

The paper is organized as follows: Section~\ref{section:Motivation} motivates the need for a
usable native OCaml toplevel. Section~\ref{section:Overview_of_the_OCaml_compilers} presents
an overview of the OCaml compilers and Section~\ref{section:The_native_toplevel} describes the
previous \texttt{ocamlnat} prototype which inspired our work, while
Section~\ref{section:On_the_fly_code_generation} presents our work on \texttt{ocamlnat}.
Performance measures are given in Section~\ref{section:Performance}.
Section~\ref{section:Conclusion_and_further_work} concludes with possible directions for
further work.


%% Motivation
\section{Motivation} \label{section:Motivation}

\begin{enumerate}
\item Speed
\item Mirage \cite{Mirage11,Madhavapeddy10,Madhavapeddy10hotcloud}
\item ocamlscript \cite{ocamlscript11}
\item Memory Overhead
\end{enumerate}

\textbf{TODO}


%% Overview of the OCaml compilers
\section{Overview of the OCaml compilers} \label{section:Overview_of_the_OCaml_compilers}

This section gives a brief overview of the OCaml compilers, covering both the byte code compiler
\texttt{ocamlc} and the optimizing native code compiler \texttt{ocamlopt}.
Feel free to skip to section~\ref{section:The_native_toplevel} if you are already familiar with the details.

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[node distance=8mm,text height=1.5ex,text depth=.25ex]
    \matrix[row sep={1.3cm,between origins}]
    {
      & \node (start) {}; \\
      & \node[phase] (parsing) {Parsing}; \\
      & \node[phase] (typing) {Typing}; \\
      & \node[phase] (transl) {Translate}; \\
      & \node[phase] (simplif) {Simplify}; \\
      \node[phase] (bytegen) {Bytegen}; && \node[phase] (asmgen) {Asmgen}; \\
      \node (bytecode) {}; && \node (nativecode) {}; \\
    };
    \draw[->] (start) -- node[right] {\it source program} (parsing);
    \draw[->] (parsing) -- node[right] {\tt Parsetree} (typing);
    \draw[->] (typing) -- node[right] {\tt Typedtree} (transl);
    \draw[->] (transl) -- node[right] {\tt Lambda} (simplif);
    \draw[->] (simplif) -- node[left] {} (bytegen);
    \draw[->] (simplif) -- node[right] {} (asmgen);
    \draw[->] (bytegen) -- node[left] {\it byte code} (bytecode);
    \draw[->] (asmgen) -- node[right] {\it native code} (nativecode);
  \end{tikzpicture}
  \caption{Overview of the OCaml compilers}
  \label{fig:Overview_of_the_OCaml_compilers}
\end{figure}

Figure~\ref{fig:Overview_of_the_OCaml_compilers} gives an overview of the compiler phases
and representations in the OCaml byte and native code compilers. Compilation always starts
by parsing an OCaml source program (either from a source file or a source region in
interactive mode) into an abstract syntax tree (AST, see file \texttt{parsing/parsetree.mli}
of the OCaml source code). Compilation then proceeds by computing the type annotations to
produce a typed syntax tree (see file \texttt{typing/typedtree.mli}).

From this typed syntax tree, the compiler generates a so called \emph{lambda representation} (see file
\texttt{bytecomp/lambda.mli}) inspired by the untyped call-by-value $\lambda$-calculus
\cite{Appel98ml,Jones87,Michaelson89}. This lambda representation is then optimized by
transforming lambda trees into \emph{better} or smaller lambda trees (see file
\texttt{bytecomp/simplif.ml}), yielding a final platform independent, internal
representation of the source program as result of the compiler frontend phases.

The simplified lambda representation is then used as input for the respective compiler
backend, which is
\begin{itemize}
\item the \texttt{Bytegen} module in case of the byte code compiler
  (see file \texttt{bytecomp/bytegen.ml}), or
\item the \texttt{Asmgen} module in case of the optimizing native code compiler
  (see file \texttt{asmcomp/asmgen.ml}).
\end{itemize}

The byte code backend, which is used by the byte code compiler \texttt{ocamlc} as well as
the byte code toplevel \texttt{ocaml}, basically turns the simplified lambda representation
into an equivalent byte code program (see file \texttt{bytecomp/instruct.mli}), suitable for
(a) direct execution by the byte code interpreter \texttt{ocamlrun} or (b) just-in-time
compilation using either OCAMLJIT \cite{Starynkevitch04} or OCamlJIT2
\cite{Meurer10jit,Meurer10ocamljit,Meurer11ocamljit2}.
This is done by the \texttt{Emitcode} module (see file \texttt{bytecomp/emitcode.ml}).
Additional details about the byte code compiler and runtime can be found in \cite{Leroy90},
\cite{Meurer10ocamljit} and \cite{Starynkevitch04}.

The native code backend, which is used by the optimizing native code compiler \texttt{ocamlopt}
as well as the native toplevel \texttt{ocamlnat}, is shown in Figure~\ref{fig:Native_code_generation}.
It takes the simplified lambda representation as input and starts by transforming it into a variant
of the lambda representation (see file \texttt{asmcomp/clambda.mli}) with explicit closures and
explicit direct/indirect function calls (see file \texttt{asmcomp/closure.ml}). This is then further
processed and transformed into an equivalent representation in an internal dialect of \mbox{C\,-\,-}
\cite{JonesR98,JonesRR99} (see files \texttt{asmcomp/cmm.mli} and \texttt{asmcomp/cmmgen.ml}).

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[node distance=8mm,text height=1.5ex,text depth=.25ex]
    \matrix[row sep={1.3cm,between origins}]
    {
      \node (start) {}; \\
      \node[phase] (closure) {Closure conversion}; \\
      \node[phase] (cmmgen) {\mbox{C\,-\,-} generation}; \\
      \node[phase] (selection) {Instruction selection}; \\
      \node[phase] (comballoc) {Alloc combining}; \\
      \node[phase] (regalloc) {Register allocation}; \\
      \node[phase] (linearize) {Linearization}; \\
      \node[phase] (scheduling) {Instruction scheduling}; \\
      \node (end) {}; \\
    };
    \draw[->] (start) -- node[right] {\tt Lambda} (closure);
    \draw[->] (closure) -- node[right] {\tt Clambda} (cmmgen);
    \draw[->] (cmmgen) -- node[right] {\tt Cmm} (selection);
    \draw[->] (selection) -- node[right] {\tt Mach} (comballoc);
    \draw[->] (comballoc) -- node[right] {\tt Mach} (regalloc);
    \draw[->] (regalloc) -- node[right] {\tt Mach} (linearize);
    \draw[->] (linearize) -- node[right] {\tt Linearize} (scheduling);
    \draw[->] (scheduling) -- node[right] {\it native code} (end);
  \end{tikzpicture}
  \caption{Native code generation (\texttt{Asmgen} module)}
  \label{fig:Native_code_generation}
\end{figure}

Afterwards the instruction selection phase (see file \texttt{asmcomp/selection.ml}) picks appropriate
instructions for the target machine, transforming the \mbox{C\,-\,-} code into non-linear machine
code (see file \texttt{asmcomp/mach.mli}). The next step attempts to combine multiple heap allocations
within a basic block into a single heap allocation (see file \texttt{asmcomp/comballoc.ml}), prior to
allocating and assigning physical registers to the virtual registers used in the machine code (see
function \texttt{regalloc} in file \texttt{asmcomp/asmgen.ml}).
The final phases linearize the machine code (see file \texttt{asmcomp/linearize.ml}) and perform
instruction scheduling for better performance (see file \texttt{asmcomp/scheduling.ml}), yielding the
final representation of the (linearized) machine code.

The optimizing native code compiler \texttt{ocamlopt} writes the linearized machine code output of
the \texttt{Asmgen} module to an assembly file in the appropriate format for the target platform (see
file \texttt{asmcomp/emit.ml}), i.e. using AT\&T assembly syntax on Linux and Intel assembly syntax
on Windows, and invokes the assembler from the system compiler toolchain, i.e. GNU \texttt{as} on Linux,
to generate an object file. This object file can then be linked with other OCaml modules and C code into
an executable binary or a dynamic library file.


%% The native toplevel
\section{The native toplevel} \label{section:The_native_toplevel}

In 2007 Alain Frisch added support for the \texttt{Dynlink} library to the native code compiler and
runtime for some platforms, which was first made available as part of OCaml 3.11. This made it 
possible to use the OCaml native code runtime with dynamically loaded plugins, which was previously
limited with the byte code runtime. Besides various other improvements, this also made it possible
to reuse the existing functionality of the optimizing native code compiler within the scope of a
native toplevel.

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[node distance=8mm,text height=1.5ex,text depth=.25ex]
    \matrix[row sep={1.3cm,between origins}]
    {
      \node (start) {}; \\
      \node[phase] (compiler) {Native code compiler}; \\
      \node[phase] (emit) {Native code emitter}; \\
      \node[phase] (as) {Toolchain Assembler (\texttt{as})}; \\
      \node[phase] (ld) {Toolchain Linker (\texttt{ld})}; \\
      \node[phase] (rtld) {Runtime Linker}; \\
      \node (end) {}; \\
    };
    \draw[->] (start) -- node[right] {\it OCaml phrase} (compiler);
    \draw[->] (compiler) -- node[right] {\it native code} (emit);
    \draw[->] (emit) -- node[right] {\it assembly file} (as);
    \draw[->] (as) -- node[right] {\it object file} (ld);
    \draw[->] (ld) -- node[right] {\it dynamic library file} (rtld);
    \draw[->] (rtld) -- node[right] {\it executable code} (end);
  \end{tikzpicture}
  \caption{\texttt{ocamlnat} prototype}
  \label{fig:ocamlnat_prototype}
\end{figure}

The initial proof-of-concept prototype of a native toplevel, called \texttt{ocamlnat} and developed
by Alain Frisch, was since silently shipped with every OCaml release\footnote{It must be build
explicitly using \texttt{make ocamlnat} after \texttt{make world} and \texttt{make opt}, and it
is only available for targets that support the native \texttt{Dynlink} library.}.

Figure~\ref{fig:ocamlnat_prototype} gives an overview of the internals of the \texttt{ocamlnat} prototype.
It works by starting up the OCaml native runtime and then prompts the user for OCaml phrases to evaluate
(just like the byte code toplevel \texttt{ocaml} does). Whenever the user enters a phrase, it is compiled
to native code using the modules of the optimizing native code compiler (utilizing the frontend phases as
shown in Figure~\ref{fig:Overview_of_the_OCaml_compilers} and the native backend phases as shown in
Figure~\ref{fig:Native_code_generation}).

This \emph{native code} is written to a temporary \emph{assembly file} by the Native code emitter, which
is also part of \texttt{ocamlopt}. The \emph{assembly file} is then passed to the Toolchain Assembler to
produce a temporary \emph{object file}. This \emph{object file} is afterwards turned into a \emph{dynamic
library file} by the Toolchain Linker, and loaded into the native toplevel process using the Runtime Linker,
yielding a memory area with the \emph{executable code} which is then executed.

While this approach has the immediate benefit of requiring only a few hundred lines of glue code to turn
the existing modules of the optimizing native code compiler and the native \texttt{Dynlink} library into
a native toplevel, there are also various obvious drawbacks to the approach (preventing
wide-spread adoption of \texttt{ocamlnat}):
\begin{enumerate}
\item Dependency on the system toolchain (as, ld).
  Problematic for Mirage \cite{Mirage11,Madhavapeddy10,Madhavapeddy10hotcloud}.
  \textbf{TODO}
\item Latency of the external tools and the necessary I/O. \textbf{TODO}
\item Left-over temporary files on (DLLs on Windows). \textbf{TODO}
\item Unclear maintenance status. \textbf{TODO}
\end{enumerate}


%% On-the-fly code generation
\section{On-the-fly code generation} \label{section:On_the_fly_code_generation}

TODO


%% Performance
\section{Performance} \label{section:Performance}

TODO


%% Conclusion and further work
\section{Conclusion and further work} \label{section:Conclusion_and_further_work}

TODO


%% References
\bibliographystyle{abbrv}
\bibliography{citations}

\end{document}
