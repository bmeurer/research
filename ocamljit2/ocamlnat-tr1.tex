\documentclass[10pt,a4paper,draft,twocolumn]{article}

\usepackage{amssymb}
\usepackage[english]{babel}
\usepackage{color}
\usepackage[colorlinks=false,%
            pdfkeywords={OCaml, Just In Time compilation, machine code generation},%
            pdftitle={Towards a usable native toplevel for OCaml},%
            pdfauthor={Marcell Fischbach, Benedikt Meurer},%
            pdfsubject={},%
            pdfdisplaydoctitle=true]{hyperref}
\usepackage{tikz}
\usepackage{varwidth}

\usetikzlibrary{arrows}
\usetikzlibrary{trees}
\usetikzlibrary{arrows,backgrounds,decorations.pathmorphing,fit,matrix,positioning}
\tikzset{
  phase/.style={
      rectangle,
      inner sep=1mm,
      rounded corners=1mm,
      minimum size=6mm,
      very thick,
      draw=blue!50!black!50,
      top color=white,
      bottom color=blue!50!black!20
  }
}

\begin{document}

\title{%
  Towards a usable native toplevel for OCaml
}
\author{%
  Marcell Fischbach\thanks{
    Universit\"at Siegen,
    D-57068 Siegen,
    Germany,
    \url{marcellfischbach@googlemail.com}
  }
  \and
  Benedikt Meurer\thanks{
    Compilerbau und Softwareanalyse,
    Naturwissenschaftl.-Technische Fakult\"at,
    Universit\"at Siegen,
    D-57068 Siegen,
    Germany,
    \url{meurer@informatik.uni-siegen.de}
  }
}
\date{}

\maketitle

\begin{abstract}
  TODO
\end{abstract}


%% Introduction
\section{Introduction}

The OCaml \cite{Leroy11,Remy02} system is the main implementation of the Caml
language \cite{Caml11}, featuring a powerful module system
combined with a full-fledged object-oriented layer. It comes with an optimizing native
code compiler \texttt{ocamlopt}, for high performance; a byte code compiler \texttt{ocamlc}
and interpreter \texttt{ocamlrun}, for increased portability; and an interactive top-level
\texttt{ocaml} based on the byte code runtime, for interactive use of OCaml through a
read-eval-print loop.

\texttt{ocamlc} and \texttt{ocaml} translate the source code into a sequence of byte code
instructions for the OCaml virtual machine \texttt{ocamlrun}, which is based on the ZINC
machine \cite{Leroy90} originally developed for Caml Light \cite{Leroy02}. The optimizing
native code compiler \texttt{ocamlopt} produces fast machine code for the supported targets
(at the time of this writing, these are Alpha, ARM, Itanum, Motorola 68k, MIPS, PA-RISC, PowerPC,
Sparc, and x86/x86-64), but is currently only applicable to \emph{static program compilation}.
For example, it cannot yet be used with multi-stage programming in MetaOCaml \cite{Taha03,Taha06},
the Coq proof assistant \cite{Bertot04,Coq10}, or the interactive toplevel \texttt{ocaml}.

This paper presents our work on a new native OCaml toplevel, called \texttt{ocamlnat}, which is
based on the native runtime and the compilation engine of the optimizing native code compiler.

TODO


%% Overview of the OCaml system
\section{Overview of the OCaml system} \label{section:Overview_of_the_OCaml_system}

This section gives a brief overview of the OCaml system. Additional details about the
byte code compiler and runtime can be found in \cite{Leroy90}, \cite{Meurer10ocamljit}
and \cite{Starynkevitch04}.
Feel free to skip to \textbf{TODO} if you are already familiar with the details.

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[node distance=8mm,text height=1.5ex,text depth=.25ex]
    \matrix[row sep={1.3cm,between origins}]
    {
      & \node (start) {}; \\
      & \node[phase] (parsing) {Parsing}; \\
      & \node[phase] (typing) {Typing}; \\
      & \node[phase] (transl) {Translate}; \\
      & \node[phase] (simplif) {Simplify}; \\
      \node[phase] (bytegen) {Bytegen}; && \node[phase] (asmgen) {Asmgen}; \\
      \node (bytecode) {}; && \node (nativecode) {}; \\
    };
    \draw[->] (start) -- node[right] {\it source program} (parsing);
    \draw[->] (parsing) -- node[right] {\tt Parsetree} (typing);
    \draw[->] (typing) -- node[right] {\tt Typedtree} (transl);
    \draw[->] (transl) -- node[right] {\tt Lambda} (simplif);
    \draw[->] (simplif) -- node[left] {} (bytegen);
    \draw[->] (simplif) -- node[right] {} (asmgen);
    \draw[->] (bytegen) -- node[left] {\it byte code} (bytecode);
    \draw[->] (asmgen) -- node[right] {\it native code} (nativecode);
  \end{tikzpicture}
  \caption{Overview of the OCaml compilers}
  \label{fig:Overview_of_the_OCaml_compilers}
\end{figure}

Figure~\ref{fig:Overview_of_the_OCaml_compilers} gives an overview of the compiler phases
and representations in the OCaml byte and native code compilers. Compilation always starts
by parsing an OCaml source program (either from a source file or a source region in
interactive mode) into an abstract syntax tree (AST, see file \texttt{parsing/parsetree.mli}
of the OCaml source code). Compilation then proceeds by computing the type annotations to
produce a typed syntax tree (see file \texttt{typing/typedtree.mli}).

From this typed syntax tree, the compiler generates a so called \emph{lambda representation} (see file
\texttt{bytecomp/lambda.mli}) inspired by the untyped call-by-value $\lambda$-calculus
\cite{Appel98ml,Jones87,Michaelson89}. This lambda representation is then optimized by
transforming lambda trees into \emph{better} or smaller lambda trees (see file
\texttt{bytecomp/simplif.ml}), yielding a final platform independent, internal
representation of the source program as result of the compiler frontend phases.

The simplified lambda representation is then used as input for the respective compiler
backend, which is
\begin{itemize}
\item the \texttt{Bytegen} module in case of the byte code compiler
  (see file \texttt{bytecomp/bytegen.ml}), or
\item the \texttt{Asmgen} module in case of the optimizing native code compiler
  (see file \texttt{asmcomp/asmgen.ml}).
\end{itemize}

The byte code backend, which is used by the byte code compiler \texttt{ocamlc} as well as
the byte code toplevel \texttt{ocaml}, basically turns the simplified lambda representation
into an equivalent byte code program (see file \texttt{bytecomp/instruct.mli}), suitable for
(a) direct execution by the byte code interpreter \texttt{ocamlrun} or (b) just-in-time
compilation using either OCAMLJIT \cite{Starynkevitch04} or OCamlJIT2
\cite{Meurer10jit,Meurer10ocamljit,Meurer11ocamljit2}.
This is done by the \texttt{Emitcode} module (see file \texttt{bytecomp/emitcode.ml}).

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[node distance=8mm,text height=1.5ex,text depth=.25ex]
    \matrix[row sep={1.3cm,between origins}]
    {
      \node (start) {}; \\
      \node[phase] (closure) {Closure conversion}; \\
      \node[phase] (cmmgen) {C\,-\,- generation}; \\
      \node[phase] (selection) {Instruction selection}; \\
      \node[phase] (comballoc) {Alloc combining}; \\
      \node[phase] (regalloc) {Register allocation}; \\
      \node[phase] (linearize) {Linearization}; \\
      \node[phase] (scheduling) {Instruction scheduling}; \\
      \node (end) {}; \\
    };
    \draw[->] (start) -- node[right] {\tt Lambda} (closure);
    \draw[->] (closure) -- node[right] {\tt Clambda} (cmmgen);
    \draw[->] (cmmgen) -- node[right] {\tt Cmm} (selection);
    \draw[->] (selection) -- node[right] {\tt Mach} (comballoc);
    \draw[->] (comballoc) -- node[right] {\tt Mach} (regalloc);
    \draw[->] (regalloc) -- node[right] {\tt Mach} (linearize);
    \draw[->] (linearize) -- node[right] {\tt Linearize} (scheduling);
    \draw[->] (scheduling) -- node[right] {\it native code} (end);
  \end{tikzpicture}
  \caption{Native code generation (\texttt{Asmgen} module)}
  \label{fig:Native_code_generation}
\end{figure}

The native code backend, which is used by the optimizing native code compiler \texttt{ocamlopt}
as well as the native toplevel \texttt{ocamlnat}, is shown in Figure~\ref{fig:Native_code_generation}.
It takes the simplified lambda representation as input and starts by transforming it into a variant
of the lambda representation (see file \texttt{asmcomp/clambda.mli}) with explicit closures and
explicit direct/indirect function calls (see file \texttt{asmcomp/closure.ml}). This is then further
processed and transformed into an equivalent representation in an internal dialect of \mbox{C\,-\,-}
\cite{JonesR98,JonesRR99} (see files \texttt{asmcomp/cmm.mli} and \texttt{asmcomp/cmmgen.ml}).

Afterwards the instruction selection phase (see file \texttt{asmcomp/selection.ml}) picks appropriate
instructions for the target machine, transforming the \mbox{C\,-\,-} code into non-linear machine
code (see file \texttt{asmcomp/mach.mli}). The next step attempts to combine multiple heap allocations
within a basic block into a single heap allocation (see file \texttt{asmcomp/comballoc.ml}), prior to
allocating and assigning physical registers to the virtual registers used in the machine code (see
function \texttt{regalloc} in file \texttt{asmcomp/asmgen.ml}).
The final phases linearize the machine code (see file \texttt{asmcomp/linearize.ml}) and perform
instruction scheduling for better performance (see file \texttt{asmcomp/scheduling.ml}), yielding the
final representation of the (linearized) machine code.

The optimizing native code compiler \texttt{ocamlopt} writes the linearized machine code output of
the \texttt{Asmgen} module to an assembly file in the appropriate format for the target platform (see
file \texttt{asmcomp/emit.ml}), i.e. using AT\&T assembly syntax on Linux and Intel assembly syntax
on Windows, and invokes the assembler from the system compiler toolchain, i.e. GNU \texttt{as} on Linux,
to generate an object file. This object file can then be linked with other OCaml modules and C code into
an executable binary or a dynamic library file.


%% Conclusion
\section{Conclusion} \label{section:Conclusion}

TODO


%% Acknowlegdements
\section*{Acknowledgements}

TODO


%% References
\bibliographystyle{abbrv}
\bibliography{citations}

\end{document}
