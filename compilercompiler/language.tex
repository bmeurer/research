\documentclass[12pt,a4paper]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{array}
\usepackage[american]{babel}
\usepackage{color}
\usepackage{enumerate}
\usepackage[a4paper,%
            colorlinks=false,%
            final,%
            pdfkeywords={},%
            pdftitle={},%
            pdfauthor={Benedikt Meurer},%
            pdfsubject={},%
            pdfdisplaydoctitle=true]{hyperref}
\usepackage{ifthen}
\usepackage[latin1]{inputenc}
\usepackage{latexsym}
\usepackage[final]{listings}
\usepackage{makeidx}
\usepackage[standard,thmmarks]{ntheorem}
\usepackage{stmaryrd}
%\usepackage{url}
%\usepackage[arrow, matrix, curve]{xy}

%% LaTeX macros
\include{macros}


\begin{document}

\section{Eine einfache Programmiersprache}

\begin{definition}[Syntax]
  Sei $\Var$ eine unendliche Menge von Variablen $x$.
  \[\begin{grammar}
  e \in \Exp \is x \mid \abstr{x}{e} \mid \app{e_1}{e_2}
  \nl
  v \in \Val \is \conf{\abstr{x}{e}}{\eta}
  \nl
  \eta \in \Env \is \cdot \mid x:v,\eta
  \end{grammar}\]
\end{definition}

{\footnotesize
  \begin{center}
    \begin{tabular}{cc}
      \multicolumn{2}{c}{\framebox[30mm][c]{$\conf{e}{\eta} \Downarrow v$}} \\[3mm]
      $\RULE{\nstyle{lookup}\,(\eta,x) = v}{\conf{x}{\eta} \Downarrow v}$
      & $\RULE{\conf{e_1}{\eta} \Downarrow \conf{\abstr{x'}{e'}}{\eta'} \quad \conf{e_2}{\eta} \Downarrow v' \quad \conf{e'}{\nstyle{bind}\,(\eta',x',v')} \Downarrow v}{\conf{\app{e_1}{e_2}}{\eta} \Downarrow v}$ \\[3mm]
    \end{tabular}
  \end{center}
}

% A store $s\in\Store$ is a finite, partial mapping from locations to values. We write $s \disjoint s'$ to indicate
% that the domains $\dom{s}$ and $\dom{s'}$ are disjoint. When $s \disjoint s'$ holds, $s * s'$ is the store obtained
% by taking the union of disjoint partial functions. When $s \disjoint s'$ does not hold, $s * s'$ is undefined.

% {\footnotesize
%   \begin{center}
%     \begin{tabular}{ccc}
%       \multicolumn{3}{c}{\framebox[30mm][c]{$\conf{e}{s} \step \conf{e'}{s'}$}} \\[3mm]
%       $\RULE{\conf{e_1}{s} \step \conf{e_1'}{s'}}{\conf{\app{e_1}{e_2}}{s} \step \conf{\app{e_1'}{e_2}}{s'}}$
%       & $\RULE{\conf{e}{s} \step \conf{e'}{s'}}{\conf{\app{v}{e}}{s} \step \conf{\app{v}{e'}}{s'}}$
%       & $\conf{\app{(\abstr{x}{e})}{v}}{s} \step \conf{e[v/x]}{s}$ \\[3mm]
%       $\RULE{\ell \not\in \dom{s}}{\conf{\app{\new}{v}}{s} \step \conf{\ell}{s[v/\ell]}}$
%       & $\RULE{s(\ell) = v}{\conf{\app{\deref}{\ell}}{s} \step \conf{v}{s}}$
%       & $\RULE{\ell\in\dom{s}}{\conf{\app{\app{\assign}{\ell}}{v}}{s} \step \conf{\ell}{s[v/\ell]}}$ \\[3mm]
%     \end{tabular} \\[5mm]
%   \end{center}
% }

% A \emph{computation} for $\conf{e}{s}$ is a maximal sequence of small steps
% \[\conf{e}{s} \step \conf{e_1}{s_1} \step \conf{e_2}{s_2} \ldots\]
% A computation \emph{diverges} if the sequence is infinite, or \emph{terminates} if the sequence is
% finite, where the last configuration is $\conf{e_n}{s_n}$ and $e_n$ is a value $v$. Otherwise we
% say that the computation \emph{got stuck}. A configuration $\conf{e}{s}$
% \begin{enumerate}
% \item is \emph{safe} if no computation for $\conf{e}{s}$ gets stuck, and
% \item \emph{must terminate normally} if all computations for $\conf{e}{s}$ terminate.
% \end{enumerate}
% Obviously each configuration which must terminate normally is also safe. More interestingly, due to
% [O'Hearn, ``A Semantic Basis for Local Reasoning''], we have:

% \begin{theorem}[Safety and Termination Monotonicity] \
%   \begin{enumerate}
%   \item If $\conf{e}{s}$ is safe and $s' = s * s''$, then $\conf{e}{s'}$ is also safe.
%   \item If $\conf{e}{s}$ must terminate normally and $s' = s * s''$, then $\conf{e}{s'}$ must also
%     terminate normally.
%   \end{enumerate}
% \end{theorem}

% \begin{theorem}[Frame Property]
%   Suppose the configuration $\conf{e}{s_0}$ is safe, and $\conf{e}{s_0 * s} \step^* \conf{v'}{s'}$. Then
%   there exists some $s_0'$ such that $s' = s_0' * s$ and $\conf{e}{s_0} \step^* \conf{v'}{s_0'}$.
% \end{theorem}


% \section{The Assertion Language}

% Given a signature $\Sigma$ and a first order logic $L_\Sigma$, we extend this logic to an assertion
% language by adding the following productions to the abstract syntax of the logic:
% \[\begin{grammar}
%   t \in \Term \is v
%   \nl
%   p,q \in \Assn \is t_1 \mapsto t_2 \mid p * q \mid \tc{p}{e}{x}{q}
% \end{grammar}\]


% \section{The calculus}

% {\footnotesize
%   \begin{center}
%     \begin{tabular}{rl}
%       \RN{Val}    & $\qall{x}{\tc{\emp}{x}{y}{y = x \wedge \emp}}$ \\[1mm]
%       \RN{App}    & $\tc{p}{e_1}{x}{p'}
%                     \wedge (\qall{x}{\tc{p'}{e_2}{y}{q'}})
%                     \wedge (\qall{x,y}{\tc{q'}{\app{x}{y}}{y}{q}})
%                     \Rightarrow \tc{p}{\app{e_1}{e_2}}{y}{q}$ \\[1mm]
%                   & where $x \not\in \FV{e_2} \cup \FV{q}$ \\[1mm]
%       \RN{Beta-V} & $\qall{x}{\tc{p}{e}{y}{q} \Rightarrow \tc{p}{\app{(\abstr{x}{e})}{x}}{y}{q}}$ \\[1mm]
%       \RN{New}    & $\qall{x}{\tc{\emp}{\app{\new}{x}}{y}{y \mapsto x}}$ \\[1mm]
%       \RN{Deref}  & $\qall{x,y}{\tc{y \mapsto x}{\app{\deref}{y}}{z}{z = x \wedge y \mapsto x}}$ \\[1mm]
%       \RN{Assign} & $\qall{x,y}{\tc{\qex{z}{y \mapsto z}}{\app{\app{\assign}{y}}{x}}{z}{z = y \wedge y \mapsto x}}$ \\[1mm]
%     \end{tabular}
%   \end{center}
% }


% % \section{The Assertion Language}

% % Given a family $\mathcal{F} = (F_\tau)$ of function symbols $f$ and
% % a family $\mathcal{R} = (R_\omega)$ of relation symbols $\varrho$.
% % \begin{definition}
% %   \[\begin{grammar}
% %     \tau \in \TermType \is \Bool \mid \Data \mid \Nat \mid \tau_1 \to \tau_2
% %     \nl
% %     \omega \in \AssnType \is \tau \mid \Prop \mid \tau \to \omega
% %     \nl
% %     t \in \Term \is f \mid x \mid \abstr{x:\tau}{t} \mid \app{t_1}{t_2}
% %     \nl
% %     p,q \in \Assn \is P \mid p \wedge q \mid p \vee q \mid \neg p \mid p \supset q
% %     \al x \mid \abstr{x:\tau}{p} \mid \app{p}{t} \mid \qall{x:\omega}{p} \mid \qex{x:\omega}{p}
% %     \al p * q \mid \tc{p}{e}{x}{q} \mid \{p\}
% %     \nl
% %     \Gamma \in \Context \is \cdot \mid \Gamma,x:\omega
% %   \end{grammar}\]
% % \end{definition}

% % {\footnotesize
% %   \begin{tabular}{ccc}
% %     \multicolumn{3}{c}{\framebox[20mm][c]{$\Tj{\Gamma}{t}{\tau}$}} \\[3mm]
% %     $\RULE{\mathbf{c}\in\{\true,\false\}}{\Tj{\Gamma}{\mathbf{c}}{\Bool}}$
% %     & $\Tj{\Gamma}{n}{\Nat}$
% %     & $\RULE{\Tj{\Gamma}{t_1}{\Nat} \quad \Tj{\Gamma}{t_2}{\Nat} \quad \Box \in \{+,-,\ldots\}}{\Tj{\Gamma}{t_1 \Box t_2}{{\Nat}}}$ \\[3mm]
% %     $\RULE{x:\tau \in\Gamma}{\Tj{\Gamma}{x}{\tau}}$
% %     & $\RULE{\Tj{\Gamma,x:\tau}{t}{\tau'}}{\Tj{\Gamma}{\abstr{x:\tau}{t}}{\tau \to \tau'}}$
% %     & $\RULE{\Tj{\Gamma}{t_1}{\tau \to \tau'} \quad \Tj{\Gamma}{t_2}{\tau}}{\Tj{\Gamma}{\app{t_1}{t_2}}{\tau'}}$ \\[3mm]
% %   \end{tabular}

% %   \begin{tabular}{ccc}
% %     \multicolumn{3}{c}{\framebox[20mm][c]{$\Tj{\Gamma}{p}{\omega}$}} \\[3mm]
% %     $\RULE{\mathbf{c} \in \{\top,\bot,\emp\}}{\Tj{\Gamma}{\mathbf{c}}{\Prop}}$
% %     & $\Tj{\Gamma}{=^\tau}{\tau \to \tau \to \Prop}$
% %     & $\Tj{\Gamma}{\mapsto}{\Data \to \Data \to \Prop}$ \\[3mm]
% %     \multicolumn{2}{c}{$\Tj{\Gamma}{\rep{\Nat}}{\Data \to \Nat \to \Prop}$}
% %     & $\Tj{\Gamma}{\rep{\Bool}}{\Data \to \Bool \to \Prop}$ \\[3mm]
% %     \multicolumn{2}{c}{$\RULE{\Tj{\Gamma}{p}{\Prop} \quad \Tj{\Gamma}{q}{\Prop} \quad \Box \in\{\wedge,\vee,\supset,*\}}{\Tj{\Gamma}{p \Box q}{\Prop}}$}
% %     & $\RULE{\Tj{\Gamma}{p}{\Prop}}{\Tj{\Gamma}{\neg p}{\Prop}}$ \\[3mm]
% %     $\RULE{x:\omega \in \Gamma}{\Tj{\Gamma}{x}{\omega}}$
% %     & $\RULE{\Tj{\Gamma,x:\tau}{p}{\omega}}{\Tj{\Gamma}{\abstr{x:\tau}{p}}{\tau \to \omega}}$
% %     & $\RULE{\Tj{\Gamma}{p}{\tau \to \omega} \quad \Tj{\Gamma}{t}{\tau}}{\Tj{\Gamma}{\app{p}{t}}{\omega}}$ \\[3mm]
% %     \multicolumn{2}{c}{$\RULE{\Tj{\Gamma,x:\omega}{p}{\Prop} \quad Q\in\{\forall,\exists\}}{\Tj{\Gamma}{Q x:\omega.\,p}{\Prop}}$}
% %     & $\RULE{\Tj{\Gamma}{p}{\Prop}}{\Tj{\Gamma}{\{p\}}{\Prop}}$ \\[3mm]
% %     \multicolumn{3}{c}{$\RULE{\Tj{\Gamma}{p}{\Prop} \quad \tj{\Gamma}{e} \quad \Tj{\Gamma,x:\Data}{q}{\Prop}}{\Tj{\Gamma}{\tc{p}{e}{x}{q}}{\Prop}}$} \\[3mm]
% %   \end{tabular}
% % }

% % \subsection{The Semantic of Assertions}

% % Let $\mathcal{S} = \{s\,|\,\tj{\cdot}{s}\}$ be the set of all semi-closed stores.
% % \begin{definition}[Semantic Domains]
% %   \[\begin{array}{rcl}
% %     \semantic{\Nat} &=& \N \\
% %     \semantic{\Bool} &=& \{\true,\false\} \\
% %     \semantic{\Data} &=& \{v \mid \tj{\cdot}{v}\} \\
% %     \semantic{\Prop} &=& \{S \mid S \subseteq \mathcal{S}\} \\
% %     \semantic{\tau \to \omega} &=& \semantic{\omega}^{\semantic{\tau}} \\
% %   \end{array}\]
% % \end{definition}

% % {\footnotesize
% %   \[\begin{array}{rcl}
% %     \semantic{\Tj{\Gamma}{\true}{\Bool}}\,\eta &=& \true \\
% %     \semantic{\Tj{\Gamma}{\false}{\Bool}}\,\eta &=& \false \\
% %     \semantic{\Tj{\Gamma}{n}{\Nat}}\,\eta &=& n \\
% %     \semantic{\Tj{\Gamma}{t_1 \Box t_2}{\Nat}}\,\eta &=& (\semantic{\Tj{\Gamma}{t_1}{\Nat}}\,\eta) \Box (\semantic{\Tj{\Gamma}{t_2}{\Nat}}\,\eta) \quad \Box\in\{+,-,\ldots\} \\
% %     \semantic{\Tj{\Gamma}{x}{\tau}}\,\eta &=& \eta(x) \\
% %     \semantic{\Tj{\Gamma}{\abstr{x:\tau}{t}}{\tau \to \tau'}}\,\eta &=& \abstr{d\in\semantic{\tau}}{\semantic{\Tj{\Gamma,x:\tau}{t}{\tau'}}\,(\eta[d/x])} \\
% %     \semantic{\Tj{\Gamma}{\app{t_1}{t_2}}{\tau}}\,\eta &=& \app{(\semantic{\Tj{\Gamma}{t_1}{\tau' \to \tau}}\,\eta)}{(\semantic{\Tj{\Gamma}{t_2}{\tau'}}\,\eta)} \\
% %   \end{array}\]
  
% %   \[\begin{array}{rcl}
% %     \semantic{\Tjr{\bot}{\Prop}} &=& \emptyset \\
% %     \semantic{\Tjr{\top}{\Prop}} &=& \mathcal{S} \\
% %     \semantic{\Tjr{\emp}{\Prop}} &=& \{s \mid s = \cdot\} \\
% %     \semantic{\Tjr{=^\tau}{\tau \to \tau \to \Prop}} &=& \phi:\semantic{\tau} \to \semantic{\tau}\to\semantic{\Prop} \\
% %     && \phi\,d_1\,d_2 = \{s \mid d_1 = d_2\} \\
% %     \semantic{\Tjr{\mapsto}{\Data \to \Data \to \Prop}} &=& \phi:\semantic{\Data}\to\semantic{\Data}\to\semantic{\Prop} \\
% %     && \phi\,d_1\,d_2 = \{s \mid s = \cdot,d_1:d_2\} \\
% %     \semantic{\Tjr{\rep{\Bool}}{\Data \to \Bool \to \Prop}} &=& \phi:\semantic{\Data}\to\semantic{\Bool}\to\semantic{\Prop} \\
% %     && \phi\,d_1\,d_2 = \{s \mid (d_1 = \true \wedge d_2 = \true) \vee (d_1 = \false \wedge d_2 = \false) \} \\
% %   \end{array}\]
  
% %   \[\begin{array}{rcl}
% %     \semantic{\Tj{\Gamma}{x}{\omega}}\,\eta &=& \eta(x) \\
% %     \semantic{\Tj{\Gamma}{\abstr{x:\omega}{p}}{\omega \tto \omega'}}\,\eta &=& \abstr{d\in\semantic{\omega}}{\semantic{\Tj{\Gamma,x:\omega}{p}{\omega'}}\,(\eta[d/x])} \\
% %     \semantic{\Tj{\Gamma}{\app{p}{q}}{\omega'}}\,\eta &=& \app{(\semantic{\Tj{\Gamma}{p}{\omega \tto \omega'}}\,\eta)}{(\semantic{\Tj{\Gamma}{q}{\omega}}\,\eta)} \\
% %     \semantic{\Tj{\Gamma}{\top}{\Prop}}\,\eta &=& \mathcal{S} \\
% %     \semantic{\Tj{\Gamma}{\bot}{\Prop}}\,\eta &=& \emptyset \\
% %     \semantic{\Tj{\Gamma}{p =^\omega q}{\Prop}}\,\eta &=& \{s \mid \semantic{\Tj{\Gamma}{p}{\omega}}\,\eta = \semantic{\Tj{\Gamma}{q}{\omega}}\,\eta\} \\
% %     \semantic{\Tj{\Gamma}{p \wedge q}{\Prop}}\,\eta &=& (\semantic{\Tj{\Gamma}{p}{\Prop}}\,\eta) \cap (\semantic{\Tj{\Gamma}{q}{\Prop}}\,\eta) \\
% %     \semantic{\Tj{\Gamma}{p \vee q}{\Prop}}\,\eta &=& (\semantic{\Tj{\Gamma}{p}{\Prop}}\,\eta) \cup (\semantic{\Tj{\Gamma}{q}{\Prop}}\,\eta) \\
% %     \semantic{\Tj{\Gamma}{\neg p}{\Prop}}\,\eta &=& \mathcal{S} \setminus (\semantic{\Tj{\Gamma}{p}{\Prop}}\,\eta) \\
% %     \semantic{\Tj{\Gamma}{p \supset q}{\Prop}}\,\eta &=& (\semantic{\Tj{\Gamma}{p}{\Prop}}\,\eta) \supset (\semantic{\Tj{\Gamma}{q}{\Prop}}\,\eta) \\
% %     \semantic{\Tj{\Gamma}{\qall{x:\omega}{p}}{\Prop}}\,\eta &=& \bigcap_{d\in\semantic{\omega}} \semantic{\Tj{\Gamma}{p}{\Prop}}\,(\eta[d/x]) \\
% %     \semantic{\Tj{\Gamma}{\qex{x:\omega}{p}}{\Prop}}\,\eta &=& \bigcup_{d\in\semantic{\omega}} \semantic{\Tj{\Gamma}{p}{\Prop}}\,(\eta[d/x]) \\
% %     \semantic{\Tj{\Gamma}{\emp}{\Prop}}\,\eta &=& \{s \mid s = \cdot \} \\
% %     \semantic{\Tj{\Gamma}{p * q}{\Prop}}\,\eta &=& (\semantic{\Tj{\Gamma}{p}{\Prop}}\,\eta) * (\semantic{\Tj{\Gamma}{q}{\Prop}}\,\eta) \\
% %     \semantic{\Tj{\Gamma}{t_1 \mapsto^\tau t_2}{\Prop}}\,\eta &=& \bigl\{s \mid s = \bigl(\cdot,(\semantic{\Tj{\Gamma}{t_1}{\Ref{\tau}}}\,\eta):(\semantic{\Tj{\Gamma}{t_2}{\tau}}\,\eta)\bigr)\bigr\} \\
% %     \semantic{\Tj{\Gamma}{\tc{p}{e}{x:\tau}{q}}{\Prop}}\,\eta &=& \{s \mid \eta(e) \text{ is correct wrt. } \semantic{\Tj{\Gamma}{p}{\Prop}}\,\eta \\
% %     && \quad \quad \text{and } \semantic{\Tj{\Gamma}{\abstr{x:\tau}{q}}{\tau \tto \Prop}}\,\eta \} \\
% %     \semantic{\Tj{\Gamma}{\{p\}}{\Prop}}\,\eta &=& \{s \mid \semantic{\Tj{\Gamma}{p}{\Prop}}\,\eta = \mathcal{S} \} \\
% %   \end{array}\]
% % }


% % \section{The programming language}

% % \begin{definition}[Expressions, Values, Stores]
% %   \[\GRbeg
% %   \tau \in \ProgType \GRis \Nat \GRmid \Unit \GRal \Ref{\tau} \GRmid
% %   \tau_1 \to \tau_2 \GRmid \tau_1 \times \tau_2
% %   \\
% %   e \in \Exp \GRis \z \GRmid \succ{e} \GRmid
% %   \iternat{e}{e_z}{x^\tau}{e_n} \GRal x^\tau \GRmid
% %   \fn{x^\tau}{e} \GRmid \app{e_1}{e_2} \GRal \unit \GRal
% %   (e_1,e_2) \GRmid \fst{e} \GRmid \snd{e} \GRal \ell^\tau \GRmid
% %   \new{\tau}{e} \GRmid \deref{e} \GRmid \assign{e_1}{e_2}
% %   \\
% %   v \in \Val \GRis \z \GRmid \succ{v} \GRmid \fn{x^\tau}{e}
% %   \GRmid \unit \GRmid (v_1,v_2) \GRmid \ell^\tau
% %   \\
% %   s \in \Store \GRis \cdot \GRmid s,\ell^\tau:v
% %   \\
% %   \Gamma \in \Context \GRis \cdot \GRmid \Gamma,x:\omega \GRend\]
% % \end{definition}

% % \begin{tabular}{cc}
% %   $\Tj{\Gamma}{\z}{\Nat}$
% %   & $\Tj{\Gamma}{\unit}{\Unit}$ \\[1mm]
% %   $\RULE{x:\tau \in \Gamma}{\Tj{\Gamma}{x}{\tau}}$
% %   & $\Tj{\Gamma}{\ell^\tau}{\Ref{\tau}}$ \\[3mm]
% %   $\RULE{\Tj{\Gamma}{e}{\Nat} \quad \Tj{\Gamma}{e_z}{\tau} \quad \Tj{\Gamma,x:\tau}{e_n}{\tau}}{\Tj{\Gamma}{\iternat{e}{e_z}{x}{e_n}}{\tau}}$ 
% %   & $\RULE{\Tj{\Gamma,x:\tau}{e}{\tau'}}{\Tj{\Gamma}{\fn{x:\tau}{e}}{\tau \to \tau'}}$ \\[3mm]
% %   $\RULE{\Tj{\Gamma}{e_1}{\tau \to \tau'} \quad \Tj{\Gamma}{e_2}{\tau}}{\Tj{\Gamma}{\app{e_1}{e_2}}{\tau'}}$
% %   & $\RULE{\Tj{\Gamma}{e}{\Nat}}{\Tj{\Gamma}{\succ{e}}{\Nat}}$ \\[3mm]
% %   $\RULE{\Tj{\Gamma}{e_1}{\tau_1} \quad \Tj{\Gamma}{e_2}{\tau_2}}{\Tj{\Gamma}{(e_1,e_2)}{\tau_1 \times \tau_2}}$
% %   & $\RULE{\Tj{\Gamma}{e}{\tau_1 \times \tau_2}}{\Tj{\Gamma}{\fst{e}}{\tau_1}}$ \\[3mm]
% %   $\RULE{\Tj{\Gamma}{e}{\tau_1 \times \tau_2}}{\Tj{\Gamma}{\snd{e}}{\tau_2}}$
% %   & $\RULE{\Tj{\Gamma}{e}{\tau}}{\Tj{\Gamma}{\new{\tau}{e}}{\Ref{\tau}}}$ \\[3mm]
% %   $\RULE{\Tj{\Gamma}{e}{\Ref{\tau}}}{\Tj{\Gamma}{\deref{e}}{\tau}}$
% %   & $\RULE{\Tj{\Gamma}{e_1}{\Ref{\tau}} \quad \Tj{\Gamma}{e_2}{\tau}}{\Tj{\Gamma}{\assign{e_1}{e_2}}{\Unit}}$ \\[3mm]
% %   \\
% %   $\tj{\Gamma}{\cdot}$
% %   & $\RULE{\tj{\Gamma}{s} \quad \Tj{\Gamma}{v}{\tau}}{\tj{\Gamma}{s,\ell^\tau:v}}$ \\[3mm]
% %   \multicolumn{2}{c}{$\RULE{\Tj{\Gamma}{e}{\tau} \quad \tj{\Gamma}{s}}{\Tj{\Gamma}{\conf{e}{s}}{\tau}}$} \\[3mm]
% % \end{tabular}

% % \begin{tabular}{cc}
% %   $\RULE{\conf{e_1}{s} \step \conf{e_1'}{s'}}{\conf{(e_1,e_2)}{s} \step \conf{(e_1',e_2)}{s'}}$
% %   & $\RULE{\conf{e_1}{s} \step \abort}{\conf{(e_1,e_2)}{s} \step \abort}$ \\[3mm]
% %   $\RULE{\conf{e}{s} \step \conf{e'}{s'}}{\conf{(v,e)}{s} \step \conf{(v,e)}{s'}}$
% %   & $\RULE{\conf{e}{s} \step \abort}{\conf{(v,e)}{s} \step \abort}$ \\[3mm]
% %   $\RULE{\conf{e}{s} \step \conf{e'}{s'}}{\conf{\fst{e}}{s} \step \conf{\fst{e'}}{s'}}$
% %   & $\RULE{\conf{e}{s} \step \abort}{\conf{\fst{e}}{s} \step \abort}$ \\[3mm]
% %   $\RULE{\conf{e}{s} \step \conf{e'}{s'}}{\conf{\snd{e}}{s} \step \conf{\snd{e'}}{s'}}$
% %   & $\RULE{\conf{e}{s} \step \abort}{\conf{\snd{e}}{s} \step \abort}$ \\[4mm]
% %   $\conf{\fst{(v_1,v_2)}}{s} \step \conf{v_1}{s}$
% %   & $\conf{\snd{(v_1,v_2)}}{s} \step \conf{v_2}{s}$ \\[2mm]
% %   $\RULE{\conf{e}{s} \step \conf{e'}{s'}}{\conf{\new{\tau}{e}}{s} \step \conf{\new{\tau}{e'}}{s'}}$
% %   & $\RULE{\conf{e}{s} \step \abort}{\conf{\new{\tau}{e}}{s} \step \abort}$ \\[3mm]
% %   \multicolumn{2}{c}{$\RULE{\ell^\tau \not\in\dom{s} \quad s' = s,\ell^\tau:v}{\conf{\new{\tau}{v}}{s} \step \conf{\ell^\tau}{s'}}$} \\[3mm]
% %   $\RULE{\conf{e}{s} \step \conf{e'}{s'}}{\conf{\deref{e}}{s} \step \conf{\deref{e'}}{s'}}$
% %   & $\RULE{\conf{e}{s} \step \abort}{\conf{\deref{e}}{s} \step \abort}$ \\[3mm]
% %   $\RULE{\ell^\tau:v \in s}{\conf{\deref{\ell^\tau}}{s} \step \conf{v}{s}}$
% %   & $\RULE{\ell^\tau \not\in \dom{s}}{\conf{\deref{\ell^\tau}}{s} \step \abort}$ \\[3mm]
% %   $\RULE{\conf{e_1}{s} \step \conf{e_1'}{s'}}{\conf{\assign{e_1}{e_2}}{s} \step \conf{\assign{e_1'}{e_2}}{s'}}$
% %   & $\RULE{\conf{e_1}{s} \step \abort}{\conf{\assign{e_1}{e_2}}{s} \step \abort}$ \\[3mm]
% %   $\RULE{\conf{e}{s} \step \conf{e'}{s'}}{\conf{\assign{\ell^\tau}{e}}{s} \step \conf{\assign{\ell^\tau}{e'}}{s'}}$
% %   & $\RULE{\conf{e}{s} \step \abort}{\conf{\assign{\ell^\tau}{e}}{s} \step \abort}$ \\[3mm]
% %   $\RULE{\ell^\tau \in \dom{s} \quad s' = s,\ell^\tau:v}{\conf{\assign{\ell^\tau}{v}}{s} \step \conf{\unit}{s'}}$
% %   & $\RULE{\ell^\tau \not\in \dom{s}}{\conf{\assign{\ell^\tau}{v}}{s} \step \abort}$ \\[3mm]
% %   $\RULE{\conf{e_1}{s} \step \conf{e_1'}{s'}}{\conf{\app{e_1}{e_2}}{s} \step \conf{\app{e_1'}{e_2}}{s'}}$
% %   & $\RULE{\conf{e_1}{s} \step \abort}{\conf{\app{e_1}{e_2}}{s} \step \abort}$ \\[3mm]
% %   $\RULE{\conf{e}{s} \step \conf{e'}{s'}}{\conf{\app{v}{e}}{s} \step \conf{\app{v}{e'}}{s'}}$
% %   & $\RULE{\conf{e}{s} \step \abort}{\conf{\app{v}{e}}{s} \step \abort}$ \\[4mm]
% %   \multicolumn{2}{c}{$\conf{\app{(\fn{x}{e})}{v}}{s} \step \conf{e[v/x]}{s}$} \\[2mm]
% %   \multicolumn{2}{c}{$\RULE{\conf{e}{s} \step \conf{e'}{s'}}{\conf{\iternat{e}{e_z}{x}{e_n}}{s} \step \conf{\iternat{e'}{e_z}{x}{e_n}}{s'}}$} \\[3mm]
% %   $\RULE{\conf{e}{s} \step \abort}{\conf{\iternat{e}{e_z}{x}{e_n}}{s} \step \abort}$
% %   & $\conf{\iternat{\z}{e_z}{x}{e_n}}{s} \step \conf{e_z}{s}$ \\[3mm]
% %   \multicolumn{2}{c}{$\conf{\iternat{\succ{v}}{e_z}{x}{e_n}}{s} \step \conf{e_n[\iternat{v}{e_z}{x}{e_n}/x]}{s}$} \\[1mm]
% % \end{tabular}

% % \begin{theorem}[Preservation]
% %   If $\Tj{\Gamma}{\conf{e}{s}}{\tau}$ and $\conf{e}{s} \step
% %   \conf{e'}{s'}$, then $\Tj{\Gamma}{\conf{e'}{s'}}{\tau}$.
% % \end{theorem}

% % \begin{theorem}[Progress]
% %   If $\Tj{\cdot}{\conf{e}{s}}{\tau}$, then either $e$ is already a
% %   value, or there exist $e'$ and $s'$ such that $\conf{e}{s} \step
% %   \conf{e'}{s'}$, or $\conf{e}{s} \step \abort$.
% % \end{theorem}

% % \section{Assertion language}

% % \begin{definition}[Terms]
% %   \[\GRbeg
% %   t \in \Term \GRis \z \GRmid \succ{t} \GRmid
% %   \iternat{t}{t_z}{x}{t_n} \GRal
% %   x %\GRmid \fn{x^\tau}{t} \GRmid \app{t_1}{t_2}
% %   \GRal \unit \GRal (t_1,t_2) \GRmid \fst{t} \GRmid \snd{t} \GRend\]
% % \end{definition}

% % \begin{definition}[Assertions]
% %   \[\GRbeg
% %   \omega \in \AssnType \GRis \tau \GRmid \Prop \GRmid \omega_1 \tto
% %   \omega_2
% %   \\
% %   p,q \in \Assn \GRis t \GRmid \top \GRmid \bot \GRmid p =^\omega q
% %   \GRal p \wedge q \GRmid p \vee q \GRmid \neg p \GRmid p \supset q
% %   \GRal x \GRmid \fn{x:\omega}{p} \GRmid \app{p}{q} \GRmid
% %   \qall{x:\omega}{p} \GRmid \qex{x:\omega}{p} \GRal \emp \GRmid p
% %   \sepcon q \GRmid t_1 \mapsto^\tau t_2 \GRmid
% %   \triplex{p}{e}{x:\tau}{q} \GRmid \{p\} \GRal
% %   \iternat{t}{p_z}{x}{p_n} \GRend\]
% % \end{definition}

% % \begin{tabular}{cc}
% %   $\RULE{x:\omega\in\Gamma}{\Tj{\Gamma}{x}{\omega}}$
% %   & $\RULE{\mathbf{c} \in \{\top,\bot,\emp\}}{\Tj{\Gamma}{\mathbf{c}}{\Prop}}$ \\[3mm]
% %   $\RULE{\Tj{\Gamma}{p}{\omega} \quad \Tj{\Gamma}{q}{\omega}}{\Tj{\Gamma}{p =_\omega q}{\Prop}}$
% %   & $\RULE{\Tj{\Gamma}{p}{\Prop} \quad \Tj{\Gamma}{q}{\Prop} \quad \Box \in \{\wedge,\vee,\supset,\sepcon\}}{\Tj{\Gamma}{p\,\Box\,q}{\Prop}}$ \\[3mm]
% %   $\RULE{\Tj{\Gamma}{p}{\Prop}}{\Tj{\Gamma}{\neg p}{\Prop}}$
% %   & $\RULE{\Tj{\Gamma,x:\omega}{p}{\Prop} \quad Q \in \{\forall,\exists\}}{\Tj{\Gamma}{Q x:\omega.\,p}{\Prop}}$ \\[3mm]
% %   $\RULE{\Tj{\Gamma,x:\omega}{p}{\omega'}}{\Tj{\Gamma}{\fn{x:\omega}{p}}{\omega \tto \omega'}}$ 
% %   & $\RULE{\Tj{\Gamma}{p}{\omega \tto \omega'} \quad \Tj{\Gamma}{q}{\omega}}{\Tj{\Gamma}{\app{p}{q}}{\omega'}}$ \\[3mm]
% %   $\RULE{\Tj{\Gamma}{t_1}{\Ref{\tau}} \quad \Tj{\Gamma}{t_2}{\tau}}{\Tj{\Gamma}{t_1 \mapsto_\tau t_2}{\Prop}}$
% %   & $\RULE{\Tj{\Gamma}{p}{\Prop} \quad \Tj{\Gamma}{e}{\tau} \quad \Tj{\Gamma,x:\tau}{q}{\Prop}}{\Tj{\Gamma}{\triplex{p}{e}{x:\tau}{q}}{\Prop}}$ \\[3mm]
% %   $\RULE{\Tj{\Gamma}{p}{\Prop}}{\Tj{\Gamma}{\{p\}}{\Prop}}$
% %   & $\RULE{\Tj{\Gamma}{t}{\Nat} \quad \Tj{\Gamma}{p_z}{\omega} \quad \Tj{\Gamma,x:\omega}{p_n}{\omega}}{\Tj{\Gamma}{\iternat{t}{p_z}{x}{p_n}}{\omega}}$ \\[3mm]
% % \end{tabular}

% % \subsection{The Semantics of Assertions}

% % Let $\mathcal{S} = \{s\,|\,\tj{\cdot}{s}\}$ be the set of all
% % well-typed stores.
% % \[\begin{array}{rcl}
% %   S_1 \sepcon S_2 &=& \{s\in\mathcal{S}\,|\,\exists s_1 \in S_1,s_2\in S_2.\,s = s_1 \oplus s_2\} \\
% %   S_1 \supset S_2 &=& \{s\in\mathcal{S}\,|\,s \in S_1 \text{ implies } s \in S_2\}
% % \end{array}\]

% % \begin{lemma}[Safety Monotonicity]
% %   If $\Tj{\cdot}{e}{\tau}$, $\tj{\cdot}{s \oplus s'}$ and
% %   $\conf{e}{s} \not\step^* \abort$, then $\conf{e}{s \oplus s'}
% %   \not\step^* \abort$.
% % \end{lemma}

% % \begin{lemma}[Frame Property]
% %   Suppose $\Tj{\cdot}{e}{\tau}$, $\tj{\cdot}{s_0 \oplus s}$,
% %   $\conf{e}{s_0} \not\step^* \abort$ and $\conf{e}{s_0 \oplus s}
% %   \step^* \conf{v}{s'}$. Then there exists some $s_0'$ such that
% %   $\conf{e}{s_0} \step^* \conf{v}{s_0'}$ with $s' = s_0' \oplus s$.
% % \end{lemma}

% % \begin{definition}[Semantic domains]
% %   \[\begin{array}{rcl}
% %   \semantic{\tau} &=& \{v\,|\,\Tj{\cdot}{v}{\tau}\} \\
% %   \semantic{\Prop} &=& \mathcal{P}(\mathcal{S}) \\
% %   \semantic{\omega_1 \tto \omega_2} &=& \semantic{\omega_2}^{\semantic{\omega_1}}
% %   \end{array}\]
% % \end{definition}

% % $(\semantic{\Tj{\Gamma}{p}{\omega}}\,\eta) \in \semantic{\omega}$
% % for $\tj{\Gamma}{\eta}$
% % \[\begin{array}{rcl}
% %   \semantic{\Tj{\Gamma}{\z}{\Nat}}\,\eta &=& \z \\
% %   \semantic{\Tj{\Gamma}{\succ{t}}{\Nat}}\,\eta &=& \succ{(\semantic{\Tj{\Gamma}{t}{\Nat}}\,\eta)} \\
% %   \semantic{\Tj{\Gamma}{\unit}{\Unit}}\,\eta &=& \unit \\
% %   \semantic{\Tj{\Gamma}{(t_1,t_2)}{\tau_1 \times \tau_2}}\,\eta &=& (\semantic{\Tj{\Gamma}{t_1}{\tau_1}}\,\eta,\semantic{\Tj{\Gamma}{t_2}{\tau_2}}\,\eta) \\
% %   \semantic{\Tj{\Gamma}{\fst{t}}{\tau_1}}\,\eta &=& v_1, \text{where } (v_1,v_2) = (\semantic{\Tj{\Gamma}{t}{\tau_1 \times \tau_2}}\,\eta) \\
% %   \semantic{\Tj{\Gamma}{\snd{t}}{\tau_2}}\,\eta &=& v_2, \text{where } (v_1,v_2) = (\semantic{\Tj{\Gamma}{t}{\tau_1 \times \tau_2}}\,\eta) \\
% % \end{array}\]
% % \[\begin{array}{rcl}
% %   \semantic{\Tj{\Gamma}{\top}{\Prop}}\,\eta &=& \mathcal{S} \\
% %   \semantic{\Tj{\Gamma}{\bot}{\Prop}}\,\eta &=& \emptyset \\
% %   \semantic{\Tj{\Gamma}{p =^\omega q}{\Prop}}\,\eta &=& \{s\in\mathcal{S}\,|\,\semantic{\Tj{\Gamma}{p}{\omega}}\,\eta = \semantic{\Tj{\Gamma}{q}{\omega}}\,\eta\} \\
% %   \semantic{\Tj{\Gamma}{\iternat{t}{p_z}{x}{p_n}}{\omega}}\,\eta &=& \fold_\N \\
% %   && \quad (\semantic{\Tj{\Gamma}{p_z}{\omega}}\,\eta) \\
% %   && \quad (\fn{d\in\semantic{\omega}}{\semantic{\Tj{\Gamma,x:\omega}{p_n}{\omega}}\,(\eta[d/x])}) \\
% %   && \quad (\semantic{\Tj{\Gamma}{t}{\Nat}}\,\eta) \\
% %   \semantic{\Tj{\Gamma}{p \wedge q}{\Prop}}\,\eta &=& (\semantic{\Tj{\Gamma}{p}{\Prop}}\,\eta) \cap (\semantic{\Tj{\Gamma}{q}{\Prop}}\,\eta) \\
% %   \semantic{\Tj{\Gamma}{p \vee q}{\Prop}}\,\eta &=& (\semantic{\Tj{\Gamma}{p}{\Prop}}\,\eta) \cup (\semantic{\Tj{\Gamma}{q}{\Prop}}\,\eta) \\
% %   \semantic{\Tj{\Gamma}{\neg p}{\Prop}}\,\eta &=& \mathcal{S} \setminus (\semantic{\Tj{\Gamma}{p}{\Prop}}\,\eta) \\
% %   \semantic{\Tj{\Gamma}{p \supset q}{\Prop}}\,\eta &=& (\semantic{\Tj{\Gamma}{p}{\Prop}}\,\eta) \supset (\semantic{\Tj{\Gamma}{q}{\Prop}}\,\eta) \\
% %   \semantic{\Tj{\Gamma}{x}{\omega}}\,\eta &=& \eta(x) \\
% %   \semantic{\Tj{\Gamma}{\fn{x:\omega}{p}}{\omega \tto \omega'}}\,\eta &=& \fn{d\in \semantic{\omega}}{\semantic{\Tj{\Gamma,x:\omega}{p}{\omega'}}\,(\eta[d/x])} \\
% %   \semantic{\Tj{\Gamma}{\app{p}{q}}{\omega}}\,\eta &=& \app{(\semantic{\Tj{\Gamma}{p}{\omega' \tto \omega}}\,\eta)}{(\semantic{\Tj{\Gamma}{q}{\omega'}}\,\eta)} \\
% %   \semantic{\Tj{\Gamma}{\qall{x:\omega}{p}}{\Prop}}\,\eta &=& \bigcap_{d \in \semantic{\omega}} \semantic{\Tj{\Gamma,x:\omega}{p}{\Prop}}\,(\eta[d/x]) \\
% %   \semantic{\Tj{\Gamma}{\qex{x:\omega}{p}}{\Prop}}\,\eta &=& \bigcup_{d \in \semantic{\omega}} \semantic{\Tj{\Gamma,x:\omega}{p}{\Prop}}\,(\eta[d/x]) \\
% %   \semantic{\Tj{\Gamma}{\emp}{\Prop}}\,\eta &=& \{\cdot\} \\
% %   \semantic{\Tj{\Gamma}{p \sepcon q}{\Prop}}\,\eta &=& (\semantic{\Tj{\Gamma}{p}{\Prop}}\,\eta) \sepcon (\semantic{\Tj{\Gamma}{q}{\Prop}}\,\eta) \\
% %   \semantic{\Tj{\Gamma}{t_1 \mapsto^\tau t_2}{\Prop}}\,\eta &=& \{s\in\mathcal{S}\,|\,s=\cdot,(\semantic{\Tj{\Gamma}{t_1}{\Ref{\tau}}}\,\eta):(\semantic{\Tj{\Gamma}{t_2}{\tau}}\,\eta)\} \\
% %   \semantic{\Tj{\Gamma}{\triplex{p}{e}{x:\tau}{q}}{\Prop}}\,\eta &=& \{s\in\mathcal{S}\,|\,\text{if $\eta(e)$ is totally correct wrt. $\semantic{\Tj{\Gamma}{p}{\Prop}}\,\eta$} \\
% %     && \text{and $\semantic{\Tj{\Gamma}{\fn{x:\tau}{q}}{\tau \tto \Prop}}\,\eta$}\} \\
% %   \semantic{\Tj{\Gamma}{\{p\}}{\Prop}}\,\eta &=& \{s\in\mathcal{S}\,|\,(\semantic{\Tj{\Gamma}{p}{\Prop}}\,\eta) = \mathcal{S}\} \\
% % \end{array}\]

% % \section{The calculus}

% % {\footnotesize
% %   \begin{tabular}{rl}
% %   \RN{Frame} & $\RULE{x \not\in \FV{r}}{\Tj{\Gamma}{\triplex{p}{e}{x:\tau}{q} \supset \triplex{p \sepcon r}{e}{x:\tau}{q \sepcon r}}{\Prop}}$ \\[4mm]
% %   \RN{Consequence} & $\Tj{\Gamma}{\bigl(\{p \supset p'\} \wedge \triplex{p'}{e}{x:\tau}{q'} \wedge \forall x:\tau.\,\{q' \supset q\}\bigr) \supset \triplex{p}{e}{x:\tau}{q}}{\Prop}$ \\[2mm]
% %   \RN{New} & $\RULE{y \not\in \FV{q}}{\Tj{\Gamma}{\triplex{p}{e}{x:\tau}{q} \supset \triplex{p}{\new{\tau}{e}}{y:\Ref{\tau}}{y \mapsto_\tau x \sepcon q}}{\Prop}}$ \\[3mm]
% %   \RN{Deref} & $\RULE{}{\Tj{\Gamma}{\triplex{p}{e}{x:\Ref{\tau}}{q \wedge x \mapsto_\tau y} \supset \triplex{p}{\deref{e}}{y:\tau}{\qex{x:\Ref{\tau}}{x \mapsto_\tau y \wedge q}}}{\Prop}}$ \\[3mm]
% % \end{tabular}}

% % \section{Types}

% % \begin{definition}
% %   The sets $\Type$ of {\em expression types} $\tau$, $\TType$ of
% %   {\em term types} $\sigma$ and $\LType$ of {\em logical types}
% %   $\theta$ are defined by the following grammar:
% %   \[\GRbeg
% %   \tau \GRis \tbool \GRmid \tint \GRmid \tref{\tau} \GRmid
% %   \tarrow{\tau_1}{\tau_2} \GRmid \tuple{\tau_1,\ldots,\tau_n} \quad
% %   (n \ge 0)
% %   \\
% %   \sigma \GRis \tau \GRmid \ttarrow{\sigma_1}{\sigma_2} \GRmid
% %   \ttuple{\sigma_1,\ldots,\sigma_n} \quad (n \ge 2)
% %   \\
% %   \theta \GRis \sigma \GRmid \tassn[\sigma] \GRend\]
% % \end{definition}

% % We write $\tunit$ instead of $\tuple{}$ and $\tassn$ instead of
% % $\tassn[\tunit]$.

% % We assume that disjoint infinite sets $\Var^\theta$ of {\em
% %   $\theta$-variables} $x^\theta$ for each $\theta\in\LType$ and
% % $\Loc^\tau$ of {\em $\tau$-locations} $\ell^\tau$ for each
% % $\tau\in\Type$ are given.  Then we have sets $\Var =
% % \bigcup_{\theta\in\LType}\Var^\theta$ of {\em variables} $x$ and
% % $\Loc = \bigcup_{\tau\in\Type}\Loc^\tau$ of {\em locations} $\ell$,
% % where variables are used to abstract expressions and locations are
% % used to identify memory cells.


% % \section{The programming language}

% % $\Bool=\{\true,\false\}$ is the set of boolean constants $b$, $\Int$
% % is the set of integer constants $z$. We do not distinguish between
% % integer values their program representation.

% % \begin{definition}[Expressions]
% %   The set $\Op$ of {\em operators} $\op$ and the set $\Const$ of
% %   {\em constants} $c$ are defined by the grammars
% %   \[\GRbeg
% %   \aop \GRis + \GRmid - \GRmid * \\
% %   \rop \GRis = \GRmid < \GRmid > \GRmid \le \GRmid \ge \\
% %   \op \GRis \aop \GRmid \rop \\
% %   c \GRis z \GRmid b \GRmid \cref \GRmid ! \GRmid \assign
% % %   \GRmid \fix
% %   \GRmid \op \GRmid \proj{n}{i},
% % %   \GRmid \fst \GRmid \snd,
% %   \GRend\] the set $\Exp$ of {\em expressions} $e$ is defined by
% %   \[\GRbeg
% %   e \GRis c \GRmid x^\tau \GRmid \ell \GRmid \fn{x^\tau}{e}
% %   \GRmid \app{e_1}{e_2} \GRmid \ifte{e_0}{e_1}{e_2} \GRmid
% %   \tuple{e_1,\ldots,e_n} \GRend\] and the set $\Val \subseteq \Exp$
% %   of {\em values} $v$ is defined by
% %   \[\GRbeg
% %   v \GRis c \GRmid \ell \GRmid \fn{x^\tau}{e} \GRmid \app{\op}{v}
% %   \GRmid \app{\assign}{v} \GRmid \tuple{v_1,\ldots,v_n} \GRend\]
% % \end{definition}

% % Expressions are considered equal modulo renaming of bound variables.
% % The empty tuple $\tuple{}$ is sometimes referred to as the {\em unit
% %   constant}.

% % $\free{e}$ denotes the set of free variables and $\locns{e}$ denotes
% % the set of locations in the expression $e$.  We say that $e$ is {\em
% %   closed} if $\free{e}=\emptyset$. $e$ is called a {\em program} if
% % $\free{e}\cup\locns{e}=\emptyset$, that is, if $e$ contains neither
% % unbound variables nor locations (i.e.  memory addresses in terms of
% % the underlying machine). We demand that all expressions considered
% % for the logic later are valid programs (i.e. programmers aren't
% % permitted to access arbitrary memory locations).


% % \subsection{Static semantics}

% % \begin{definition}[Typing relation for expressions]
% %   The {\em typing relation for expressions}, written $\tj{e}{\tau}$,
% %   is the smallest relation between expressions and types satisfying
% %   all instances of the rules in
% %   figure~\ref{fig:Typing_rules_for_constants} and
% %   figure~\ref{fig:Typing_rules_for_expressions}. An expression $e$
% %   is {\em well typed} if there is some $\tau\in\Type$ such that
% %   $\tj{e}{\tau}$.
% % \end{definition}

% % \begin{figure}[htb]
% %   \centering
% %   \begin{tabular}{rll}
% %     \RN{T-Int} & $\tj{z}{\tint}$ \\[1mm]
% %     \RN{T-Bool} & $\tj{b}{\tbool}$ \\[1mm]
% %     \RN{T-Ref} & $\tj{\cref}{\tarrow{\tau}{\tref{\tau}}}$ \\[1mm]
% %     \RN{T-Deref} & $\tj{!}{\tarrow{\tref{\tau}}{\tau}}$ \\[1mm]
% %     \RN{T-Assign} & $\tj{\assign}{\tarrow{\tref{\tau}}{\tarrow{\tau}{\tunit}}}$ \\[1mm]
% %     \RN{T-Aop} & $\tj{\aop}{\tarrow{\tint}{\tarrow{\tint}{\tint}}}$ \\[1mm]
% %     \RN{T-Rop} & $\tj{\rop}{\tarrow{\tint}{\tarrow{\tint}{\tbool}}}$ \\[1mm]
% %     \RN{T-Proj} & $\tj{\proj{n}{i}}{\tarrow{\tuple{\tau_1,\ldots,\tau_n}}{\tau_i}}$
% %   \end{tabular}
% %   \caption{Typing rules for constants}
% %   \label{fig:Typing_rules_for_constants}
% % \end{figure}

% % \begin{figure}[htb]
% %   \centering
% %   \begin{tabular}{rl}
% %     \RN{T-Var} & $\tj{x^\tau}{\tau}$ \\[1mm]
% %     \RN{T-Loc} & $\tj{\ell^\tau}{\tref{\tau}}$ \\[1mm]
% %     \RN{T-Abstr} & $\RULE{\tj{e}{\tau'}}{\tj{\fn{x^\tau}{e}}{\tarrow{\tau}{\tau'}}}$ \\[3mm]
% %     \RN{T-App} & $\RULE{\tj{e_1}{\tarrow{\tau}{\tau'}} \quad \tj{e_2}{\tau}}{\tj{\app{e_1}{e_2}}{\tau'}}$ \\[3mm]
% %     \RN{T-Cond} & $\RULE{\tj{e_0}{\tbool} \quad \tj{e_1}{\tau} \quad \tj{e_2}{\tau}}{\tj{\ifte{e_0}{e_1}{e_2}}{\tau}}$ \\[3mm]
% %     \RN{T-Tuple} & $\RULE{\tj{e_1}{\tau_1} \quad \ldots \quad \tj{e_n}{\tau_n}}{\tj{\tuple{e_1,\ldots,e_n}}{\tuple{\tau_1,\ldots,\tau_n}}}$
% %   \end{tabular}
% %   \caption{Typing rules for expressions}
% %   \label{fig:Typing_rules_for_expressions}
% % \end{figure}


% % \subsection{Operational semantics}

% % Let $(W,\subseteq) = (\powersetfin{\Loc},\subseteq)$ be a partial
% % order of ``possible worlds''.

% % \begin{definition}[Store]
% %   A {\em store} is a finite partial mapping $s:\Loc \pto \CVal$,
% %   such that $s(\Loc^\tau) \subseteq \CVal^\tau$ for all
% %   $\tau\in\Type$.  $\Store$ denotes the set of all such stores.
% % \end{definition}

% % A {\em configuration} $k$ is a pair $(e,s)$.  $\Conf$ denotes the
% % set of all configurations.

% % \begin{figure}[ht]
% %   \centering {\small
% %     \begin{tabular}{rl}
% %     \RN{E-AppLeft} & $\RULE{(e_1,s) \to (e_1',s')}{(\app{e_1}{e_2},s)\to(\app{e_1'}{e_2},s')}$ \\[3mm]
% %     \RN{E-AppRight} & $\RULE{(e,s) \to (e',s')}{(\app{v}{e},s)\to(\app{v}{e'},s')}$ \\[3mm]
% %     \RN{E-AppOp} & $(\app{\app{\op}{z_1}}{z_2},s) \to (\op^I(z_1,z_2),s)$ \\[1mm]
% %     \RN{E-AppAbs} & $(\app{(\fn{x}{e})}{v},s) \to (e[v/x],s)$ \\[1mm]
% %     \RN{E-AppProj} & $(\app{\proj{n}{i}}{\tuple{v_1,\ldots,v_n}},s) \to (v_i,s)$ \\[1mm]
% %     \RN{E-AppDeref} & $(\app{!}{\ell},s) \to (s(\ell),s)$ $\quad$ where $\ell\in\dom{s}$ \\[1mm]
% %     \RN{E-AppAssign} & $(\app{\app{\assign}{\ell}}{v},s) \to (\unit,s[v/\ell])$ $\quad$ where $\ell\in\dom{s}$ \\[1mm]
% %     \RN{E-AppRef} & $(\app{\cref}{v},s) \to (\ell,s[v/\ell])$ $\quad$ where $\tj{v}{\tau}$ and $\ell \in \Loc^\tau \setminus \dom{s}$ \\[1mm]
% %     \RN{E-CondEval} & $\RULE{(e_0,s) \to (e_0',s')}{(\ifte{e_0}{e_1}{e_2},s)\to(\ifte{e_0'}{e_1}{e_2},s')}$ \\[3mm]
% %     \RN{E-CondTrue} & $(\ifte{\true}{e_1}{e_2},s) \to (e_1,s)$ \\[1mm]
% %     \RN{E-CondFalse} & $(\ifte{\false}{e_1}{e_2},s) \to (e_2,s)$ \\[1mm]
% %     \RN{E-Tuple} & $\RULE{(e_i,s) \to (e_i',s')}{(\tuple{v_1,\ldots,v_{i-1},e_i,\ldots,e_n},s) \to (\tuple{v_1,\ldots,v_{i-1},e_i',\ldots,e_n},s')}$
% %   \end{tabular}}
% % \caption{Small step rules}
% % \label{fig:Small_step_rules}
% % \end{figure}

% % % \begin{figure}[ht]
% % %   \centering
% % %   {\small\begin{tabular}{rl}
% % %       \RN{E-Val} & $(v,s) \Downarrow (v,s)$ \\[1mm]
% % %       \RN{E-App} & $\RULE{(e_1,s) \Downarrow (v_1,s') \quad (e_2,s') \Downarrow (v_2,s'') \quad (\app{v_1}{v_2},s'') \Downarrow (v,s''')}{(\app{e_1}{e_2},s) \Downarrow (v,s''')}$ \\[3mm]
% % %       \RN{E-Op} & $(\app{\app{\op}{z_1}}{z_2},s) \Downarrow (\op^I(z_1,z_2),s)$ \\[1mm]
% % %       \RN{E-BetaV} & $\RULE{(e[v/x],s) \Downarrow (v',s')}{(\app{(\fn{x}{e})}{v},s) \Downarrow (v',s')}$ \\[3mm]
% % %       \RN{E-Proj} & $(\app{\proj{n}{i}}{\tuple{v_1,\ldots,v_n}},s) \Downarrow (v_i,s)$ \\[1mm]
% % %       \RN{E-Deref} & $(\app{!}{\ell},s) \Downarrow (s(\ell),s)$ $\quad$ where $\ell\in\dom{s}$ \\[1mm]
% % %       \RN{E-Assign} & $(\app{\app{\assign}{\ell}}{v},s) \Downarrow (\unit,s[v/\ell])$ $\quad$ where $\ell\in\dom{s}$ \\[1mm]
% % %       \RN{E-Ref} & $(\app{\cref}{v},s) \Downarrow (\ell,s[v/\ell])$ $\quad$ where $\tj{v}{\tau}$ and $\ell\in\Loc^\tau\setminus\dom{s}$ \\[1mm]
% % %       \RN{E-CondTrue} & $\RULE{(e_0,s) \Downarrow (\true,s') \quad (e_1,s') \Downarrow (v',s'')}{(\ifte{e_0}{e_1}{e_2},s) \Downarrow (v',s'')}$ \\[3mm]
% % %       \RN{E-CondFalse} & $\RULE{(e_0,s) \Downarrow (\false,s') \quad (e_2,s') \Downarrow (v',s'')}{(\ifte{e_0}{e_1}{e_2},s) \Downarrow (v',s'')}$ \\[3mm]
% % %       \RN{E-Tuple} & $\RULE{(e_1,s) \Downarrow (v_1,s_1) \quad \ldots \quad (e_n,s_{n-1})\Downarrow (v_n,s_n)}{(\tuple{e_1,\ldots,e_n},s) \Downarrow (\tuple{v_1,\ldots,v_n},s_n)}$
% % %   \end{tabular}}
% % %   \caption{Evaluation rules}
% % %   \label{fig:Evaluation_rules}
% % % \end{figure}

% % % \begin{definition}[Evalutation relation]
% % %   The {\em evalutation relation} $\Downarrow$ is the smallest binary relation between configurations
% % %   satisfying all instances of the rules in figure~\ref{fig:Evaluation_rules}.
% % % \end{definition}

% % % We write $k \not\Downarrow$ to denote that there is no $k'$ such
% % % that $k \Downarrow k'$. Obviously
% % % the evaluation relation is well-defined. Let's say we have $(e,s)
% % % \Downarrow (e',s')$, then
% % % \begin{itemize}
% % % \item $e'\in\Val$, and
% % % \item $\tj{e}{\tau}$ implies $\tj{e'}{\tau}$, and
% % % \item $\locns{e} \subseteq \dom{s}$ implies $\locns{e'} \subseteq
% % %   \dom{s'}$, and
% % % \item $\free{e'} \subseteq \free{e}$.
% % % \end{itemize}

% % \begin{definition}[Small step relation]
% %   The {\em small step relation} $\to$ is the smallest binary
% %   relation between configurations satisfying all instances of the
% %   rules in figure~\ref{fig:Small_step_rules}. We write $\to^*$ for
% %   the reflexive, transitive closure of $\to$.
% % \end{definition}

% % We write $k \not\to$ if there exists no $k'$ such that $k \to k'$.
% % Obviously the small step relation is well-defined. Let's say we have
% % $(e,s)\to(e',s')$. Then
% % \begin{itemize}
% % \item if $\tj{e}{\tau}$, then $\tj{e'}{\tau}$, and
% % \item if $\locns{e} \subseteq \dom{s}$ then $\locns{e'} \subseteq
% %   \dom{s'}$, and
% % \item if $\free{e'} \subseteq \free{e}$.
% % \end{itemize}

% % A {\em finite computation} for $k$ is a finite sequence of
% % configurations $k_1,\ldots,k_n$ such that $k = k_1$, $k_n \not\to$
% % and $k_i \to k_{i+1}$ for every $i=1,\ldots,n-1$. Such a finite
% % computation {\em terminates} if $k_n \in \Val\times\Store$.
% % % Otherwise we say that the computation {\em got stuck}.
% % An {\em infinite computation} for $k$ is an infinite sequence of
% % configurations $k_1,k_2,\ldots$ such that $k=k_1$ and for each
% % $i=1,2,\ldots$ there is some $k_{i+1}$ such that $k_i \to k_{i+1}$.
% % We say that such an infinite computation {\em diverges}.  A
% % configuration $k$ {\em must terminate normally} when all possible
% % computations for $k$ terminate.

% % Similar to O'Hearn ({\em ``A semantic basis for Local Reasoning''})
% % we state:

% % \begin{lemma}[Termination
% %   Monotonicity] \label{lemma:Termination_Monotonicity} If $(e,s)$
% %   must terminate normally and $s' = s \oplus s''$, then $(e,s')$
% %   must also terminate normally.
% % \end{lemma}

% % \begin{proof}
% %   Straightforward induction.
% % \end{proof}

% % \begin{lemma}[Frame Property] \label{lemma:Frame_Property} Suppose
% %   $(e,s_0)$ must terminate normally, and $(e,s_0 \oplus s) \to^*
% %   (v,s')$. Then there exists some $s_0'$ such that $(e,s_0) \to^*
% %   (v,s_0')$ and $s' = s_0' \oplus s$.
% % \end{lemma}

% % \begin{proof}
% %   The proof is pretty easy, we just need to prove the frame property
% %   for a single small step; the frame property for computations is a
% %   trivial consequence. Therefore, given $(e,s_0 \oplus s) \to
% %   (e',s')$, there exists some $s_0'$ such that $(e,s_0) \to
% %   (e',s_0')$ with $s' = s_0' \oplus s$.
% %   \begin{itemize}
% %   \item[\RN{E-Ref}]
% %   \end{itemize}
% % \end{proof}


% % \section{Assertions}

% % Let $\mathcal{F}^\sigma$ be some predefined set of {\em
% %   $\sigma$-function symbols} $f^\sigma$ and $\mathcal{F} =
% % \bigcup_{\sigma\in\TType}\mathcal{F}^\sigma$ be the set of all {\em
% %   function symbols} $f$, such that
% % \begin{itemize}
% % \item $f_\aop \in
% %   \mathcal{F}^{\ttarrow{\tint}{\ttarrow{\tint}{\tint}}}$, and
% % \item $f_\rop \in
% %   \mathcal{F}^{\ttarrow{\tint}{\ttarrow{\tint}{\tbool}}}$.
% % \end{itemize}

% % \begin{definition}[Assertions]
% %   The sets $\Term$ of {\em terms} $t$ and $\Assn$ of {\em
% %     assertions} $p,q,r$ are defined by the following grammar:
% %   \[\GRbeg
% %   t \GRis f \GRmid x \GRmid v \GRmid \app{t_1}{t_2} \GRmid
% %   \ttuple{t_1,\ldots,t_n}
% %   \\
% %   p \GRis t_1 = t_2 \GRmid \app{x}{t} \GRmid \neg p \GRmid p \wedge
% %   q \GRmid \exists x.\,p \GRal \emp \GRmid t_1 \mapsto t_2 \GRmid p
% %   \sepcon q \GRmid p \sepimp q \GRmid \triplex{p}{e}{x}{q} \GRend\]
% % \end{definition}

% % \begin{definition}[Hoare formulae]
% %   The set $\Formula \subseteq \Assn$ of {\em hoare formulae} $h$ is
% %   defined by the following grammar:
% %   \[\GRbeg
% %   h \GRis t_1 = t_2 \GRmid \neg h \GRmid h_1 \wedge h_2 \GRmid
% %   \exists x.\,h \GRal h_1 \sepcon h_2 \GRmid h_1 \sepimp h_2 \GRmid
% %   \triplex{p}{e}{x}{q} \GRend\]
% % \end{definition}

% % \begin{definition}
% %   The {\em typing relation for terms}, written $\tj{t}{\sigma}$, is
% %   the smallest relation between terms and term types satisfying all
% %   instances of the rules in
% %   figure~\ref{fig:Typing_rules_for_constants},
% %   figure~\ref{fig:Typing_rules_for_expressions} and
% %   figure~\ref{fig:Typing_rules_for_terms}. A term $t$ is {\em well
% %     typed} if there is some $\sigma\in\TType$ such that
% %   $\tj{t}{\sigma}$.
% % \end{definition}

% % \begin{figure}[htb]
% %   \centering
% %   \begin{tabular}{rl}
% %     \RN{T-Fun} & $\tj{f^\sigma}{\sigma}$ \\[1mm]
% %     \RN{T-Var} & $\tj{x^\sigma}{\sigma}$ \\[1mm]
% %     \RN{T-App} & $\RULE{\tj{t_1}{\ttarrow{\sigma}{\sigma'}} \quad \tj{t_2}{\sigma}}{\tj{\app{t_1}{t_2}}{\sigma'}}$ \\[3mm]
% %     \RN{T-Tuple} & $\RULE{\tj{t_1}{\sigma_1} \quad \ldots \quad \tj{t_n}{\sigma_n}}{\tj{\ttuple{t_1,\ldots,t_n}}{\ttuple{\sigma_1,\ldots,\sigma_n}}}$
% %   \end{tabular}
% %   \caption{Typing rules for terms}
% %   \label{fig:Typing_rules_for_terms}
% % \end{figure}

% % \begin{definition}
% %   The set of {\em well typed} assertions is the smallest set of
% %   assertions satisfying all instances of the rules in
% %   figure~\ref{fig:Typing_rules_for_assertions}. We write
% %   $\tj{p}{\tassn}$ to indicate that $p$ is well typed.
% % \end{definition}

% % \begin{figure}[htb]
% %   \centering
% %   \begin{tabular}{rl}
% %     \RN{T-Eq} & $\RULE{\tj{t_1}{\sigma} \quad \tj{t_2}{\sigma}}{\tj{t_1 = t_2}{\tassn}}$ \\[3mm]
% %     \RN{T-Var} & $\RULE{\tj{t}{\sigma}}{\tj{\app{x^{\tassn[\sigma]}}{t}}{\tassn}}$ \\[3mm]
% %     \RN{T-Neg} & $\RULE{\tj{p}{\tassn}}{\tj{\neg p}{\tassn}}$ \\[3mm]
% %     \RN{T-Conj} & $\RULE{\tj{p}{\tassn} \quad \tj{q}{\tassn}}{\tj{p \wedge q}{\tassn}}$ \\[3mm]
% %     \RN{T-Exists} & $\RULE{\tj{p}{\tassn}}{\tj{\exists x^\theta.\,p}{\tassn}}$ \\[3mm]
% %     \RN{T-Emp} & $\tj{\emp}{\tassn}$ \\[1mm]
% %     \RN{T-Cont} & $\RULE{\tj{t_1}{\tref{\tau}} \quad \tj{t_2}{\tau}}{\tj{t_1 \mapsto t_2}{\tassn}}$ \\[3mm]
% %     \RN{T-SepConj} & $\RULE{\tj{p}{\tassn} \quad \tj{q}{\tassn}}{\tj{p \sepcon q}{\tassn}}$ \\[3mm]
% %     \RN{T-SepImpl} & $\RULE{\tj{p}{\tassn} \quad \tj{q}{\tassn}}{\tj{p \sepimp q}{\tassn}}$ \\[3mm]
% %     \RN{T-Spec} & $\RULE{\tj{p}{\tassn} \quad \tj{e}{\tau} \quad \tj{q}{\tassn}}{\tj{\triplex{p}{e}{x^\tau}{q}}{\tassn}}$
% %   \end{tabular}
% %   \caption{Typing rules for assertions}
% %   \label{fig:Typing_rules_for_assertions}
% % \end{figure}


% % \subsection{Meaning of assertions}

% % For each logical type $\theta\in\LType$ we define a semantic domain
% % $\semantic{\theta}$ by:
% % \[\begin{array}{rcl}
% %   \semantic{\tau} &=& \{v\in\CVal\,|\,\tj{v}{\tau}\} \\
% %   \semantic{\ttarrow{\sigma_1}{\sigma_2}} &=& (\semantic{\sigma_1} \to \semantic{\sigma_2}) \\
% %   \semantic{\ttuple{\tau_1,\ldots,\tau_n}} &=& \semantic{\tau_1} \times \ldots \times \semantic{\tau_n} \\
% %   \semantic{\tassn[\sigma]} &=& \mathcal{P}(\semantic{\sigma} \times \Store)
% % \end{array}\]

% % For each predefined function symbol $f^\sigma$, let
% % $\semantic{f^\sigma}\in\semantic{\sigma}$ be the meaning of $f$,
% % with
% % \begin{itemize}
% % \item $\semantic{f_\aop} : \semantic{\tint} \to \semantic{\tint} \to
% %   \semantic{\tint}, z_1 z_2 \mapsto \aop^I(z_1,z_2)$, and
% % \item $\semantic{f_\rop} : \semantic{\tint} \to \semantic{\tint} \to
% %   \semantic{\tbool}, z_1 z_2 \mapsto \rop^I(z_1,z_2)$.
% % \end{itemize}

% % An {\em environment} is a partial finite mapping $\eta:\Var \pto
% % \bigcup_{\theta\in\LType}\semantic{\theta}$ such that
% % $\eta(\Var^\theta) \subseteq \semantic{\theta}$ for each
% % $\theta\in\LType$.

% % \begin{definition}[Meaning of terms]
% %   Let $t$ be a term of type $\sigma$ and $\eta$ a suitable
% %   environment with $\free{t} \subseteq \dom{\eta}$.  The {\em
% %     meaning of $t$} wrt. $\eta$, written
% %   $\semantic{\tj{t}{\sigma}}\,\eta$, is defined by:
% %   \[\begin{array}{rcl}
% %     \semantic{\tj{f}{\sigma}}\,\eta
% %     &=& \semantic{f^\sigma} \\
% %     \semantic{\tj{x}{\sigma}}\,\eta
% %     &=& \eta(x) \\
% %     \semantic{\tj{v}{\tau}}\,\eta
% %     &=& v\,\eta \\
% %     \semantic{\tj{\app{t_1}{t_2}}{\sigma}}\,\eta
% %     &=& \app{(\semantic{\tj{t_1}{\ttarrow{\sigma'}{\sigma}}}\,\eta)}{(\semantic{\tj{t_2}{\sigma'}}\,\eta)} \\
% %     \semantic{\tj{\ttuple{t_1,\ldots,t_n}}{\ttuple{\sigma_1,\ldots,\sigma_n}}}\,\eta
% %     &=& (\semantic{\tj{t_1}{\sigma_1}}\,\eta,\ldots,\semantic{\tj{t_n}{\sigma_n}}\,\eta) 
% %   \end{array}\]
% % \end{definition}

% % \begin{lemma}
% %   $\free{t} \subseteq \dom{\eta} \Rightarrow
% %   (\semantic{\tj{t}{\sigma}}\,\eta)\in\semantic{\sigma}$
% % \end{lemma}

% % \begin{proof}
% %   Straightforward induction.
% % \end{proof}

% % We write $\semantic{t}$ instead of $\semantic{\tj{t}{\sigma}}$,
% % since for each well typed term $t$ there is exactly one $\sigma$
% % such that $\tj{t}{\sigma}$.

% % \begin{definition}[Meaning of assertions]
% %   The {\em satisfaction relation}, written $\eta,s \models p$, is
% %   the smallest relation between environments, stores and well typed
% %   assertions, satisfying $\free{p} \subseteq \dom{\eta}$ and all of
% %   the following properties:
% %   \[\begin{array}{lcl}
% %     \eta,s \models t_1 = t_2
% %     &\text{iff}& \semantic{t_1}\,\eta = \semantic{t_2}\,\eta \\
% %     \eta,s \models \app{x^{\tassn[\sigma]}}{t}
% %     &\text{iff}& (\semantic{t}\,\eta,s) \in \eta(x) \\
% %     \eta,s \models \neg p
% %     &\text{iff}& \eta,s \not\models p \\
% %     \eta,s \models p \wedge q
% %     &\text{iff}& \eta,s \models p \text{ and } \eta,s \models q \\
% %     \eta,s \models \exists x^\theta.\,p
% %     &\text{iff}& \exists d \in \semantic{\theta}.\,\eta[d/x],s \models p \\
% %     \eta,s \models \emp
% %     &\text{iff}& \grph{s} = \emptyset \\
% %     \eta,s \models t_1 \mapsto t_2
% %     &\text{iff}& \grph{s} = \{(\semantic{t_1}\,\eta,\semantic{t_2}\,\eta)\} \\
% %     \eta,s \models p \sepcon q
% %     &\text{iff}& \exists s_1,s_2.\,s=s_1 \oplus s_2 \text{ and } \eta,s_1 \models p \text{ and } \eta,s_2 \models q \\
% %     \eta,s \models p \sepimp q
% %     &\text{iff}& \forall s_1,s_2.\,(s_2 = s \oplus s_1 \text{ and } \eta,s_1 \models p) \text{ implies } \eta,s_2 \models q \\
% %     \eta,s \models \triplex{p}{e}{x}{q}
% %     &\text{iff}& \forall s'.\,\eta,s' \models p \text{ implies that all computations for } (e\,\eta,s') \\
% %     && \text{terminate with some $(v,s'')$ such that } \eta[v/x],s'' \models q
% %   \end{array}\]
% % \end{definition}

% % We write $x^{\tassn}$ instead of $\app{x^{\tassn}}{\unit}$.
% % Furtheron we abbreviate:
% % \[\begin{array}{rcl}
% %   \btrue &=_{def}& \true = \true \\
% %   \bfalse &=_{def}& \neg \btrue \\
% %   \forall x.\,p &=_{def}& \neg \exists x.\,\neg p \\
% %   p \vee q &=_{def}& \neg (\neg p \wedge \neg q) \\
% %   p \Rightarrow q &=_{def}& \neg p \vee q \\
% %   p \Leftrightarrow q &=_{def}& (p \Rightarrow q) \wedge (q \Rightarrow p)
% % \end{array}\]
% % It is useful to introduce several more complex forms as abbreviations:
% % \[\begin{array}{rcl}
% %   t \mapsto - &=_{def}& \exists x.\,t \mapsto x \quad \text{where $x\not\in\free{t}$} \\
% %   t_1 \hookrightarrow t_2 &=_{def}& t_1 \mapsto t_2 \sepcon \btrue \\
% %   \{p\} &=_{def}& \triplex{\btrue}{\unit}{x}{p} \quad \text{where $x\not\in\free{p}$}
% % \end{array}\]

% % Meaning of abbreviations:
% % \[\begin{array}{lcl}
% %   \eta,s \models \btrue
% %   && \text{always} \\
% %   \eta,s \models \bfalse
% %   && \text{never} \\
% %   \eta,s \models p \vee q
% %   &\text{iff}& \eta,s \models p \text{ or } \eta,s \models q \\
% %   \eta,s \models p \Rightarrow q
% %   &\text{iff}& \eta,s \models p \text{ implies } \eta,s \models q \\
% %   \eta,s \models p \Leftrightarrow q
% %   &\text{iff}& \eta,s \models p \text{ iff } \eta,s \models q \\
% %   \eta,s \models \forall x^\theta.\,p
% %   &\text{iff}& \forall d\in \semantic{\theta}.\,\eta[d/x],s \models p \\
% %   \eta,s \models t \mapsto -
% %   &\text{iff}& \dom{s} = \{\semantic{t}\,\eta\} \\
% %   \eta,s \models t_1 \hookrightarrow t_2
% %   &\text{iff}& (\semantic{t_1}\,\eta,\semantic{t_2}\,\eta)\in\grph{s} \\
% %   \eta,s \models \{p\}
% %   &\text{iff}& \forall s'.\,\eta,s' \models p
% % \end{array}\]

% % \begin{lemma} \label{lemma:Coincidence} \
% %   \begin{enumerate}
% %   \item Let $t\in\Term$, $\eta_1,\eta_2\in\Env$ with $\eta_1
% %     =_{\free{t}} \eta_2$. Then $\semantic{t}\,\eta_1 =
% %     \semantic{t}\,\eta_2$.
% %   \item Let $p\in\Assn$, $s\in\Store$, $\eta_1,\eta_2\in\Env$ with
% %     $\eta_1 =_{\free{p}} \eta_2$. Then $\eta_1,s \models p$ iff
% %     $\eta_2,s\models p$.
% %   \end{enumerate}
% % \end{lemma}

% % \begin{proof}
% %   Trivial inductions.
% % \end{proof}

% % \subsubsection{Pure assertions}

% % \begin{definition}
% %   An assertion is said to be {\em pure} if, for any given
% %   environment, it is independent of the store.  More precisely, an
% %   assertion $p$ is {\em pure} iff, for all environments $\eta$ and
% %   all stores $s, s'$,
% %   \[\begin{array}{rcl}
% %     \eta,s \models p &\text{iff}& \eta,s' \models p.
% %   \end{array}\]
% % \end{definition}

% % Obviously all hoare formulae $h$ are pure.


% % \subsection{The calculus}

% % \subsubsection{The frame axiom}

% % \begin{center}
% %   \begin{tabular}{rl}
% %   \RN{Frame} & $\triplex{p}{e}{x}{q} \Rightarrow \triplex{p \sepcon r}{e}{x}{q \sepcon r}$ \\
% %   & {\footnotesize where $x \not\in \free{r}$} \\[1mm]
% % \end{tabular}
% % \end{center}

% % To see that the \RN{Frame} axiom is sound, assume that $\eta\in\Env$
% % with $\free{p,e,q,r}\subseteq\dom{\eta}$ and $s\in\Store$ with
% % $\eta,s \models p \sepcon r$. This implies that there are $s_1,s_2$
% % such that $s = s_1 \oplus s_2$, $\eta,s_1 \models p$ and $\eta,s_2
% % \models r$. Now by lemma~\ref{lemma:Termination_Monotonicity} we
% % know that each computation for $(e\,\eta,s)$ terminates with some
% % $(v,s')$, since $\eta\models\triplex{p}{e}{x}{q}$.  Now
% % lemma~\ref{lemma:Frame_Property} states that there must be a
% % computation $(e\,\eta,s_1) \to^* (v,s_1')$ with $s' = s_1' \oplus
% % s_2$. By lemma~\ref{lemma:Coincidence} we have $\eta[v/x],s_2
% % \models r$ since $x\not\in\free{r}$ and by assumption we already
% % know that $\eta[v/x],s_1' \models q$.

% % \subsubsection{Rules for total correctness}

% % {\small
% %   \begin{tabular}{rl}
% %   \RN{Conseq} & $(\{p \Rightarrow p'\} \wedge \triplex{p'}{e}{x}{q'} \wedge \forall x.\,\{q' \Rightarrow q\}) \Rightarrow \triplex{p}{e}{x}{q}$ \\[1mm]
% % \end{tabular}}

% % \subsubsection{Rules for the programming language}

% % {\small
% %   \begin{tabular}{rl}
% %   \RN{Val} & $\triple{\emp}{x_{:y}}{y = x \wedge \emp}$ \\[1mm]
% %   \RN{App} & $\triplex{p}{e_1}{x}{p'} \wedge (\forall x.\,\triplex{p'}{e_2}{y}{q'}) \wedge (\forall x,y.\,\triplex{q'}{\app{x}{y}}{z}{q})$ \\
% %   & $\Rightarrow \triplex{p}{\app{e_1}{e_2}}{z}{q}$ \\
% %   & {\footnotesize where $x \not\in \free{e_2}$, $x,y \not\in\free{q}$} \\[1mm]
% %   \RN{AppOp} & $\triplex{\emp}{\app{\app{\op}{x}}{y}}{z}{z = \app{f_{\op}}{\ttuple{x,y}} \wedge \emp}$ \\[1mm]
% %   \RN{AppAbs} & $\forall x.\,\triplex{p}{e}{y}{q} \Rightarrow \triplex{p}{\app{(\fn{x}{e})}{x}}{y}{q}$ \\[1mm]
% % %   \RN{Unfold} &
% % %   $\triplex{p}{e[\app{\fix}{(\fn{x}{e})}/x]}{y}{q} \Rightarrow
% % %   \triplex{p}{\app{\fix}{(\fn{x}{e})}}{y}{q}$ \\[1mm]
% % %   \RN{Fst} & $\forall
% % %   x,y.\,\triplex{\emp}{\app{\fst}{\pair{x}{y}}}{z}{z = x \wedge
% % %     \emp}$ \\[1mm]
% % %   \RN{Snd} & $\forall
% % %   x,y.\,\triplex{\emp}{\app{\snd}{\pair{x}{y}}}{z}{z = y \wedge
% % %     \emp}$ \\[1mm]
% %   \RN{AppProj} & $\forall x_1,\ldots,x_n.\,\triplex{\emp}{\app{\proj{n}{i}}{\tuple{x_1,\ldots,x_n}}}{y}{y = x_i \wedge \emp}$ \\[1mm]
% %   \RN{AppDeref} & $\forall x,y.\,\triplex{x \mapsto y}{!x}{z}{z = y \wedge x \mapsto y}$ \\[1mm]
% %   \RN{AppAssign} & $\forall x,y.\,\triplex{x \mapsto -}{\app{\app{\assign}{x}}{y}}{u}{u = \unit \wedge x \mapsto y}$ \\[1mm]
% %   \RN{AppRef} & $\forall x.\,\triplex{\emp}{\cref\,x}{y}{y \mapsto x}$ \\[1mm]
% %   \RN{CondTrue} & $\triplex{p}{e_0}{x}{x = \true \wedge r} \wedge \triplex{r}{e_1}{y}{q}$ \\
% %   & $\Rightarrow \triplex{p}{\ifte{e_0}{e_1}{e_2}}{y}{q}$ \\
% %   & {\footnotesize where $x \not\in \free{r}$} \\[1mm]
% %   \RN{CondFalse} & $\triplex{p}{e_0}{x}{x = \false \wedge r} \wedge \triplex{r}{e_2}{y}{q}$ \\
% %   & $\Rightarrow \triplex{p}{\ifte{e_0}{e_1}{e_2}}{y}{q}$ \\
% %   & {\footnotesize where $x \not\in \free{r}$} \\[1mm]
% % %   \RN{Tuple} & $\triplex{p}{e_1}{x_1}{p_1} \wedge \ldots \wedge
% % %   \triplex{p_n}{e_n}{x_n}{p_n} \wedge (\forall
% % %   x_1,\ldots,x_n.\,\triplex{
% % %     \RN{Pair} & $\triplex{p}{e_1}{x}{p'} \wedge (\forall
% % %     x.\,\triplex{p'}{e_2}{y}{q'}) \wedge (\forall
% % %     x,y.\,\triplex{q'}{\pair{x}{y}}{z}{q})$ \\
% % %     & $\Rightarrow \triplex{p}{\pair{e_1}{e_2}}{z}{q}$ \\
% % %     & \footnotesize{where $x \not\in \free{e_2}$, $x,y \not\in
% % %       \free{q}$}
% % \end{tabular}}

% % \subsubsection{Rules for separation}

% % {\small
% %   \begin{tabular}{rl}
% %   \RN{Sep-1} & $p_1 \sepcon p_2 \Leftrightarrow p_2 \sepcon p_1$ \\[1mm]
% %   \RN{Sep-2} & $(p_1 \sepcon p_2) \sepcon p_3 \Leftrightarrow p_1 \sepcon (p_2 \sepcon p_3)$ \\[1mm]
% %   \RN{Sep-3} & $p \sepcon \emp \Leftrightarrow p$ \\[1mm]
% %   \RN{Sep-4} & $(p_1 \vee p_2) \sepcon q \Leftrightarrow (p_1 \vee q) \sepcon (p_2 \vee q)$ \\[1mm]
% %   \RN{Sep-5} & $(p_1 \wedge p_2) \sepcon q \Rightarrow (p_1 \wedge q) \sepcon (p_2 \wedge q)$ \\[1mm]
% %   \RN{Sep-6} & $(\exists x.\,p) \sepcon q \Leftrightarrow \exists x.\,p \sepcon q$ $\quad$ where $x\not\in\free{q}$ \\[1mm]
% %   \RN{Sep-7} & $(\forall x.\,p) \sepcon q \Rightarrow \forall x.\,p \sepcon q$ $\quad$ where $x\not\in\free{q}$ \\[1mm]
% %   \RN{Sep-8} & $\{p_1 \Rightarrow p_2\} \wedge \{q_1 \Rightarrow q_2\} \Rightarrow \{p_1 \sepcon q_1 \Rightarrow p_2 \sepcon q_2\}$ \\[1mm]
% %   \RN{Sep-9} & $\{p_1 \sepcon p_2 \Rightarrow p_3\} \Leftrightarrow \{p_1 \Rightarrow (p_2 \sepimp p_3)\}$ 
% % \end{tabular}}


% % \subsubsection{Structural rules}

% % {\small
% %   \begin{tabular}{rl}
% %   \RN{Refl-Term} & $\forall x^\sigma.\,x = x$ \\[1mm]
% %   \RN{Subst-Term} & $t_1 = t_2 \Rightarrow (p[t_1/x] \Leftrightarrow p[t_2/x])$ \\
% %   & {\footnotesize where $(p[t_1/x]), (p[t_2/x]) \in \Assn$} \\[1mm]
% %   \RN{Spec-Term} & $(\forall x.\,p) \Rightarrow p[t/x]$ \\
% %   & {\footnotesize where $(p[t/x])\in\Assn$} \\[1mm]
% % \end{tabular}}


\end{document}
