\documentclass[12pt,a4paper]{report}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{array}
\usepackage[american]{babel}
\usepackage{color}
\usepackage{enumerate}
%\usepackage[T1]{fontenc}
%\usepackage{german}
\usepackage[a4paper,%
            colorlinks=false,%
            final,%
            pdfkeywords={},%
            pdftitle={},%
            pdfauthor={Benedikt Meurer},%
            pdfsubject={},%
            pdfdisplaydoctitle=true]{hyperref}
\usepackage[latin1]{inputenc}
\usepackage{latexsym}
\usepackage[final]{listings}
\usepackage{makeidx}
%\usepackage{ngerman}
\usepackage[standard,thmmarks]{ntheorem}
%\usepackage{scrpage2}
\usepackage{stmaryrd}
\usepackage{url}

%% LaTeX macros
\include{macros}


\begin{document}


%%
%% The programming language
%%

\chapter{The programming language}

As target language, we use call-by-value PCF with unit, records and imperative concepts.


%%
%% Abstract syntax
%%

\section{Abstract syntax}

We assume that an infinite set of variables $x \in \Var$ and an infinite
set of names $m\in \Member$ is given, not necessarily disjoint.
Variables are used to abstract expressions; programs are considered equal modulo
renaming of bound variables. Names $m$ are used to name fields in records. These
names are always free and not subject to $\alpha$-conversion.
$\Bool = \{\true,\false\}$ is the set of boolean constants $b$,
$\Int$ is a set of integer constants $z$; we do not distinguish
between integer values and their program representation.

\begin{definition}[Types]
  The set $\Type$ of all {\em types} $\tau$ is defined by the context-free grammar
  \[\GRbeg
  \tau \GRis \tbool \GRmid \tint \GRmid \tunit
          \GRal \tref{\tau}
          \GRal \tarrow{\tau_1}{\tau_2}
          \GRal \trecord{m_1:\tau_1,\ldots,m_n:\tau_n},
  \GRend\]
  with distinct member names $m_1,\ldots,m_n$ for record types.
\end{definition}

We assume an infinite set $\Loc^\tau$ of {\em $\tau$-locations} for each type $\tau \in \Type$,
where the sets $\Loc^\tau$ are required to be disjoint. Given those sets,
$\Loc = \bigcup_{\tau\in\Type} \Loc^\tau$ is the set of all {\em locations} $l$.

\begin{definition}[Expressions]
  The set $\Op$ of {\em operators} $\op$ and the set $\Const$ of {\em constants} $c$
  are defined by the grammars
  \[\GRbeg
    \op \GRis + \GRmid - \GRmid * \GRmid = \GRmid < \GRmid > \GRmid \le \GRmid \ge \\
    c \GRis z \GRmid b \GRmid \unit \GRmid l \GRmid \cref \GRmid !
             \GRmid \assign \GRmid \fix,
  \GRend\]
  the set $\Exp$ of {\em expressions} $e$ is defined by
  \[\GRbeg
    e \GRis c \GRmid x \GRmid \abstr{x}{e} \GRmid \app{e_1}{e_2}
           \GRmid \ifte{e_0}{e_1}{e_2}
           \GRal \proj{e}{l} \GRmid \record{m_1=e_1,\ldots,m_n=e_n}
  \GRend\]
  and the set $\Val \subseteq \Exp$ of {\em values} $v$ is defined by
  \[\GRbeg
    v \GRis c \GRmid \abstr{x}{e} \GRmid \app{\op}{v} \GRmid \record{m_1=v_1,\ldots,m_n=v_n}
  \GRend\]
  with distinct member names $m_1,\ldots,m_n$ for records.
\end{definition}

$\free{e}$ denotes the set of free variables and $\locns{e}$ denotes the set of locations in the
expression $e$. We say that an expression $e$ is a {\em program} if both $\free{e}=\emptyset$
and $\locns{e}=\emptyset$ holds, that is if $e$ contains neither unbound variables nor
locations (i.e. memory addresses in terms of the underlying machine). We demand that all expressions
considered for the logic later are valid programs (i.e. programmers aren't permitted to access
abritrary memory locations).


%%
%% Static semantics
%%

\section{Static semantics}

The static semantics of the programming language are defined by the typing relation
$\Tj{\Gamma}{e}{\tau}$.

\begin{definition}[Typing relation]
  A {\em typing judgement} is a formula $\Tj{\Gamma}{e}{\tau}$ where
  \begin{itemize}
    \item $\Gamma:\Var \pto \Type$, $\dom{\Gamma}$ is finite
    \item $e\in\Exp$ and
    \item $\tau\in\Type$.
  \end{itemize}
\end{definition}

We write $\tj{e}{\tau}$ for $\Tj{[\,]}{e}{\tau}$. The set $\Exp^\tau = \{e\in\Exp\,|\,\tj{e}{\tau}\}$
includes the closed expressions of type $\tau$. Likewise $\Val^\tau = \Exp^\tau \cap \Val$ includes
the closed values of type $\tau$.


%%
%% Operational semantics
%%

\section{Operational semantics}

\begin{definition}[Store] \label{definition:Store} \
  \begin{enumerate}
    \item A {\em store} is a partial function $\sigma:\Loc \pto \bigcup_{\tau\in\Type} \Val^\tau$ with
          \begin{itemize}
            \item $\sigma(\Loc^\tau) \subseteq \Val^\tau$ for all $\tau \in \Type$, and
            \item $\locns{\sigma(\Loc)} \subseteq \dom{\sigma}$.
          \end{itemize}

    \item For each finite $L \subseteq \Loc$ the set of {\em $L$-stores} is defined as
          \[\begin{array}{l}
            \Store_L = \{\sigma\,|\,\text{$\sigma$ is a store with $L\subseteq\dom{\sigma}$}\}.
          \end{array}\]

    \item $\Store = \bigcup_{L\subseteq\Loc,L\text{ finite}} \Store_L$ denotes the set of all {\em stores}.
  \end{enumerate}
\end{definition}

We thereby require stores to be well-typed and closed by definition, i.e. we don't permit {\em dangling
references} within stores.

\begin{definition}[Configuration]
  Let $e\in\Exp$ and $\sigma\in\Store$. The pair $(e,\sigma)$ is a {\em configuration}
  if $\locns{e} \subseteq \dom{\sigma}$.
\end{definition}

The stores $\sigma$ are already guarantied to be closed due to definition~\ref{definition:Store} and
now expressions that appear as part of an evaluation are also required to be closed, i.e. do not
include {\em dangling references} to unallocated store cells.

\begin{definition}[Big step semantics]
  Let $e\in\Exp$, $v\in\Val$ and $\sigma,\sigma'\in\Store$. A {\em big step} is a formula
  $(e,\sigma) \Downarrow (v,\sigma')$. A big step is said to be valid if it was derived with the
  big step rules given {\bf somewhere else}.
\end{definition}

\begin{corollary}
  Let $e\in\Exp$, $v\in\Val$ and $\sigma,\sigma'\in\Store$. If $(e,\sigma)$ is a configuration
  and $(e,\sigma) \Downarrow (v,\sigma')$, then
  \begin{enumerate}
    \item $(v,\sigma')$ is also a configuration, and
    \item $\dom{\sigma} \subseteq \dom{\sigma'}$.
  \end{enumerate}
\end{corollary}

\begin{proof}
  Straight forward induction.
\end{proof}

The big step semantic is thereby well-defined with regard to configurations, i.e. it preserves
the configuration property. In the remainder
we thereby consider only pairs $(e,\sigma)$ that are valid configurations. In addition we
assume that type safety holds for the semantics (see Pierce, {\bf TODO}).

\begin{lemma}
  Let $e\in\Exp$, $v\in\Val$ and $\sigma_1,\sigma_2\in\Store$ with $\grph{\sigma_1} \subseteq \grph{\sigma_2}$.
  \begin{enumerate}
    \item For every $\sigma_1'\in\Store$ with $(e,\sigma_1) \Downarrow (v,\sigma_1')$ there exists a
          $\sigma_2'\in\Store$ so that $(e,\sigma_2) \Downarrow (v,\sigma_2')$ and
          $\grph{\sigma_1'} \subseteq \grph{\sigma_2'}$.

    \item For every $\sigma_2'\in\Store$ with $(e,\sigma_2) \Downarrow (v,\sigma_2')$ there exists a
          $\sigma_1'\in\Store$ so that $(e,\sigma_1) \Downarrow (v,\sigma_1')$ and
          $\grph{\sigma_1'} \subseteq \grph{\sigma_2'}$.
  \end{enumerate}
\end{lemma}

\begin{proof}
  {\bf TODO}: The first case won't work for the (REF) rule, because $\sigma_2$ may already include
  the allocated location.
\end{proof}



%%
%% The assertion language
%%

\chapter{The assertion language}


%%
%% Syntax of the assertion language
%%

\section{Syntax of the assertion language}

Based on the types $\tau$ of the programming language, we define
\begin{itemize}
  \item the set $\DType$ of {\em data types} $\delta$ and
  \item the set $\LType$ of {\em logic types} $\pi$
\end{itemize}
using the context-free grammar given below:
\[\GRbeg
  \delta \GRis \tau \GRmid \ttarrow{\delta_1}{\delta_2} \\
  \pi \GRis \tassn \GRmid \delta \GRmid \ttarrow{\delta}{\pi}
\GRend\]
Given an appropriate set $F$ of predefined {\em function symbols} $f$, we
define
\begin{itemize}
  \item the set $\Term$ of {\em terms} $t$ and
  \item the set $\Assn$ of {\em assertions} $p,q$
\end{itemize}
using the following grammar:
\[\GRbeg
  p,q \GRis x
      \GRal v
      \GRal f
      \GRal p \mapsto q
      \GRal p \leadsto q
      \GRal \app{p}{q}
      \GRal \abstr{x:\delta}{p}
      \GRal \neg p
      \GRal p \wedge q
      \GRal \exists x:\pi \in [p]. q
      \GRal p = q
      \GRal \triple{p}{e}{q}
\GRend\]


%%
%% Axiomatic semantics
%%

\section{Semantics of the logic}


%%
%% Reachability
%%

\subsection{Reachability}


\begin{definition}[Reachability]
  Let $L\subseteq\Loc$ finite and $\sigma\in\Store_L$. By induction we define sets $\reachn{i}{L}{\sigma} \in \Loc$
  \begin{itemize}
    \item $\reachn{0}{L}{\sigma} = L$
    \item $\reachn{i+1}{L}{\sigma} = \reachn{i}{L}{\sigma} \cup \bigcup_{l\in\reachn{i}{L}{\sigma}} \locns{\sigma(l)}$.
  \end{itemize}
  The set $\reach{L}{\sigma} = \bigcup_{i\in\N} \reachn{i}{L}{\sigma}$ includes all locations in $\sigma$ reachable
  by $L$.
\end{definition}

Since a store $\sigma\in\Store_L$ is always closed by definition, it is trivial that
$\reach{L}{\sigma} \subseteq \dom{\sigma}$ holds.

\begin{lemma}
  For all finite $L,L'\subseteq\Loc$ with $L \subseteq L'$ and $\sigma,\sigma'\in\Store_{L'}$ we have:
  \begin{enumerate}
    \item $\Store_{L'} \subseteq \Store_L$
    \item $\reach{L}{\sigma} \subseteq \reach{L'}{\sigma}$
    \item If $\reach{L'}{\sigma} = \reach{L'}{\sigma'}$ and $\sigma(l) = \sigma'(l)$ for every $l\in\reach{L'}{\sigma}$,
          then $\reach{L}{\sigma} = \reach{L}{\sigma'}$.
  \end{enumerate}
\end{lemma}

\begin{proof}
  Trivial.
\end{proof}

\begin{definition}[$L$-similarity, $L$-equivalence, $L$-definability]
  Given a finite set $L \subseteq \Loc$ we define:
  \begin{enumerate}
    \item Two stores $\sigma,\sigma'\in\Store$ with $L \subseteq \dom{\sigma} \cup \dom{\sigma'}$ are
          {\em $L$-similar}, denoted $\sigma \simeq_L \sigma'$, if $\sigma(l)=\sigma'(l)$ for every
          $l \in L$.

    \item Two stores $\sigma,\sigma'\in\Store_L$ are {\em $L$-equivalent}, denoted $\sigma \equiv_L \sigma'$,
          if
          \begin{itemize}
            \item $\reach{L}{\sigma} = \reach{L}{\sigma'}$ and
            \item $\sigma \simeq_{\reach{L}{\sigma}} \sigma'$.
          \end{itemize}

    \item A predicate $\phi:\Store_{L'} \to \Bool$ with $L' \subseteq L$ is said to be {\em $L$-definable} if
          $\app{\phi}{\sigma} = \app{\phi}{\sigma'}$ holds for all
          stores $\sigma,\sigma'\in\Store_L$ with $\sigma \equiv_L \sigma'$.
  \end{enumerate}
\end{definition}

\begin{lemma}
  Assume finite sets $L,L'\subseteq\Loc$ with $L \subseteq L'$.
  \begin{enumerate}
    \item $\sigma \simeq_{L'} \sigma'$ implies $\sigma \simeq_L \sigma'$ for all $\sigma,\sigma'\in\Store$.
    \item $\sigma \equiv_{L'} \sigma'$ implies $\sigma \equiv_L \sigma'$ for all $\sigma,\sigma'\in\Store_{L'}$.
  \end{enumerate}
\end{lemma}

\begin{proof}
  Trivial.
\end{proof}


%%
%% Semantic domains
%%

\subsection{Semantic domains}

\begin{definition}[Semantic domains]
  For all types $\pi \in \LType$ we define {\em semantic domains}
  $\semantic{\pi} = \bigcup_{L\subseteq\Loc,L\text{ finite}} \semantic{\pi}_L$, where
  the {\em $L$-definable semantic domains} $\semantic{\pi}_L$ are defined inductively as follows:
  \[\begin{array}{rcl}
    \semantic{\tau}_L &:=& \{v\in\Val^\tau\,|\,\locns{v}=L\} \\
    \semantic{\tassn}_L &:=& \{\phi:\Store_L \to \Bool\,|\,\text{$\phi$ $L$-definable}\} \\
    \semantic{\ttarrow{\delta}{\pi}}_L &:=& \{\eta:\semantic{\delta}\to\semantic{\pi}\,|\,
             \eta(\semantic{\delta}_{L'}) \subseteq \semantic{\pi}_{L \cup L'} \text{ f.a. finite } L' \subseteq \Loc\}
  \end{array}\]
\end{definition}

\begin{definition}[Support]
  Let $\pi\in\LType$. For every $d \in \semantic{\pi}$ the set $\supp{d}\subseteq\Loc$,
  called the {\em support} of $d$, is defined by induction on $\pi$:
  \[\begin{array}{rcl}
    \supp{v} &:=& \locns{v} \\
    \supp{\phi} &:=& L, \text{ where } \phi:\Store_L\to\Bool \\
    \supp{\eta} &:=& \bigcap_{d\in\semantic{\delta}} \supp{\app{\eta}{d}}, \text{ where } \eta:\semantic{\delta}\to\semantic{\pi}
  \end{array}\]
\end{definition}

\begin{lemma}
  Let $\pi\in\LType$.
  \begin{enumerate}
    \item For every $d\in\semantic{\pi}$ and $L\subseteq\Loc$ finite,
          $d\in\semantic{\pi}_L$ implies $L = \supp{d}$.
    \item For all $L,L'\subseteq\Loc$ finite, $\semantic{\pi}_L \cap \semantic{\pi}_{L'} \ne \emptyset$
          implies $L = L'$.
  \end{enumerate}
\end{lemma}

\begin{proof} \
  \begin{enumerate}
    \item Straight forward induction.
    \item Trivial conclusion.
  \end{enumerate}
\end{proof}


%%
%% Total correctness
%%

\subsection{Total correctness}

\begin{definition}[Total correctness]
  Let $\tau\in\Type$, $e\in\Exp^\tau$, $\phi\in\semantic{\tassn}$, $\psi\in\semantic{\ttarrow{\tau}{\tassn}}$
  and $L \subseteq \Loc$ finite. $e$ is {\em $L$-correct} with regard to $\phi$ and $\psi$ if for all
  $\sigma\in\Store_L$ with $\app{\phi}{\sigma}=\true$ there exists a $v\in\Val^\tau$ and a $\sigma'\in\Store_L$,
  for which $(e,\sigma) \Downarrow (v,\sigma')$ and $\app{\app{\psi}{v}}{\sigma'} = \true$ holds. We write
  $L \models \triple{\phi}{e}{\psi}$.
\end{definition}

%\begin{proposition}[Total correctness]
%  Let $\tau\in\Type$, $e\in\Exp^\tau$, $\phi\in\semantic{\tassn}$, $\psi\in\semantic{\ttarrow{\tau}{\tassn}}$
%  and $L \subseteq \Loc$ finite with $L \models \triple{\phi}{e}{\psi}$.
%  \begin{enumerate}
%    \item $L' \models \triple{\phi}{e}{\psi}$ for every finite $L'\subseteq\Loc$ with $L \subseteq L'$.
%    \item $L' \models \triple{\phi}{e}{\psi}$ for $L' = \supp{\phi} \cup \locns{e} \cup \supp{\psi}$.
%  \end{enumerate}
%\end{proposition}

\begin{proposition}[Total correctness]
  Let $\tau\in\Type$, $e\in\Exp^\tau$, $\phi\in\semantic{\tassn}$, $\psi\in\semantic{\ttarrow{\tau}{\tassn}}$
  and $L,L' \subseteq \Loc$ finite with $\locns{e} \cup \supp{\phi} \cup \supp{\psi} \subseteq L,L'$. Then
  $L \models \triple{\phi}{e}{\psi}$ iff $L' \models \triple{\phi}{e}{\psi}$.
\end{proposition}


\end{document}
