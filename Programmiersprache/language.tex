\documentclass[12pt,a4paper]{report}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{array}
\usepackage[american]{babel}
\usepackage{color}
\usepackage{enumerate}
%\usepackage[T1]{fontenc}
%\usepackage{german}
\usepackage[a4paper,%
            colorlinks=false,%
            final,%
            pdfkeywords={},%
            pdftitle={},%
            pdfauthor={Benedikt Meurer},%
            pdfsubject={},%
            pdfdisplaydoctitle=true]{hyperref}
\usepackage[latin1]{inputenc}
\usepackage{latexsym}
\usepackage[final]{listings}
\usepackage{makeidx}
%\usepackage{ngerman}
\usepackage[standard,thmmarks]{ntheorem}
%\usepackage{scrpage2}
\usepackage{stmaryrd}
\usepackage{url}

%% LaTeX macros
\include{macros}


\begin{document}


%%
%% The programming language
%%

\chapter{The programming language}

As target language, we use call-by-value PCF with unit, records and imperative concepts.


%%
%% Abstract syntax
%%

\section{Abstract syntax}

We assume that an infinite set of variables $x \in \Var$ and an infinite
set of names $m\in \Member$ is given, not necessarily disjoint.
Variables are used to abstract expressions; programs are considered equal modulo
renaming of bound variables. Names $m$ are used to name fields in records. These
names are always free and not subject to $\alpha$-conversion.
$\Bool = \{\true,\false\}$ is the set of boolean constants $b$,
$\Int$ is a set of integer constants $z$; we do not distinguish
between integer values and their program representation.

\begin{definition}[Types]
  The set $\Type$ of all {\em types} $\tau$ is defined by the context-free grammar
  \[\GRbeg
  \tau \GRis \tbool \GRmid \tint \GRmid \tunit
          \GRal \tref{\tau}
          \GRal \tarrow{\tau_1}{\tau_2}
          \GRal \trecord{m_1:\tau_1,\ldots,m_n:\tau_n},
  \GRend\]
  with distinct member names $m_1,\ldots,m_n$ for record types.
\end{definition}

We assume an infinite set $\Loc^\tau$ of {\em $\tau$-locations} for each type $\tau \in \Type$,
where the sets $\Loc^\tau$ are required to be disjoint. Given those sets,
$\Loc = \bigcup_{\tau\in\Type} \Loc^\tau$ is the set of all {\em locations} $l$. The set
$\Locfin = \powersetfin{\Loc}$ includes all finite subsets of $\Loc$, and likewise $\Locfin^\tau = \powersetfin{\Loc^\tau}$
includes all finite subsets of $\Loc^\tau$.

\begin{definition}[Expressions]
  The set $\Op$ of {\em operators} $\op$ and the set $\Const$ of {\em constants} $c$
  are defined by the grammars
  \[\GRbeg
    \op \GRis + \GRmid - \GRmid * \GRmid = \GRmid < \GRmid > \GRmid \le \GRmid \ge \\
    c \GRis z \GRmid b \GRmid \unit \GRmid \cref \GRmid !
             \GRmid \assign \GRmid \fix,
  \GRend\]
  the set $\Exp$ of {\em expressions} $e$ is defined by
  \[\GRbeg
    e \GRis c \GRmid x \GRmid l \GRmid \abstr{x}{e} \GRmid \app{e_1}{e_2}
           \GRmid \ifte{e_0}{e_1}{e_2}
           \GRal \proj{e}{m} \GRmid \record{m_1=e_1,\ldots,m_n=e_n}
  \GRend\]
  and the set $\Val \subseteq \Exp$ of {\em values} $v$ is defined by
  \[\GRbeg
    v \GRis c \GRmid l \GRmid \abstr{x}{e} \GRmid \app{\op}{v} \GRmid \record{m_1=v_1,\ldots,m_n=v_n}
  \GRend\]
  with distinct member names $m_1,\ldots,m_n$ for records.
\end{definition}

$\free{e}$ denotes the set of free variables and $\locns{e}$ denotes the set of locations in the
expression $e$. We say that an expression $e$ is a {\em program} if both $\free{e}=\emptyset$
and $\locns{e}=\emptyset$ holds, that is if $e$ contains neither unbound variables nor
locations (i.e. memory addresses in terms of the underlying machine). We demand that all expressions
considered for the logic later are valid programs (i.e. programmers aren't permitted to access
abritrary memory locations).


%%
%% Static semantics
%%

\section{Static semantics}

The static semantics of the programming language are defined by the typing relation
$\Tj{\Gamma}{e}{\tau}$.

\begin{definition}[Typing relation]
  A {\em typing judgement} is a formula $\Tj{\Gamma}{e}{\tau}$ where
  \begin{itemize}
    \item $\Gamma:\Var \pto \Type$, $\dom{\Gamma}$ is finite
    \item $e\in\Exp$ and
    \item $\tau\in\Type$.
  \end{itemize}
\end{definition}

We write $\tj{e}{\tau}$ for $\Tj{[\,]}{e}{\tau}$. The set $\Exp^\tau = \{e\in\Exp\,|\,\tj{e}{\tau}\}$
includes the closed expressions of type $\tau$. Likewise $\Val^\tau = \Exp^\tau \cap \Val$ includes
the closed values of type $\tau$.


%%
%% Operational semantics
%%

\section{Operational semantics}

\begin{definition}[Store] \label{definition:Store} \
  \begin{enumerate}
    \item A {\em store} is a partial function $\sigma:\Loc \pto \bigcup_{\tau\in\Type} \Val^\tau$ with
          \begin{itemize}
            \item $\sigma(\Loc^\tau) \subseteq \Val^\tau$ for all $\tau \in \Type$, and
            \item $\locns{\sigma(\Loc)} \subseteq \dom{\sigma}$.
          \end{itemize}

    \item For each $L\in\Locfin$ the set of {\em $L$-stores} is defined as
          \[\begin{array}{l}
            \Store_L = \{\sigma\,|\,\text{$\sigma$ is a store with $L\subseteq\dom{\sigma}$}\}.
          \end{array}\]

    \item $\Store = \bigcup_{L\in\Locfin} \Store_L$ denotes the set of all {\em stores}.
  \end{enumerate}
\end{definition}

We thereby require stores to be well-typed and closed by definition, i.e. we don't permit {\em dangling
references} within stores.

\begin{definition}[Configuration]
  Let $e\in\Exp$ and $\sigma\in\Store$. The pair $(e,\sigma)$ is a {\em configuration}
  if $\locns{e} \subseteq \dom{\sigma}$.
\end{definition}

The stores $\sigma$ are already guarantied to be closed due to definition~\ref{definition:Store} and
now expressions that appear as part of an evaluation are also required to be closed, i.e. do not
include {\em dangling references} to unallocated store cells.

\begin{definition}[Big step semantics]
  Let $e\in\Exp$, $v\in\Val$ and $\sigma,\sigma'\in\Store$. A {\em big step} is a formula
  $(e,\sigma) \Downarrow (v,\sigma')$. A big step is said to be valid if it was derived with the
  big step rules given {\bf somewhere else}.
\end{definition}

\begin{corollary}
  Let $e\in\Exp$, $v\in\Val$ and $\sigma,\sigma'\in\Store$. If $(e,\sigma)$ is a configuration
  and $(e,\sigma) \Downarrow (v,\sigma')$, then
  \begin{enumerate}
    \item $(v,\sigma')$ is also a configuration, and
    \item $\dom{\sigma} \subseteq \dom{\sigma'}$.
  \end{enumerate}
\end{corollary}

\begin{proof}
  Straight forward induction.
\end{proof}

The big step semantic is thereby well-defined with regard to configurations, i.e. it preserves
the configuration property. In the remainder
we thereby consider only pairs $(e,\sigma)$ that are valid configurations. In addition we
assume that type safety holds for the semantics (see Pierce, {\bf TODO}).


%%
%% The assertion language
%%

\chapter{The assertion language}


%%
%% Syntax of the assertion language
%%

\section{Syntax of the assertion language}

Based on the types $\tau$ of the programming language, we define
\begin{itemize}
  \item the set $\DType$ of {\em data types} $\theta$ and
  \item the set $\LType$ of {\em logic types} $\pi$
\end{itemize}
using the context-free grammar given below:
\[\GRbeg
  \theta \GRis \tau \GRmid \ttarrow{\theta_1}{\theta_2} \\
  \pi \GRis \tassn \GRmid \theta \GRmid \ttarrow{\theta}{\pi}
\GRend\]
Given an appropriate set $F$ of predefined {\em function symbols} $f$, we
define the set $\Assn$ of {\em assertions} $p,q$ using the following grammar:
\[\GRbeg
  p,q \GRis x
      \GRal v
      \GRal f
      \GRal p \mapsto q
      \GRal p \leadsto q
      \GRal \app{p}{q}
      \GRal \abstr{x:\theta}{p}
      \GRal \neg p
      \GRal p \wedge q
      \GRal \exists x:\pi \in [p]. q
      \GRal p = q
      \GRal \triple{p}{e}{q}
\GRend\]


%%
%% Axiomatic semantics
%%

\section{Semantics of the logic}


%%
%% Reachability
%%

\subsection{Reachability}


\begin{definition}[Reachability]
  Let $L\in\Locfin$ and $\sigma\in\Store_L$. By induction we define sets $\reachn{i}{L}{\sigma} \in \Loc$
  \begin{itemize}
    \item $\reachn{0}{L}{\sigma} = L$
    \item $\reachn{i+1}{L}{\sigma} = \reachn{i}{L}{\sigma} \cup \bigcup_{l\in\reachn{i}{L}{\sigma}} \locns{\sigma(l)}$.
  \end{itemize}
  The set $\reach{L}{\sigma} = \bigcup_{i\in\N} \reachn{i}{L}{\sigma}$ includes all locations in $\sigma$ reachable
  by $L$.
\end{definition}

Since a store $\sigma\in\Store_L$ is always closed by definition, it is obvious that
$\reach{L}{\sigma} \subseteq \dom{\sigma}$ holds.

\begin{lemma}
  For all $L,L'\in\Locfin$ with $L \subseteq L'$ and $\sigma,\sigma'\in\Store_{L'}$ we have:
  \begin{enumerate}
    \item $\Store_{L'} \subseteq \Store_L$
    \item $\reach{L}{\sigma} \subseteq \reach{L'}{\sigma}$
    \item If $\reach{L'}{\sigma} = \reach{L'}{\sigma'}$ and $\sigma(l) = \sigma'(l)$ for every $l\in\reach{L'}{\sigma}$,
          then $\reach{L}{\sigma} = \reach{L}{\sigma'}$.
  \end{enumerate}
\end{lemma}

\begin{proof}
  Trivial.
\end{proof}

\begin{definition}[$L$-similarity, $L$-equivalence, $L$-definability]
  Given a set $L\in\Locfin$ we define:
  \begin{enumerate}
    \item Two stores $\sigma,\sigma'\in\Store$ with $L \subseteq \dom{\sigma} \cup \dom{\sigma'}$ are
          {\em $L$-similar}, denoted $\sigma \simeq_L \sigma'$, if $\sigma(l)=\sigma'(l)$ for every
          $l \in L$.

    \item Two stores $\sigma,\sigma'\in\Store_L$ are {\em $L$-equivalent}, denoted $\sigma \equiv_L \sigma'$,
          if
          \begin{itemize}
            \item $\reach{L}{\sigma} = \reach{L}{\sigma'}$ and
            \item $\sigma \simeq_{\reach{L}{\sigma}} \sigma'$.
          \end{itemize}

    \item A predicate $\phi:\Store_{L'} \to \Bool$ with $L' \subseteq L$ is said to be {\em $L$-definable} if
          $\app{\phi}{\sigma} = \app{\phi}{\sigma'}$ holds for all
          stores $\sigma,\sigma'\in\Store_L$ with $\sigma \equiv_L \sigma'$.
  \end{enumerate}
\end{definition}

\begin{lemma}
  For all sets $L,L'\in\Locfin$ with $L \subseteq L'$ we have:
  \begin{enumerate}
    \item $\sigma \simeq_{L'} \sigma'$ implies $\sigma \simeq_L \sigma'$ for all $\sigma,\sigma'\in\Store$.
    \item $\sigma \equiv_{L'} \sigma'$ implies $\sigma \equiv_L \sigma'$ for all $\sigma,\sigma'\in\Store_{L'}$.
  \end{enumerate}
\end{lemma}

\begin{proof}
  Trivial.
\end{proof}


%%
%% Semantic domains
%%

\subsection{Semantic domains}

\begin{definition}[Semantic domains]
  For all types $\pi \in \LType$ we define {\em semantic domains}
  $\semantic{\pi} = \bigcup_{L\in\Locfin} \semantic{\pi}_L$, where
  the {\em $L$-definable semantic domains} $\semantic{\pi}_L$ are defined inductively as follows:
  \[\begin{array}{rcl}
    \semantic{\tau}_L &:=& \{v\in\Val^\tau\,|\,\locns{v}=L\} \\
    \semantic{\tassn}_L &:=& \{\phi:\Store_L \to \Bool\,|\,\text{$\phi$ $L$-definable}\} \\
    \semantic{\ttarrow{\theta}{\pi}}_L &:=& \{\psi:\semantic{\theta}\to\semantic{\pi}\,|\,
             \psi\,(\semantic{\theta}_{L'}) \subseteq \semantic{\pi}_{L \cup L'} \text{ f.a. } L'\in\Locfin\}
  \end{array}\]
\end{definition}

\begin{definition}[Support]
  Let $\pi\in\LType$. For every $d \in \semantic{\pi}$ the set $\supp{d}\subseteq\Loc$,
  called the {\em support} of $d$, is defined by induction on $\pi$:
  \[\begin{array}{rcl}
    \supp{v} &:=& \locns{v} \\
    \supp{\phi} &:=& L, \text{ where } \phi:\Store_L\to\Bool \\
    \supp{\eta} &:=& \bigcap_{d\in\semantic{\theta}} \supp{\app{\eta}{d}}, \text{ where } \eta:\semantic{\theta}\to\semantic{\pi}
  \end{array}\]
\end{definition}

\begin{lemma}
  Let $\pi\in\LType$.
  \begin{enumerate}
    \item For every $d\in\semantic{\pi}$ and $L\in\Locfin$,
          $d\in\semantic{\pi}_L$ implies $L = \supp{d}$.
    \item For all $L,L'\in\Locfin$, $\semantic{\pi}_L \cap \semantic{\pi}_{L'} \ne \emptyset$
          implies $L = L'$.
  \end{enumerate}
\end{lemma}

\begin{proof} \
  \begin{enumerate}
    \item Straight forward induction.
    \item Trivial conclusion.
  \end{enumerate}
\end{proof}


%%
%% Total correctness
%%

\subsection{Total correctness}

\begin{definition}[Total correctness]
  Let $\tau\in\Type$, $e\in\Exp^\tau$, $\phi\in\semantic{\tassn}$, $\psi\in\semantic{\ttarrow{\tau}{\tassn}}$
  and $L\in\Loc$. $e$ is {\em $L$-correct} with regard to $\phi$ and $\psi$ if for all
  $\sigma\in\Store_L$ with $\app{\phi}{\sigma}=\true$ there exists a $v\in\Val^\tau$ and a $\sigma'\in\Store_L$,
  for which $(e,\sigma) \Downarrow (v,\sigma')$ and $\app{\app{\psi}{v}}{\sigma'} = \true$ holds. We write
  $L \models \triple{\phi}{e}{\psi}$.
\end{definition}


%% TODO - statt \pi besser \theta fuer die logischen Typen verwenden
%%        und \pi fuer die Permutationen

%%
%% Second attempt
%%

\pagebreak
\subsection{Second attempt}

\begin{definition}
  Let $L\in\Locfin$.
  \begin{itemize}
    \item A {\em $L$-permutation} is a total, bijective function $\eta:\Loc \to \Loc$ with
          \begin{itemize}
            \item $\eta\,(L) = L$ and
            \item $\eta\,(\Loc^\tau) = \Loc^\tau$ for every $\tau\in\Type$.
          \end{itemize}
    \item $\Perm_L = \{\eta:\Loc \to \Loc\,|\,\text{$\eta$ is $L$-permutation}\}$ denotes the
          set of all $L$-permutations.
  \end{itemize}
\end{definition}

For every such $\eta$, a function $\langle\eta\rangle:\Exp\to\Exp,e\mapsto \app{e}{\eta}$ is
defined, where $\app{e}{\eta}$ is the expression $e$ with the locations permuted according to $\eta$.
The set
$R_\eta^\Store = \{(\sigma,\langle\eta^{-1}\rangle \circ \sigma \circ \eta)\,|\,\sigma\in\Store_L\}$
relates stores to their permuted variants, $R_L^\Store = \bigcap_{\eta\in\Perm_L} R_\eta^\Store$.

\begin{lemma}
  Let $L\in\Locfin$ and $\eta\in\Perm_L$. Then
  \begin{enumerate}
    \item $R_\eta^\Store \subseteq \Store_L \times \Store_L$
  \end{enumerate}
\end{lemma}

\begin{definition}[Semantic domains]
  For every type $\pi \in \LType$ we define {\em semantic domains}
  $\semantic{\pi} = \bigcup_{L\in\Locfin} \semantic{\pi}_L$ with
  $\semantic{\pi}_L = \{d\,|\,(d,d)\in R_L^\pi\}$. Here
  $R_L^\pi = \bigcap_{\eta\in\Perm_L} R_\eta^\pi$, where the $R_\eta^\pi$
  are defined by induction on $\pi$:
  \[\begin{array}{rcl}
    R_\eta^\tau &=& \{(v,\app{v}{\eta})\,|\,v \in \Val^\tau\} \\

    R_\eta^\tassn &=& \{\vec{\phi}\in(\Store_L\to\Bool)^2\,|\,\vec{\phi}\,(R_\eta^\Store) \subseteq \delta^2 \Bool\} \\

    R_\eta^{\ttarrow{\theta}{\pi}} &=& \{\vec{\psi}\in(\semantic{\theta}\to\semantic{\pi})^2\,|\,
                                        \vec{\psi}\,(R_\eta^\theta) \subseteq R_\eta^\pi\}
  \end{array}\]
  $d \in \semantic{\pi}$ is called {\em $L$-definable} if $d \in \semantic{\pi}_L$.
\end{definition}

\begin{lemma}[Sanity Lemma]
  Let $L\in\Locfin$. Then
  \begin{enumerate}
    \item $\phi\in\semantic{\tassn}_L \Rightarrow \left[ \forall \sigma,\sigma'\in\Store_L.
              \sigma \equiv_L \sigma' \Rightarrow \phi\,\sigma = \phi\,\sigma'\right]$
    \item $\psi\in\semantic{\ttarrow{\theta}{\pi}}_L \Rightarrow
              \left[\forall L'\in\Locfin. \psi\,(\semantic{\theta}_{L'})\subseteq\semantic{\pi}_{L \cup L'} \right]$
    \item $d \in \semantic{\pi} \Rightarrow d \in \semantic{\pi}_{\supp{d}}$
  \end{enumerate}
\end{lemma}


%%
%% Third attempt
%%

\pagebreak
\subsection{Third attempt}

% TODO
\newcommand{\CExp}{\nstyle{CExp}}
\newcommand{\CVal}{\nstyle{CVal}}
\newcommand{\loc}{\nstyle{loc}}
\newcommand{\sto}{\nstyle{sto}}
\newcommand{\val}{\nstyle{val}}
\newcommand{\DEF}{\nstyle{DEF}}
\newcommand{\OUT}{\nstyle{OUT}}
\newcommand{\I}{\mathcal{I}}

\begin{definition}
  Let $(W,\sqsubseteq)$ be a lattice (of `worlds' $w$).
  A {\em $W$-set} is a set $D$ together with a family of subsets $(D_w)_{w\in W}$ such that
  $D = \bigcup_{w\in W} D_w$ and
  \begin{itemize}
    \item $v \sqsubseteq w \Rightarrow D_v \subseteq D_w$
    \item $D_v \cap D_w \subseteq D_{v \sqcap w}$
  \end{itemize}
  for all $v,w \in W$.
\end{definition}

We define the {\em support} of an element $d\in D$ to be the world
\[\begin{array}{rcl}
  \supp{d} &=& \bigsqcap \{w\in W\,|\,d \in D_w\}.
\end{array}\]
The support is guarantied to exist by definition of the $W$-sets, i.e. we have
$d \in D_{\supp{d}}$ for every $d \in D$. $\supp{d}$ is thereby the least world of the element $d$.

\begin{definition}
  A {\em $W$-sorted (relation) signature} is a family $\Sigma=(\Sigma^w_n)_{w\in W,n\in \N}$
  of sets $\Sigma^w_n$ such that for all $m,n\in \N$ and $v,w\in W$
  \begin{itemize}
    \item $m \ne n \Rightarrow \Sigma^v_m \cap \Sigma^w_n = \emptyset$
    \item $v \sqsubseteq w \Rightarrow \Sigma^v_n \supseteq \Sigma^w_n$
  \end{itemize}
\end{definition}

An element $r \in \Sigma_n$ is called a {\em relation symbol of arity $n$}. We use the abbreviations
\[\begin{array}{rcl}
  \Sigma_n =_{def} \bigcup_{w\in W} \Sigma^w_n, &
  \Sigma^w =_{def} \bigcup_{n\in \N} \Sigma^w_n, &
  \Sigma =_{def} \bigcup_{w\in W} \Sigma^w.
\end{array}\]

\begin{definition}
  Let $\Sigma$ be a $W$-sorted signature. A {\em $W$-$\Sigma$-set} is a pair
  $(D,\I)$, where $D$ is a $W$-set and $\I$ is a function which maps every
  $r \in \Sigma_n$ to a relation $\I(r) \subseteq D^n$ such that
  $r \in \Sigma^w \Rightarrow \delta^n D_w \subseteq \I(r)$ for all $w \in W$.
\end{definition}

We choose $(W,\sqsubseteq) = (\powersetfin{\Loc},\subseteq)$ as the lattice set of `worlds'.

\begin{definition}[Ground relation]
  A {\em ground relation of arity $n$} is simply a triple $R = (R^\gamma)_{\gamma\in\{\loc,\sto,\val\}}$ with
  \begin{itemize}
    \item $R^\loc \subseteq \bigcup_{\tau\in\Type} \left(\Loc^\tau\right)^n$,
    \item $R^\sto \subseteq \Store^n$ and
    \item $R^\val = \bigcup_{\tau\in\Type} \left(\CVal^\tau\right)^n \cap R^\Exp$
  \end{itemize}
  where the relation $R^\Exp \subseteq \Exp^n$ is defined by induction as follows:
  \begin{enumerate}
    \item $\vec{l}\in R^\Exp$ iff $\vec{l}\in R^{\Loc}$.
    \item $(c,\ldots,c)\in R^\Exp$ iff $c\in\Const$.
    \item $(x,\ldots,x)\in R^\Exp$ iff $x\in\Var$.
    \item $(\abstr{x}{e_1},\ldots,\abstr{x}{e_n})\in R^\Exp$ iff $\vec{e}\in R^\Exp$.
    \item $(\app{e_1}{e_1'},\ldots,\app{e_n}{e_n'})\in R^\Exp$ iff $\vec{e},\vec{e'}\in R^\Exp$.
    \item $(\ifte{e_1}{e_1'}{e_1''},\ldots,\ifte{e_n}{e_n'}{e_n''})\in R^\Exp$ iff
          $\vec{e},\vec{e'},\vec{e''}\in R^\Exp$.
    \item $(\proj{e_1}{m_j},\ldots,\proj{e_n}{m_j})\in R^\Exp$ iff $\vec{e}\in R^\Exp$.
    \item $(\record{{m_i=e_{1,i}}^{i=1 \ldots k}},\ldots,\record{{m_i=e_{n,i}}^{i=1 \ldots k}})\in R^\Exp$ iff \\
            $(e_{1,i},\ldots,e_{n,i})\in R^\Exp$ for every $i=1 \ldots k$.
  \end{enumerate}
\end{definition}

\begin{definition}[$L$-definability]
  Let $L \in W$. A ground relation $R$ of arity $n$ is called {\em $L$-definable}, if there
  exists a relation $R_L$ such that
  \begin{enumerate}
    \item $\vec{\sigma}\in R^\sto$ iff $(\vec{\sigma}|L) \in R_L$ and
          $\vec{\sigma}\,(\delta^n\,(\Loc \setminus L)) \subseteq \delta^n \CVal_\bot$
    \item $\vec{l}\in R^\loc$ and $\vec{\sigma}\in R^\sto$ implies $\vec{\sigma}\,(\vec{l})\in R^\val$
    \item $\vec{\sigma}\in R^\sto$, $\vec{l}\in R^\loc$ and $\vec{v}\in R^\val$ implies
          $\vec{\sigma}[\vec{v}/\vec{l}]\in R^\sto$
  \end{enumerate}
\end{definition}

We let $\DEF^L_n$ denote the set of all $L$-definable ground relations
of arity $n$ and $\OUT^L_n = \bigcup_{L'\in W\wedge L \cap L' = \emptyset} \DEF^{L'}_n$ denote
the set of those which are definable outside of $L$.

Let $\Sigma = (\Sigma^L_n)_{L\in W,n\in \N}$ where $\Sigma^L_n = \OUT^L_n$. It is trivial to see
that $\Sigma$ is indeed a $W$-sorted signature.

\begin{definition}[Semantic domains]
  For every type $\pi\in\LType$ we define a $W$-$\Sigma$-set $\semantic{\pi}=(D^\pi,\I^\pi)$ by
  \begin{itemize}
    \item $D^\tau_L = \{v\in\CVal^\tau\,|\,\locns{v}\subseteq L\}$ \\
          $D^\tau = \bigcup_{L\in W} D^\tau_L$ \\
          $\I^\tau(R) = \{\vec{v}\in(D^\tau)^n\,|\,\vec{v}\in R^\val\}$

    \item $D^\tassn_L = \{ \phi:\Store\to\Bool_\bot\,|\,
                              \forall R\in\Sigma^L_n.\phi\,(R^\sto) \subseteq \delta^n\Bool_\bot \\
                              \hspace*{5cm} \wedge \phi\,(\Store_L) \subseteq \Bool \\
                              \hspace*{5cm} \wedge \forall L_1,L_2\in W.
                                \phi\,(\Store_{L_1} \cup \Store_{L_2}) \subseteq \Bool
                                \Rightarrow
                                \phi\,(\Store_{L_1 \cap L_2}) \subseteq \Bool
                         \}$ \\
          $D^\tassn = \bigcup_{L\in W} D^\tassn_L$ \\
          $\I^\tassn(R) = \{ \vec{\phi} \in (D^\tassn)^n\,|\,
                                  \vec{\phi}\,(R^\sto) \subseteq \delta^n \Bool_\bot \}$

    \item $D^{\ttarrow{\theta}{\pi}}_L = \{ \psi:D^\theta \to D^\pi\,|\,
                              \forall L'\in W. \psi\,(D^\theta_{L'}) \subseteq D^\pi_{L \cup L'} \\
                              \hspace*{4.2cm} \wedge \forall R\in\Sigma^L. \psi\,(\I^\theta(R))\subseteq\I^\pi(R)\}$ \\
          $D^{\ttarrow{\theta}{\pi}} = \bigcup_{L\in W} D^{\ttarrow{\theta}{\pi}}_L$ \\
          $\I^{\ttarrow{\theta}{\pi}}(R) = \{ \vec{\psi} \in (D^{\ttarrow{\theta}{\pi}})^n\,|\,
                                          \vec{\psi}\,(\I^\theta(R)) \subseteq \I^\pi(R) \}$
  \end{itemize}
\end{definition}

{\bf TODO:} Prove that $D^\pi$ is a $W$-set and $(D^\pi,\I^\pi)$ is a $W$-$\Sigma$-set
for all $\pi\in\LType$.

We follow the usual mathematical convention and use $\semantic{\pi}$ not only as a notation
for the $W$-$\Sigma$-set $(D^\pi,\I^\pi)$ but also for the underlying $W$-set $D^\pi$,
hence $\semantic{\pi}_L$ denotes the set $D^\pi_L$. Moreover, we use $R^\pi$ as an abbreviation
for $\I^\pi(R)$.

\begin{definition}[Support]
  For every $\pi\in\LType$ we define the {\em support} of an element $d \in \semantic{\pi}$ to be the set
  \[\begin{array}{rcl}
    \supp{d} &=& \bigcap \{L\in W\,|\,\semantic{\pi}_L\}
  \end{array}\]
\end{definition}

The support is guarantied to exists, because $\semantic{\pi}$ is a $W$-set, i.e. we
have $d \in \semantic{\pi}_{\supp{d}}$ for all $d\in\semantic{\pi}$, $\pi\in\LType$.

\begin{lemma}[Sanity Lemma]
  Let $L\in W$. Then
  \begin{enumerate}
    \item $\phi\in\semantic{\tassn}_L \Rightarrow \left[ \forall \sigma,\sigma'\in\Store_L.
              \sigma \equiv_L \sigma' \Rightarrow \phi\,\sigma = \phi\,\sigma'\right]$
    \item $\psi\in\semantic{\ttarrow{\theta}{\pi}}_L \Rightarrow
              \left[\forall L'\in W. \psi\,(\semantic{\theta}_{L'})\subseteq\semantic{\pi}_{L \cup L'} \right]$
    \item $d \in \semantic{\pi} \Rightarrow d \in \semantic{\pi}_{\supp{d}}$
  \end{enumerate}
\end{lemma}


\end{document}
