\documentclass[12pt,a2paper,draft]{article}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[blocks]{authblk}
\usepackage[english]{babel}
\usepackage{color}
\usepackage[colorlinks=false,%
            pdfkeywords={type safety, big-step, operational, semantics},%
            pdftitle={A new approach to prove type safety using big-step operational semantics},%
            pdfauthor={Benedikt Meurer and Kurt Sieber},%
            pdfsubject={},%
            pdfdisplaydoctitle=true]{hyperref}
\usepackage{mathpartir}
\usepackage{varwidth}

\newcommand{\abstr}[2]{\ensuremath{\lambda{#1}.\,{#2}}}
\newcommand{\app}[2]{\ensuremath{{#1}\,{#2}}}
\newcommand{\rec}[2]{\ensuremath{{\normalfont\textsf{rec}}\,{#1}.\,{#2}}}
\newcommand{\unit}{\ensuremath{\normalfont\textsf{unit}}}
\newcommand{\Unit}{\ensuremath{\normalfont\textsf{Unit}}}

\newcommand{\tj}[2]{\mbox{\ensuremath{{#1}:{#2}}}}
\newcommand{\Tj}[3]{\mbox{\ensuremath{{#1}\vdash\tj{#2}{#3}}}}
\newcommand{\Pj}[3]{\mbox{\ensuremath{{#1}\vdash{#2}\rightarrow{#3}}}}
\newcommand{\tree}[1]{\mathcal{D}(#1)}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}

\begin{document}

\title{%
  A new approach to prove type safety\\using big-step operational semantics
}
\author{Benedikt Meurer}
\author{Kurt Sieber}
\affil{%
  Compilerbau und Softwareanalyse\\
  Universit\"at Siegen\\
  D-57072 Siegen, Germany\\
  {\tt \{meurer,sieber\}@informatik.uni-siegen.de}
}
\date{}
\maketitle
\begin{abstract}
  TODO
\end{abstract}


%% Introduction
\section{Introduction}

Two widely-used styles of \emph{operational semantics} are available today: \emph{big step semantics} \cite{Kahn87},
also known as \emph{natural semantics}, relates program expressions to the final results of their
evaluation; \emph{small step semantics} \cite{Plotkin81,Plotkin04}, also known as
\emph{structured operational semantics}, repeatedly applies a one-step transition relation to
form reduction sequences.


%% The language and its big-step semantics
\section{The language and its big-step semantics}

This section describes the programming language considered in this paper,
the simply typed $\lambda$-calculus with $\unit$ and general recursion, which
presents the simplest possible functional language that exhibits run-time
errors (closed expressions that ``go wrong'') and divergence. Figure~\ref{figure:Basic_syntax}
shows the basic syntax of the programming language.

\begin{figure}[htb]
  \centering
  \begin{tabular}{llcl}
    Variables   & \multicolumn{3}{l}{$x,y,z,\ldots$} \\
    Expressions & $e$ & $::=$ & $\unit \mid x \mid \abstr{x}{e} \mid \app{e_1}{e_2} \mid \rec{x}{e}$ \\
    Values      & $v$ & $::=$ & $\unit \mid \abstr{x}{e}$
  \end{tabular}
  \caption{Basic syntax}
  \label{figure:Basic_syntax}
\end{figure}

We write $e'[e/x]$ for the capture-avoiding substitution of $e$ for all free occurrences
of $x$ in $e'$. The standard call-by-value semantics in big-step style for this language is
defined inductively by the inference rules given in figure~\ref{figure:Call_by_value_inference_rules}.
To be exact, the \emph{evaluation relation} $e \Downarrow v$ is the smallest fixpoint of
the given inference rules. That is, $e \Downarrow v$ holds if and only if it is the conclusion
of a finite derivation tree built from the inference rules.

\begin{figure}[htb]
  \centering
  \begin{mathpar}
    \inferrule[(Val)]{}{v \Downarrow v}
    \and
    \inferrule[(App)]{%
      e_1 \Downarrow \abstr{x}{e} \\
      e_2 \Downarrow v_2 \\
      e[v_2/x] \Downarrow v
    }{%
      \app{e_1}{e_2} \Downarrow v
    }
    \and
    \inferrule[(Rec)]{%
      e[\rec{x}{e}/x] \Downarrow v
    }{%
      \rec{x}{e} \Downarrow v
    }
  \end{mathpar}
  \caption{Call-by-value inference rules}
  \label{figure:Call_by_value_inference_rules}
\end{figure}

\begin{definition}[Derivation tree] \label{definition:Derivation_tree}
  The \emph{derivation tree} for $e$ is the smallest set $\tree{e}$ such that:
  \begin{enumerate}
  \item $(\varepsilon, e) \in \tree{e}$
  \item If $(\kappa,e_0) \in \tree{e}$ and there is an inference rule
    \begin{mathpar}
      \inferrule*{%
        e_1 \Downarrow v_1 \\
        \ldots \\
        e_n \Downarrow v_n
      }{%
        e_0 \Downarrow v_n
      }
    \end{mathpar}
    and $e_1 \Downarrow v_1$, $\ldots$, $e_{i-1} \Downarrow v_{i-1}$ for some $i = 1,\ldots,n$, then
    $(\kappa \cdot i,e_i) \in \tree{e}$.
  \end{enumerate}
\end{definition}


%% Type safety
\section{Type safety}

\begin{figure}[htb]
  \centering
  \begin{mathpar}
    \inferrule[(T-Unit)]{}{\Tj{\Gamma}{\unit}{\Unit}}
    \and
    \inferrule[(T-Var)]{%
      \Gamma(x) = \tau
    }{%
      \Tj{\Gamma}{x}{\tau}
    }
    \and
    \inferrule[(T-Abstr)]{%
      \Tj{\Gamma[\tau/x]}{e}{\tau'}
    }{%
      \Tj{\Gamma}{\abstr{x}{e}}{\tau \to \tau'}
    }
    \\
    \inferrule[(T-Rec)]{%
      \Tj{\Gamma[\tau/x]}{e}{\tau}
    }{%
      \Tj{\Gamma}{\rec{x}{e}}{\tau}
    }
    \and
    \inferrule[(T-App)]{%
      \Tj{\Gamma}{e_1}{\tau' \to \tau} \\
      \Tj{\Gamma}{e_2}{\tau'}
    }{%
      \Tj{\Gamma}{\app{e_1}{e_2}}{\tau}
    }
  \end{mathpar}
  \caption{Typing rules}
  \label{figure:Typing_rules}
\end{figure}

\begin{lemma}[Preservation of types under substitution] \label{lemma:Preservation_of_types_under_substitution}
  If $\Tj{\Gamma[\tau/x]}{e'}{\tau'}$ and $\Tj{\Gamma}{e}{\tau}$,
  then $\Tj{\Gamma}{e'[e/x]}{\tau'}$.
\end{lemma}

\begin{lemma}[Canonical Forms] \label{lemma:Canonical_Forms} \
  \begin{enumerate}
  \item If $\tj{v}{\Unit}$, then $v = \unit$.
  \item If $\tj{v}{\tau' \to \tau}$, then $v = \abstr{x}{e}$.
  \end{enumerate}
\end{lemma}

\begin{theorem}[Preservation] \label{theorem:Preservation}
  If $\Tj{\Gamma}{e}{\tau}$ and $e \Downarrow v$, then $\Tj{\Gamma}{v}{\tau}$.
\end{theorem}

\begin{theorem}[Type safety]
  If $\tj{e}{\tau}$ and $\tree{e}$ is finite, then there is some $v$ such that $e \Downarrow v$.
\end{theorem}

\begin{proof}
  By induction on the size of the (finite) derivation tree $\tree{e}$ and case analysis
  over $\tj{e}{\tau}$.
  \begin{description}
  \item \textsc{(T-Unit)}: $\tj{\unit}{\Unit}$

    $\unit \Downarrow \unit$ exists using \textsc{(Val)}.

  \item \textsc{(T-Abstr)}: $\tj{\abstr{x}{e}}{\tau \to \tau'}$ $\quad$ $\Tj{[x:\tau]}{e}{\tau'}$

    $\abstr{x}{e} \Downarrow \abstr{x}{e}$ exists using \textsc{(Val)}.

  \item \textsc{(T-Rec)}: $\tj{\rec{x}{e}}{\tau}$ $\quad$ $\Tj{[x:\tau]}{e}{\tau}$

    By lemma~\ref{lemma:Preservation_of_types_under_substitution}
    we also have $\tj{e[\rec{x}{e}/x]}{\tau}$. Since $\tree{e[\rec{x}{e}/x]} = \tree{\rec{x}{e}}/1$ we
    can use the induction hypothesis, yielding some $v$ such that $e[\rec{x}{e}/x] \Downarrow v$,
    and therefore concluding $\rec{x}{e} \Downarrow v$ using \textsc{(Rec)}.

  \item \textsc{(T-App)}: $\tj{\app{e_1}{e_2}}{\tau}$ $\quad$ $\tj{e_1}{\tau'\to\tau}$ $\quad$ $\tj{e_2}{\tau'}$

    We have $\tree{e_1} = \tree{\app{e_1}{e_2}}/1$ and the induction hypothesis yields
    some $v_1$ such that $e_1 \Downarrow v_1$. By theorem~\ref{theorem:Preservation} we
    have $\tj{v_1}{\tau'\to\tau}$, and as such $v_1 = \abstr{x}{e}$ according to lemma~\ref{lemma:Canonical_Forms}.

    Hence we also have $\tree{e_2} = \tree{\app{e_1}{e_2}}/2$ and using the induction hypothesis
    on $e_2$ yields a $v_2$ such that $e_2 \Downarrow v_2$, plus $\tj{v_2}{\tau'}$ using
    theorem~\ref{theorem:Preservation}.

    $\tj{e[v_2/x]}{\tau}$ holds due to \textsc{(T-Abstr)} and
    lemma~\ref{lemma:Preservation_of_types_under_substitution}. Since
    $\tree{e[v_2/x]} = \tree{\app{e_1}{e_2}}/3$ we can use the induction hypothesis again and
    get a $v$ such that $e[v_2/x] \Downarrow v$.

    Using \textsc{(App)} we conclude $\app{e_1}{e_2} \Downarrow v$.
  \end{description}
\end{proof}


%% Related work
\section{Related work}

So far, three different big-step semantics have been proposed for the $\lambda$-calculus to
proof type-safety of a programming language: the first uses additional inductive rules
$e \Downarrow \textsf{err}$ to model evaluations that ``go wrong'' \cite{Tofte87}, the second uses
additional coinductive rules to formalize diverging compuations (following Cousot et al.
\cite{CousotCousot07,LeroyGrall09}), and the third interprets the usual inference
rules coinductively \cite{LeroyGrall09}. 


%% Conclusion
\section{Conclusions}


%% References
\bibliographystyle{abbrv}
\bibliography{citations}


\end{document}