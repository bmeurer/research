\documentclass[12pt,a4paper]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{array}
\usepackage[american]{babel}
\usepackage{color}
\usepackage{enumerate}
\usepackage[a4paper,%
            colorlinks=false,%
            final,%
            pdfkeywords={},%
            pdftitle={},%
            pdfauthor={Benedikt Meurer},%
            pdfsubject={},%
            pdfdisplaydoctitle=true]{hyperref}
\usepackage{ifthen}
\usepackage[latin1]{inputenc}
\usepackage{latexsym}
\usepackage[final]{listings}
\usepackage{makeidx}
\usepackage{mathpartir}
\usepackage{ngerman}
\usepackage[standard,thmmarks]{ntheorem}
\usepackage{stmaryrd}
\usepackage{varwidth}

%% LaTeX macros
\include{macros}

\begin{document}


\subsection*{Algebraische Grundlagen}

Sei $\Sigma = \langle S, \mathcal{F} \rangle$ mit 
$S = \{\nstyle{exp},\nstyle{label},\nstyle{nat}\}$ und $\mathcal{F}$
\[\begin{array}{rl}
label:& \nstyle{exp} \to \nstyle{label}\\
child:& \nstyle{exp} \times \nstyle{nat} \to \nstyle{exp}\\
compose_n:& \nstyle{label} \times \underbrace{\nstyle{exp} \times \ldots \times \nstyle{exp}}_n \to \nstyle{exp}\\
subst:& \nstyle{exp} \times \nstyle{exp} \to \nstyle{exp}\\
\end{array}\]


\subsection*{Abstrakte Syntax}

Die Menge $\sstyle{BS}$ aller \emph{Bindungsspezifikationen} $bs$ sei definiert durch
\[\begin{grammar}
bs
\is \nstyle{Dynamic}
\al \nstyle{Static}\,i \quad (i \in \N)
\end{grammar}\]
und die Menge $\sstyle{BT}$ aller \emph{Bindungstypen} durch
\[\begin{grammar}
bt \is (bs_1,\ldots,bs_n) \quad (n \in \N)
\end{grammar}\]
Eine \emph{Syntaxsignatur} $\Omega$ besteht aus einer Menge $F$ von \emph{Funktionszeichen} $f$
und einer Funktion
\[
\arity: F \to \bigcup_{n\in\N}\sstyle{BT}^n
\]
wobei f\"ur jedes $f \in F$ gilt: Wenn $\arity(f) = (bt_1,\ldots,bt_n)$ und
$\nstyle{Static}\,i$ in einem der $bt_j$ vorkommt, dann ist $i \in \{1,\ldots,n\}$.

Durch eine Syntaxsignatur $\Omega$ wird die abstrakte Synta einer Programmiersprache
festgelegt: Die Mengen $\Exp^{bt}_\Omega$ aller \emph{Ausdr\"ucke $e$} vom
Typ $bt$ sind induktiv definiert durch:
\begin{enumerate}
\item $\id \in \Exp^{()}_\Omega$ f\"ur alle $\id \in \Id$.
\item Wenn $\arity(f)=(bt_1,\ldots,bt_n)$ und $e_i \in \Exp^{bt_i}_\Omega$ f\"ur $i=1,\ldots,n$,
  dann ist $f(e_1,\ldots,e_n) \in \Exp^{()}_\Omega$.
\item Wenn $e \in \Exp^{()}_\Omega$, dann ist $\Lambda \vec{\id}:\vec{bs}.e \in \Exp^{(\vec{bs})}_\Omega$.
\end{enumerate}
$\free(e)$ ist wie \"ublich definiert; $e$ hei"st \emph{abgeschlossen} wenn $\free(e) = \emptyset$.
Ein \emph{Programm} ist ein abgeschlossener Ausdruck vom Typ $()$.

Jeder Ausdruck $e$ wird als markierter Baum mit Markierungen der Form $\id$, $f$ oder
$\Lambda \id_1:bs_1,\ldots,\id_n:bs_n$ aufgefasst. Durch Bindungsspezifikationen der
Form $\nstyle{Static}\,i$ wird aus diesem Baum ein Graph. $\graph(e)$ entsteht aus
$e$ indem man (induktiv) f\"ur jeden Teilbaum der Form $f(e_1,\ldots,e_n)$ und
f\"ur $i=1,\ldots,n$ Folgendes durchf\"uhrt: Wenn $e_i = \Lambda \vec{\id}:\vec{bs}.e'$
und $bs_j = \nstyle{Static}\,k$, dann wird jedes freie Vorkommen von $\id_j$ in $e'$
durch einen Pointer auf $e_k$ ersetzt.


\subsection*{Substitutionsmodell}

Sei $\Omega=\langle F,\arity \rangle$ eine Syntaxsignatur einer beliebigen Programmiersprache.
\[\begin{grammar}
  e \in \Exp
  \is \id
  \al f(e_1,\ldots,e_n) & n \in \N
  \al \Lambda\id:\tau.e
  \nl
  \tau \in \Type
  \is \Void
  \al \Dynamic
  \al \Static{n} & n \in \N
\end{grammar}\]

\begin{mathpar}
  \inferrule[(Id)]{%
  }{%
    \Omega \vdash \id \div \Void
  }
  \and
  \inferrule[(Bind)]{%
    \Omega \vdash e \div \Void
  }{%
    \Omega \vdash \Lambda\id:\tau.e \div \tau
  }
  \and
  \inferrule[(Cons)]{%
    \Omega \vdash f \div (\tau_1,\ldots,\tau_n)
    \\
    \Omega \vdash e_1 \div \tau_1
    \\
    \ldots
    \\
    \Omega \vdash e_n \div \tau_n
  }{%
    \Omega \vdash f(e_1,\ldots,e_n) \div \Void
  }
\end{mathpar}

\subsubsection*{Algebra}

\begin{itemize}
\item $\sem{\nstyle{exp}}_S = \Exp$
\item $\sem{\nstyle{label}}_S = F$
\item $\sem{\nstyle{nat}}_S = \N$
\end{itemize}

\[\begin{array}{rll}
  \sem{label}_S: & \Exp \pto F, \\
  & f(\vec{e}) \mapsto f \\
%  & \Lambda\id:\tau.e \mapsto f & f = \sem{label}_S(e) \\
  \\\\
  \sem{child}_S: & \Exp \times \N \pto \Exp, \\
  & (f(e_1,\ldots,e_n),i) \mapsto e_i & 1 \le i \le n \\
%  & (\Lambda\id:\tau.e,i) \mapsto e_i & e_i = \sem{child}_S(e,i) \\
  \\\\
  \sem{compose_n}_S: & F \times \underbrace{\Exp \times \ldots \times \Exp}_n \to \Exp, \\
  & (f, e_1,\ldots,e_n) \mapsto f(e_1,\ldots,e_n) \\
  \\\\
  \sem{subst}_S: & \Exp \times \Exp \pto \Exp, \\
  & (\Lambda\id:\tau.e',e) \mapsto e'[e/\id] \\
\end{array}\]


\subsection*{Umgebungsmodell}

Seien $\Cl$ und $\Env$ wie folgt induktiv definiert:
\[\begin{grammar}
  \eta \in \Env
  \is \varepsilon
  \al \id:\cl;\eta
  \nl
  \cl \in \Cl
  \is (e,\eta)
  \al f(\cl_1,\ldots,\cl_n)
\end{grammar}\]
$\dom(\eta)$ und $\eta(\id)$ sind wie folgt induktiv definiert:
\[\begin{array}{rcl}
  \dom(\varepsilon) &=& \emptyset \\
  \dom(\id:\cl;\eta) &=& \{\id\} \cup \dom(\eta) \\
  \\
  (\id:\cl;\eta)(\id) &=& \cl \\
  (\id':\cl';\eta)(\id) &=& \eta(\id) \\
\end{array}\]

\subsubsection*{Algebra}

\begin{itemize}
\item $\sem{\nstyle{exp}}_\Env = \Cl$
\item $\sem{\nstyle{label}}_\Env = F$
\item $\sem{\nstyle{nat}}_\Env = \N$
\end{itemize}

\[\begin{array}{rll}
  \sem{label}_\Env: & \Cl \pto F, \\
  & (\id,\eta) \mapsto f & f = \sem{label}_\Env(\cl) \wedge \cl = \eta(\id) \\
  & (e,\eta) \mapsto f & f = \sem{label}_S(e) \\
  & f(\vec{\cl}) \mapsto f \\
  \\\\
  \sem{child}_\Env: & \Cl \times \N \pto \Cl, \\
  & ((\id,\eta),i) \mapsto \cl_i & \cl_i = \sem{child}_\Env(\cl, i) \wedge \cl = \eta(\id) \\
  & ((e,\eta),i) \mapsto (e_i,\eta) & e_i = \sem{child}_S(e,i) \\
  & f(\vec{\cl}) \mapsto \cl_i & 1 \le i \le n \\
  \\\\
  \sem{compose_n}_\Env: & \multicolumn{2}{l}{F \times \underbrace{\Cl \times \ldots \times \Cl}_n \to \Cl,} \\
  & \multicolumn{2}{l}{(f,\vec{\cl}) \mapsto f(\vec{\cl})} \\
  \\\\
  \sem{subst}_\Env: & \multicolumn{2}{l}{\Cl \times \Cl \pto \Cl,} \\
  & \multicolumn{2}{l}{((\Lambda\id:\tau.e,\eta),\cl) \mapsto (e,\id:\cl;\eta)}
\end{array}\]


\subsection*{Zusammenhang}

Die \"Ubersetzungsfunktion $\tr:\Cl\to\Exp$ ist wie folgt induktiv definiert:
\[\begin{array}{rcll}
  \tr(e,\eta)
  &=& e[\eta(\id_i)/\id_i]^{i=1 \ldots n}
  & \dom(\eta) = \{\id_1,\ldots,\id_n\}
  \\
  \tr(f(\cl_1,\ldots,\cl_n))
  &=& f(\tr(\cl_1),\ldots,\tr(\cl_n))
\end{array}\]

\begin{lemma}
  F\"ur alle $f \in F$ und $\cl \in \Cl$ gilt:
  \begin{quote}
  $f = \sem{label}_\Env(\cl)$ gdw. $f = \sem{label}_S(\tr(\cl))$.
  \end{quote}
\end{lemma}

\begin{proof}
  Via Induktion \"uber $\cl$:
  \begin{itemize}
  \item $\cl = (\id,\eta)$

    Wenn $\id \not\in \dom(\eta)$, dann sind beide undefiniert.

    Wenn $\id \in \dom(\eta)$, dann ex. $\cl' = \eta(\id)$, und nach I.V. gilt
    \begin{quote}
      $f = \sem{label}_\Env(\cl')$ gdw. $f = \sem{label}_S(\tr(\cl'))$.
    \end{quote}
    Es gilt $\sem{label}_\Env(\cl) = \sem{label}_\Env(\cl')$ und
    $\tr(\cl) = \tr(\cl')$, also folgt die Behauptung.

  \item $\cl = (e,\eta)$

    \textbf{TODO}

  \item $\cl = f(\cl_1,\ldots,\cl_n)$

    Trivial.

  \end{itemize}
\end{proof}

\end{document}