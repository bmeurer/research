\documentclass[12pt,a4paper]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{array}
\usepackage[american]{babel}
\usepackage{color}
\usepackage{enumerate}
\usepackage[a4paper,%
            colorlinks=false,%
            final,%
            pdfkeywords={},%
            pdftitle={},%
            pdfauthor={Benedikt Meurer},%
            pdfsubject={},%
            pdfdisplaydoctitle=true]{hyperref}
\usepackage{ifthen}
\usepackage[latin1]{inputenc}
\usepackage{latexsym}
\usepackage[final]{listings}
\usepackage{makeidx}
\usepackage{ngerman}
\usepackage[standard,thmmarks]{ntheorem}
\usepackage{stmaryrd}

%% LaTeX macros
\include{macros}

\begin{document}


\section*{Grundlegende Algebra}

Sei $\Sigma = \langle S, \mathcal{F} \rangle$ mit 
$S = \{\nstyle{exp},\nstyle{label},\nstyle{nat}\}$ und $\mathcal{F}$
\[\begin{array}{rl}
label:& \nstyle{exp} \to \nstyle{label}\\
child:& \nstyle{exp} \times \nstyle{nat} \to \nstyle{exp}\\
compose_n:& \nstyle{label} \times \underbrace{\nstyle{exp} \times \ldots \times \nstyle{exp}}_{n} \to \nstyle{exp}\\
subst_n:& \nstyle{exp} \times \underbrace{\nstyle{exp} \times \ldots \times \nstyle{exp}}_{n} \to \nstyle{exp}\\
\end{array}\]


\section*{Abstrakte Syntax}

Die Menge $\sstyle{BS}$ aller \emph{Bindungsspezifikationen} $bs$ sei definiert durch
\[\begin{grammar}
bs
\is \nstyle{Dynamic}
\al \nstyle{Static}\,i \quad (i \in \N)
\end{grammar}\]
und die Menge $\sstyle{BT}$ aller \emph{Bindungstypen} durch
\[\begin{grammar}
bt \is (bs_1,\ldots,bs_n) \quad (n \in \N)
\end{grammar}\]
Eine \emph{Syntaxsignatur} $\Omega$ besteht aus einer Menge $F$ von \emph{Funktionszeichen} $f$
und einer Funktion
\[
\arity: F \to \bigcup_{n\in\N}\sstyle{BT}^n
\]
wobei f\"ur jedes $f \in F$ gilt: Wenn $\arity(f) = (bt_1,\ldots,bt_n)$ und
$\nstyle{Static}\,i$ in einem der $bt_j$ vorkommt, dann ist $i \in \{1,\ldots,n\}$.

Durch eine Syntaxsignatur $\Omega$ wird die abstrakte Synta einer Programmiersprache
festgelegt: Die Mengen $\Exp^{bt}_\Omega$ aller \emph{Ausdr\"ucke $e$} vom
Typ $bt$ sind induktiv definiert durch:
\begin{enumerate}
\item $\id \in \Exp^{()}_\Omega$ f\"ur alle $\id \in \Id$.
\item Wenn $\arity(f)=(bt_1,\ldots,bt_n)$ und $e_i \in \Exp^{bt_i}_\Omega$ f\"ur $i=1,\ldots,n$,
  dann ist $f(e_1,\ldots,e_n) \in \Exp^{()}_\Omega$.
\item Wenn $e \in \Exp^{()}_\Omega$, dann ist $\Lambda \vec{\id}:\vec{bs}.e \in \Exp^{(\vec{bs})}_\Omega$.
\end{enumerate}
$\free(e)$ ist wie \"ublich definiert; $e$ hei"st \emph{abgeschlossen} wenn $\free(e) = \emptyset$.
Ein \emph{Programm} ist ein abgeschlossener Ausdruck vom Typ $()$.

Jeder Ausdruck $e$ wird als markierter Baum mit Markierungen der Form $\id$, $f$ oder
$\Lambda \id_1:bs_1,\ldots,\id_n:bs_n$ aufgefasst. Durch Bindungsspezifikationen der
Form $\nstyle{Static}\,i$ wird aus diesem Baum ein Graph. $\graph(e)$ entsteht aus
$e$ indem man (induktiv) f\"ur jeden Teilbaum der Form $f(e_1,\ldots,e_n)$ und
f\"ur $i=1,\ldots,n$ Folgendes durchf\"uhrt: Wenn $e_i = \Lambda \vec{\id}:\vec{bs}.e'$
und $bs_j = \nstyle{Static}\,k$, dann wird jedes freie Vorkommen von $\id_j$ in $e'$
durch einen Pointer auf $e_k$ ersetzt.


\section*{Substitutionsmodell}

Sei $\Omega=\langle F,\arity \rangle$ eine Syntaxsignatur einer beliebigen Programmiersprache.
Im Folgenden sei weiterhin $\Exp = \bigcup_{bt\in\sstyle{BT}}\Exp^{bt}_\Omega$.

\noindent\textbf{TODO:} Besser $\Exp$ allgemein definieren und nachtr\"aglich einschr\"anken.
Dann brauch man sich bei den Funktionen der Algebra nicht verbiegen, sondern kann nachtr\"aglich
zeigen, dass sie \emph{wohldefiniert} sind.

\subsubsection*{Algebra}

\begin{itemize}
\item $\sem{\nstyle{exp}}_S = \Exp$
\item $\sem{\nstyle{label}}_S = F$
\item $\sem{\nstyle{nat}}_S = \N$
\end{itemize}

\[\begin{array}{rll}
  \sem{label}_S: & \Exp \pto F, \\
  & f(\vec{e}) \mapsto f \\
  & \Lambda\vec{\id}:\vec{bs}.e' \mapsto \sem{label}_S(e') \\
  \\\\
  \sem{child}_S: & \Exp \times \N \pto \Exp, \\
  & (f(\vec{e}),i) \mapsto e_i & 1 \le i \le n \\
  & (\Lambda\vec{\id}:\vec{bs}.e',i) \mapsto \sem{child}_S(e',i) \\
  \\\\
  \sem{compose_n}_S: & F \times \underbrace{\Exp \times \ldots \times \Exp}_n \pto \Exp, \\
  & (f, \vec{e}) \mapsto f(\vec{e}) \\
  \\\\
  \sem{subst_n}_S: & \Exp \times \underbrace{\Exp \times \ldots \times \Exp}_n \pto \Exp, \\
  & (\Lambda\vec{\id}:\vec{bs}.e',\vec{e}) \mapsto e'[\vec{e}/\vec{\id}]
\end{array}\]


\section*{Umgebungsmodell}

Seien $\Cl$, $\Env$ und $\Frame$ wie folgt induktiv definiert:
\[\begin{grammar}
  \eta \in \Env
  \is [\fr_1;\ldots;\fr_n]
  \nl
  \fr \in \Frame
  \is [\id_1:\cl_1;\ldots;\id_n:\cl_n]
  \nl
  \cl \in \Cl
  \is (e,\eta)
  \al f(\cl_1,\ldots,\cl_n)
\end{grammar}\]

\subsubsection*{Algebra}

\begin{itemize}
\item $\sem{\nstyle{exp}}_\Env = \Cl$
\item $\sem{\nstyle{label}}_\Env = F$
\item $\sem{\nstyle{nat}}_\Env = \N$
\end{itemize}

\[\begin{array}{rll}
  \sem{label}_\Env: & \Cl \pto F, \\
  & (\id,\eta) \mapsto \sem{label}_\Env(\cl) & \cl = \eta(\id) \\
  & (e,\eta) \mapsto \sem{label}_S(e) \\
  & f(\vec{\cl}) \mapsto f \\
  \\\\
  \sem{child}_\Env: & \Cl \times \N \pto \Cl, \\
  & ((\id,\eta),i) \mapsto \cl_i & \cl_i = \sem{child}_\Env(\eta(\id), i) \\
  & ((e,\eta),i) \mapsto (e_i,\eta) & e_i = \sem{child}_S(e,i) \\
  & f(\vec{\cl}) \mapsto \cl_i & 1 \le i \le n \\
  \\\\
  \sem{compose_n}_\Env: & F \times \underbrace{\Cl \times \ldots \times \Cl}_n \to \Cl, \\
  & (f,\vec{\cl}) \mapsto f(\vec{\cl}) \\
  \\\\
  \sem{subst_n}_\Env: & \Cl \times \underbrace{\Cl \times \ldots \times \Cl}_n \pto \Cl, \\
  & ((\Lambda\vec{\id}:\vec{bs}.e,\eta),\vec{\cl}) \mapsto (e,[\vec{\id}:\vec{cl}];\eta)
\end{array}\]


\end{document}