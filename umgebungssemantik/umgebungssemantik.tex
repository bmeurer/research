\documentclass[12pt,fleqn]{article}
\usepackage{ngerman}
\usepackage{hyperref,german,amssymb,amstext,amsmath,amsthm,array,stmaryrd,color,latexsym}

% TP Macros
\input{TP}

\newcommand{\RN}[1]{\mbox{\textsc{(#1)}}}
\newcommand{\Cl}{\name{Cl}}
\newcommand{\cl}{\name{cl}}

\begin{document}

\section{Substitutionssemantik}

Voraussetzungen:
\begin{itemize}
  \item $\Id \cap \Val = \emptyset$

  \item Ausdr"ucke sind gleich modulo Umbenennung gebundener Namen.

        Geht nat"urlich auch ohne diese Konvention, aber macht Definitionen und Beweise h"asslich.
\end{itemize}

\begin{definition}[Big step Regeln]
Ein {\em big step} in der Substitutionssemantik ist eine Formel der Gestalt $e \Downarrow v$ mit $e\in\Exp$
und $v \in \Val$. Ein solcher big step hei"st {\em g"ultig}, wenn er sich mit den folgenden Regeln herleiten
l"asst: \\[5mm]
\begin{tabular}{ll}
  \RN{Val}        & $v \Downarrow v$ \\[3mm]
  \RN{Beta}       & $\regel{e_1 \Downarrow \abstr{\id}{e} \quad e[e_2/\id] \Downarrow v}
                           {\app{e_1}{e_2} \Downarrow v}$ \\[3mm]
  \RN{Op-1}       & $\regel{e_1 \Downarrow \op \quad e_2 \Downarrow z}
                           {\app{e_1}{e_2} \Downarrow \app{\op}{z}}$ \\[3mm]
  \RN{Op-2}       & $\regel{e_1 \Downarrow \app{\op}{z_1} \quad e_2 \Downarrow z_2 \quad \op^I(z_1,z_2) = z}
                           {\app{e_1}{e_2} \Downarrow z}$ \\[3mm]
  \RN{Cond-True}  & $\regel{e_0 \Downarrow \true \quad e_1 \Downarrow v}
                           {\bifte{e_0}{e_1}{e_2} \Downarrow v}$ \\[3mm]
  \RN{Cond-False} & $\regel{e_0 \Downarrow \false \quad e_2 \Downarrow v}
                           {\bifte{e_0}{e_1}{e_2} \Downarrow v}$ \\[3mm]
  \RN{Unfold}     & $\regel{e_1 \Downarrow \bfix \quad \app{e_2}{(\app{\bfix}{e_2})} \Downarrow v}
                           {\app{e_1}{e_2} \Downarrow v}$
\end{tabular}
\end{definition}


\section{Umgebungssemantik}

\begin{definition}[Closures und Umgebungen]
  Die Menge $\Env$ aller {\em (Laufzeit-)Umgebungen} $\eta$ und die Menge $\Cl$ aller {\em Closures} $\cl$ sind
  durch die folgende kontextfreie Grammatik definiert:
  \bgram
  \eta \is [\,] \mid \id:\cl;\eta \n
  \cl \is (e,\eta)
  \egram
  Der {\em Definitionsbereich} $\dom{\eta}$ einer Umgebung $\eta$ ist wie folgt induktiv definiert:
  \[\begin{array}{rcl}
    \dom{[\,]} &=& \emptyset \\
    \dom{\id:\cl;\eta} &=& \{\id\} \cup \dom{\eta}
  \end{array}\]
  Eine Closure $\cl = (e,\eta)$ hei"st {\em wohldefiniert}, wenn $\free{e} \subseteq \dom{\eta}$ und
  $\eta$ wohldefiniert ist. Eine Umgebung $\eta$ hei"st {\em wohldefiniert}, wenn alle eingetragenen
  Closures wohldefiniert sind.
\end{definition}

\noindent Schreibweisen
\begin{enumerate}
\item F\"ur $(\id_1:\cl_1;\ldots;\id_n:\cl_n;[\,])\in\Env$ schreiben wir
  \[
  [\id_1:\cl_1;\ldots;\id_n:\cl_n]
  \]
\item F\"ur $\eta=(\id_1:\cl_1;\ldots;\id_n:\cl_n;[\,])\in\Env$ und $\id\in\dom{\eta}$ sei
  \[
  \eta(\id) = \cl_i, \text{ wobei } i = \min\{j \in \{1,\ldots,n\}\,|\,\id_j=\id\}
  \]
\end{enumerate}

\begin{definition}[Big step Regeln]
Ein {\em big step} in der Umgebungssemantik ist eine Formel der Gestalt $(e,\eta) \Downarrow (e',\eta')$,
wobei $e,e'\in\Exp$ und $\eta,\eta'\in\Env$. Ein derartiger big step hei"st {\em g"ultig}, wenn er sich mit den
folgenden Regeln herleiten l"asst: \\[5mm]
\begin{tabular}{ll}
  \RN{Val}        & $(v,\eta) \Downarrow (v,\eta)$ \\[3mm]
  \RN{Id}         & $\regel{\eta(\id) \Downarrow \cl}
                           {(\id,\eta) \Downarrow \cl}$ \\[3mm]
  \RN{Beta}       & $\regel{(e_1,\eta) \Downarrow (\abstr{\id}{e},\eta_1)
                            \quad (e,\eta_1[(e_2,\eta)/\id]) \Downarrow \cl}
                           {(\app{e_1}{e_2},\eta) \Downarrow \cl}$ \\[3mm]
  \RN{Op-1}       & $\regel{(e_1,\eta) \Downarrow (\op,\eta_1) \quad (e_2,\eta) \Downarrow (z,\eta_2)}
                           {(\app{e_1}{e_2},\eta) \Downarrow (\app{\op}{z},[])}$ \\[3mm]
  \RN{Op-2}       & $\regel{(e_1,\eta) \Downarrow (\app{\op}{z_1},\eta_1)
                            \quad (e_2,\eta) \Downarrow (z_2,\eta_2)
                            \quad \op^I(z_1,z_2) = z}
                           {(\app{e_1}{e_2},\eta) \Downarrow (z,[])}$ \\[3mm]
  \RN{Cond-True}  & $\regel{(e_0,\eta) \Downarrow (\true,\eta_0) \quad (e_1,\eta) \Downarrow \cl}
                           {(\bifte{e_0}{e_1}{e_2},\eta) \Downarrow \cl}$ \\[3mm]
  \RN{Cond-False} & $\regel{(e_0,\eta) \Downarrow (\false,\eta_0) \quad (e_2,\eta) \Downarrow \cl}
                           {(\bifte{e_0}{e_1}{e_2},\eta) \Downarrow \cl}$ \\[3mm]
  \RN{Unfold}     & $\regel{(e_1,\eta) \Downarrow (\bfix,\eta_1)
                            \quad (\app{e_2}{(\app{\bfix}{e_2})},\eta) \Downarrow \cl}
                           {(\app{e_1}{e_2},\eta) \Downarrow \cl}$
\end{tabular}
\end{definition}

\begin{lemma}[Wohldefiniertheit der Umgebungssemantik] \label{lemma:Wohldefiniertheit}
  Seien $(e,\eta),(\hat{e},\hat{\eta})\in\Cl$. Wenn $(e,\eta)$ wohldefiniert und
  $(e,\eta) \Downarrow (\hat{e},\hat{\eta})$, dann ist auch $(\hat{e},\hat{\eta})$
  wohldefiniert und es gilt $\hat{e}\in \Val$.
\end{lemma}

\begin{proof}
  Vermutlich triviale Induktion.
\end{proof}

Im Weiteren betrachten wir nur noch wohldefinierte Closures und Umgebungen, d.h. wir nehmen an,
$\Cl$ und $\Env$ enthalten nur noch wohldefinierte Elemente.

\begin{definition} \label{definition:Substitution}
  Sei $(e,\eta) \in \Cl$. Der Ausdruck $e\,\eta$ ist wie folgt
  induktiv definiert:
  \[\begin{array}{rcl}
    c\,\eta &=& c \\
    \id\,\eta &=& e'\,\eta', \text{ wobei } \eta(\id) = (e',\eta') \\
    (\app{e_1}{e_2})\,\eta &=& \app{(e_1\,\eta)}{(e_2\,\eta)} \\
    (\abstr{\id}{e})\,\eta &=& \abstr{\id'}{(e[\id'/\id]\,\eta)}, \text{ wobei } \id'\not\in\dom{\eta} \\
    (\bifte{e_0}{e_1}{e_2})\,\eta &=& \bifte{(e_0\,\eta)}{(e_1\,\eta)}{(e_2\,\eta)}
  \end{array}\]
\end{definition}

\begin{lemma} \label{lemma:Substitution}
  Seien $(e,\eta), (e',\eta') \in \Cl$. Dann gilt:
  \begin{enumerate}
    \item $e\in\Val$ impliziert $(e\,\eta)\in\Val$.
    \item $(e\,\eta)\in\Val$, dann entweder $e\in\Val$ oder
          $e=\id\in\Id$ und $\eta(\id) = (e',\eta')$ mit $(e'\,\eta')\in\Val$
    %\item $(e\,\eta) = (e\,\eta')$ wenn $\eta' =_{\free{e}} \eta$
    \item $e\,(\eta[(e',\eta')/\id]) = (e[\id'/\id]\,\eta)[(e'\,\eta')/\id']$ wenn $\id' \not\in \dom{\eta}$
  \end{enumerate}
\end{lemma}


\section{"Aquivalenz der Modelle}

\begin{theorem}[Korrektheit der Umgebungssemantik] \label{theorem:Korrektheit}
  Seien $(e,\eta) \in \Cl$, $v'\in\Val$ und $\eta'\in\Env$. Wenn $(e,\eta) \Downarrow (v',\eta')$, dann
  $(e\,\eta) \Downarrow (v'\,\eta')$.
\end{theorem}

\begin{proof}
  Induktion "uber die L"ange der Herleitung des big steps $(e,\eta) \Downarrow (v',\eta')$ mit Fallunterscheidung
  nach der zuletzt angewandten big step Regel:
  \begin{itemize}
    \item $(v,\eta) \Downarrow (v,\eta)$ mit \RN{Val}, dann ist $(v\,\eta) \in \Val$ und somit folgt
          $(v\,\eta) \Downarrow (v\,\eta)$ mit \RN{Val}.

    \item $(\id,\eta) \Downarrow (v',\eta')$ mit \RN{Id} bedingt $\eta(\id) = (\hat{e},\hat{\eta})$ und
          $(\hat{e},\hat{\eta}) \Downarrow (v',\eta')$. Nach IV muss also $(\hat{e}\,\hat{\eta})\Downarrow(v'\,\eta')$
          gelten, und somit folgt wegen $(\id\,\eta) = (\hat{e}\,\hat{\eta})$ die Behauptung.

    \item $(\app{e_1}{e_2},\eta) \Downarrow (v',\eta')$ mit Regel \RN{Beta} kann nur aus Pr"amissen der Form
          $(e_1,\eta) \Downarrow (\abstr{\id}{e},\hat{\eta})$ und $(e,\hat{\eta}[(e_2,\eta)/\id])\Downarrow(v',\eta')$
          folgen. Mit IV folgt daraus $(e_1\,\eta) \Downarrow (\abstr{\id}{e})\,\hat{\eta}$ und
          $e\,(\hat{\eta}[(e_2,\eta)/\id])\Downarrow(v'\,\eta')$. Nach Definition~\ref{definition:Substitution}
          gilt $(\abstr{\id}{e})\,\hat{\eta} = \abstr{\id'}{(e[\id'/\id]\,\hat{\eta})}$ wobei
          $\id'\not\in\dom{\hat{\eta}}$. Nach Lemma~\ref{lemma:Substitution} folgt dar"uberhinaus
          $e\,(\hat{\eta}[(e_2,\eta)/\id]) = (e[\id'/\id]\,\hat{\eta})[e_2\,\eta/\id]$, und somit
          $(\app{e_1}{e_2})\,\eta \Downarrow (v'\,\eta')$ mit Regel \RN{Beta}.

%     \item $(\rec{\id}{e},\eta) \Downarrow (v',\eta')$ kann ausschliesslich mit \RN{Unfold} aus der Pr"amisse
%           $(e,\eta[(\rec{\id}{e},\eta)/\id]) \Downarrow (v',\eta')$ folgen. Nach IV gilt dann ebenfalls
%           $e\,(\eta[(\rec{\id}{e},\eta)/\id]) \Downarrow (v'\,\eta')$ und nach Definition~\ref{definition:Substitution}
%           gilt $(\rec{\id}{e})\,\eta = \rec{\id'}{(e[\id'/\id]\,\eta)}$ mit $\id'\not\in\dom{\eta}$. Wegen
%           Lemma~\ref{lemma:Substitution} folgt dann
%           $e\,(\eta[(\rec{\id}{e},\eta)/\id]) = (e[\id'/\id]\,\eta)[\rec{\id'}{(e[\id'/\id]\,\eta)}/\id]$ und
%           somit $(\rec{\id}{e})\,\eta \Downarrow (v'\,\eta')$ mit Regel \RN{Unfold}.
  \end{itemize}
  Die "ubrigen F"alle folgen analog.
\end{proof}

\begin{lemma}[Koinzidenz] \label{lemma:Koinzidenz}
  F"ur alle $\eta,\hat{\eta},\eta'\in\Env$, ...
  Wenn $(e[(e_2\,\eta)/\id],[\,]) \Downarrow (v',\eta')$, dann ex. $\eta''$, so dass
  $(e,\hat{\eta}[(e_2,\eta)/\id]) \Downarrow (v',\eta'')$.
\end{lemma}

\begin{proof}
  Sollte gelten, m"usste aber allgemeiner formuliert werden, um einfach beweisbar zu sein.
\end{proof}

\begin{theorem}[Vollst"andigkeit der Umgebungssemantik] \label{theorem:Vollstaendigkeit}
  Seien $(e,\eta)\in\Cl$ und $v \in \Val$.
  Wenn $(e\,\eta) \Downarrow v$, dann ex. $(v',\eta')\in\Cl$ mit $(v'\,\eta') = v$, so dass
  $(e,\eta) \Downarrow (v',\eta')$.
\end{theorem}

Man k"onnte hier vermutlich auch noch eine konkretere Aussage "uber $v'$ und $\eta'$ machen, so man das will.

\begin{proof}
  Offensichtlich gilt $\free{v} = \emptyset$. Die Behauptung folgt
  dann per Induktion "uber die L"ange der Herleitung des big steps $(e\,\eta) \Downarrow v$, wobei jeweils nach der
  zuletzt angewandten Regel unterschieden wird. Hierbei ist in jedem der F"alle zu unterscheiden, ob $e$ selbst
  schon von der f"ur die Regel passenden Form ist, oder ob $e$ ein Identifier ist. Ist $e$ ein Identifier, so
  folgt die Behauptung unmittelbar mit IV und big step Regel \RN{Id}; wir betrachten diesen Fall damit als erledigt
  und konzentrieren uns im Folgenden auf die F"alle f"ur $e\not\in\Id$.
  \begin{itemize}
    \item $v \Downarrow v$ mit $\RN{Val}$, d.h. $(e\,\eta) = v$. Sei o.B.d.A. $e \in \Val$, dann existiert ein
          big step $(e,\eta) \Downarrow (e,\eta)$ mit $\RN{Val}$.
          
%     \item $(\rec{\id}{e})\,\eta \Downarrow v$ mit $\RN{Unfold}$ bedingt o.B.d.A.
%           $(e[\id'/\id]\,\eta)[(\rec{\id}{e})\,\eta/\id'] \Downarrow v$, wobei $\id' \not\in \dom{\eta}$.
%           Nach Lemma~\ref{lemma:Substitution} folgt $e\,(\eta[(\rec{\id}{e})\,\eta/\id])\Downarrow v$ und nach IV
%           existiert dann $(v',\eta') \in \Cl$ mit $(v'\,\eta') = v$, so dass
%           $(e,\eta[(\rec{\id}{e},\eta)/\id]) \Downarrow (v',\eta')$. Die Behauptung folgt unmittelbar mit
%           \RN{Unfold}.

    \item $(\app{e_1}{e_2})\,\eta \Downarrow v$ mit \RN{Beta} kann o.B.d.A. nur aus Pr"amissen der Form
          $(e_1\,\eta) \Downarrow \abstr{\id}{e}$ und $e[(e_2\,\eta)/\id]\Downarrow v$ folgen. Nach IV ex.
          $(\hat{v},\hat{\eta}),(v',\eta')\in\Cl$, so dass $(e_1,\eta) \Downarrow (\hat{v},\hat{\eta})$
          und $(e[(e_2\,\eta)/\id],[\,])\Downarrow (v',\eta')$. Nach Lemma~\ref{lemma:Koinzidenz} ex. $\eta''$
          mit $(e,\hat{\eta}[(e_2,\eta)/\id]) \Downarrow (v',\eta'')$. O.B.d.A. ex. $\hat{\id}\not\in\dom{\hat{\eta}}$,
          so dass $(e_1,\eta) \Downarrow (\abstr{\hat{\id}}{e[\hat{\id}/\id]},\hat{\eta})$ und
          $(e[\hat{\id}/\id],\hat{\eta}[(e_2,\eta)/\hat{\id}]) \Downarrow (v',\eta'')$. Die Behauptung folgt
          unmittelbar mit \RN{Beta}.
  \end{itemize}
  Die restlichen F"alle folgen "ahnlich einfach.
\end{proof}

\begin{theorem}["Aquivalenzsatz]
  Sei $e \in \Exp$, $v \in \Val$ mit $\free{e} = \emptyset$. Die folgenden Aussagen sind "aquivalent:
  \begin{enumerate}
    \item $e \Downarrow v$
    \item ex. $(v',\eta')\in\Cl$ mit $v = (v'\,\eta')$, so dass $(e,[\,]) \Downarrow (v',\eta')$
  \end{enumerate}
\end{theorem}

\begin{proof}
  Folgt leicht aus Satz~\ref{theorem:Korrektheit} und Satz~\ref{theorem:Vollstaendigkeit}.
\end{proof}

\begin{corollary}
  Sei $e \in \Exp$, $c \in \Const$ mit $\free{e} = \emptyset$. Die folgenden Aussagen sind "aquivalent:
  \begin{enumerate}
    \item $e \Downarrow c$
    \item ex. $\eta\in\Cl$, so dass $(e,[\,]) \Downarrow (c,\eta)$
  \end{enumerate}
\end{corollary}


\section{De Bruijn Indizes}

\begin{definition}[Expressions]
  Vorgeben sei eine (unendliche) Menge $\{\underline{1},\underline{2},\ldots\}$ von {\em De Bruijn-Indizes}
  $\iota$. Die Menge $\dbExp$ aller {\em De Bruijn-Ausdr\"ucke} $e$ ist durch die kontextfreie Grammatik
  \bgram
  e \is c \mid \iota \mid \abstr{}{e} \mid \app{e_1}{e_2} \mid \bifte{e_0}{e_1}{e_2}
  \egram
  definiert. Der {\em Rang} $\rank{e} \in \setN$ eines De Bruijn-Ausdrucks $e$ ist wie folgt induktiv definiert:
  \[\begin{array}{rcl}
    \rank{c} &=& 0 \\
    \rank{\iota} &=& \iota \\
    \rank{\abstr{}{e}} &=& \max(\rank{e},1) - 1 \\
    \rank{\app{e_1}{e_2}} &=& \max(\rank{e_1},\rank{e_2}) \\
    \rank{\bifte{e_0}{e_1}{e_2}} &=& \max(\rank{e_0},\rank{e_1},\rank{e_2})
  \end{array}\]
\end{definition}

\begin{definition}[Closures und Umgebungen]
  Die Menge $\dbEnv$ aller {\em De Bruijn-(Laufzeit-)Umgebungen} $\eta$ und die Menge $\dbCl$ aller
  {\em De Bruijn-Closures} $\cl$ sind durch die folgende kontextfreie Grammatik definiert:
  \bgram
  \eta \is [\,] \mid \cl;\eta \n
  \cl \is (e,\eta)
  \egram
  Die {\em L\"ange} $\len{\eta}$ einer De Bruijn-Umgebung $\eta$ ist wie folgt induktiv definiert:
  \[\begin{array}{rcl}
    \len{[\,]} &=& 0 \\
    \len{\cl;\eta} &=& 1 + \len{\eta}
  \end{array}\]
  Eine De Bruijn-Closure $\cl = (e,\eta)$ hei"st {\em wohldefiniert}, wenn $\rank{e} \le \len{\eta}$ und
  $\eta$ wohldefiniert ist. Eine De Bruijn-Umgebung $\eta$ hei"st {\em wohldefiniert}, wenn alle eingetragenen
  Closures wohldefiniert sind.
\end{definition}

\begin{definition}[Big step Regeln]
Ein {\em big step} in der De Bruijn-Umgebungssemantik ist eine Formel der Gestalt $(e,\eta) \Downarrow (e',\eta')$,
wobei $e,e'\in\dbExp$ und $\eta,\eta'\in\dbEnv$. Ein derartiger big step hei"st {\em g"ultig}, wenn er sich mit den
folgenden Regeln herleiten l"asst: \\[5mm]
\begin{tabular}{ll}
  \RN{Val}        & $(v,\eta) \Downarrow (v,\eta)$ \\[3mm]
  \RN{Index}      & $\regel{\hat{\eta}(\iota) \Downarrow \cl}
                           {(\iota,\eta) \Downarrow \cl}$ \\[3mm]
  \RN{Beta}       & $\regel{(e_1,\eta) \Downarrow (\abstr{\id}{e},\eta_1)
                            \quad (e,(e_2,\eta);\eta_1) \Downarrow \cl}
                           {(\app{e_1}{e_2},\eta) \Downarrow \cl}$ \\[3mm]
  \RN{Op-1}       & $\regel{(e_1,\eta) \Downarrow (\op,\eta_1) \quad (e_2,\eta) \Downarrow (z,\eta_2)}
                           {(\app{e_1}{e_2},\eta) \Downarrow (\app{\op}{z},[])}$ \\[3mm]
  \RN{Op-2}       & $\regel{(e_1,\eta) \Downarrow (\app{\op}{z_1},\eta_1)
                            \quad (e_2,\eta) \Downarrow (z_2,\eta_2)
                            \quad \op^I(z_1,z_2) = z}
                           {(\app{e_1}{e_2},\eta) \Downarrow (z,[])}$ \\[3mm]
  \RN{Cond-True}  & $\regel{(e_0,\eta) \Downarrow (\true,\eta_0) \quad (e_1,\eta) \Downarrow \cl}
                           {(\bifte{e_0}{e_1}{e_2},\eta) \Downarrow \cl}$ \\[3mm]
  \RN{Cond-False} & $\regel{(e_0,\eta) \Downarrow (\false,\eta_0) \quad (e_2,\eta) \Downarrow \cl}
                           {(\bifte{e_0}{e_1}{e_2},\eta) \Downarrow \cl}$ \\[3mm]
  \RN{Unfold}     & $\regel{(e_1,\eta) \Downarrow (\bfix,\eta_1)
                            \quad (\app{e_2}{(\app{\bfix}{e_2})},\eta) \Downarrow \cl}
                           {(\app{e_1}{e_2},\eta) \Downarrow \cl}$
\end{tabular}
\end{definition}

\begin{lemma}[Wohldefiniertheit der De Bruijn-Umgebungssemantik]
  Seien $(e,\eta),(\hat{e},\hat{\eta})\in\dbCl$. Wenn $(e,\eta)$ wohldefiniert und
  $(e,\eta) \Downarrow (\hat{e},\hat{\eta})$, dann ist auch $(\hat{e},\hat{\eta})$
  wohldefiniert und es gilt $\hat{e}\in\dbVal$.
\end{lemma}

\begin{proof}
  Vermutlich triviale Induktion.
\end{proof}

Wie zuvor betrachten wir nun nur noch wohldefinierte De Bruijn-Closures und -Umgebungen, d.h. wir nehmen an,
$\dbCl$ und $\dbEnv$ enthalten nur noch wohldefinierte Elemente.

\begin{definition}[Namenskontext]
  Die Menge $\Ncx$ aller {\em Namenskontexte} $\Gamma$ ist induktiv definiert durch:
  \bgram
  \Gamma \is [\,] \mid \id;\Gamma
  \egram
  Der {\em Definitionsbereich} $\dom{\Gamma}$ eines Namenskontext $\Gamma$ ist wie folgt induktiv definiert:
  \[\begin{array}{rcl}
    \dom{[\,]} &=& \emptyset \\
    \dom{\id;\Gamma} &=& \{\id\} \cup \dom{\Gamma}
  \end{array}\]
\end{definition}

\noindent Schreibweisen
\begin{enumerate}
\item F\"ur $\Gamma=(\id_1;\ldots;\id_n;[\,])\in\Ncx$ schreiben wir $[\id_1;\ldots;\id_n]$.
\item F\"ur $\Gamma=[\id_1;\ldots;\id_n]$ und $\id\in\dom{\Gamma}$ sei
  \[ \Gamma(\id) = \min\{j \in \{1,\ldots,n\}\,|\, \id_j = \id\} \]
\end{enumerate}

\begin{definition}[\"Ubersetzungsfunktion]
  Gegeben $e \in Exp$, $\Gamma\in\Ncx$ mit $\free{e} \subseteq \dom{\Gamma}$. Der {\em De Bruijn-Ausdruck}
  $\tr{\Gamma,e}$, welcher durch Entfernen der Bezeichner aus $e$ entsteht, ist wie folgt induktiv definiert:
  \[\begin{array}{rcl}
    \tr{\Gamma,c} &=& c \\
    \tr{\Gamma,\id} &=& \underline{i} \quad \text{ falls } i = \Gamma(\id) \\
    \tr{\Gamma,\abstr{\id}{e}} &=& \abstr{}{\tr{\id;\Gamma,e}} \\
    \tr{\Gamma,\app{e_1}{e_2}} &=& \app{(\tr{\Gamma,e_1})}{(\tr{\Gamma,e_2})} \\
    \tr{\Gamma,\bifte{e_0}{e_1}{e_2}} &=& \bifte{\tr{\Gamma,e_0}}{\tr{\Gamma,e_1}}{\tr{\Gamma,e_2}}
  \end{array}\]
  Sei weiter $\eta=[\id_1:\cl_1;\ldots;\id_n:\cl_n]\in\Env$ mit $\free{e}\subseteq \dom{\eta}$. Die
  {\em De Bruijn-Closure} $\tr{e,\eta}$, welche durch Entfernen der Bezeichner aus $e$ und $\eta$ entsteht,
  ist wie folgt induktiv definiert:
  \[\begin{array}{rcl}
    \tr{e,\eta} &=& (\tr{[\id_1;\ldots;\id_n],e},[\tr{\cl_1};\ldots;\tr{\cl_n}])
  \end{array}\]
\end{definition}

\begin{lemma}[Wohldefiniertheit der \"Ubersetzung] \
  \begin{enumerate}
  \item Seien $e \in \Exp$ und $\Gamma\in\Ncx$ mit $\free{e}\subseteq \dom{\Gamma}$, \\
    dann gilt $(\tr{\Gamma,e})\in\dbExp$.
  \item Sei $\cl\in\Cl$. Dann gilt $(\tr{\cl})\in\dbCl$.
  \end{enumerate}
\end{lemma}

\begin{proof}
  Straight forward induction.
\end{proof}

\begin{lemma}
  Die \"Ubersetzungsfunktion $\name{tr}$ ist {\em strukturerhaltend}.
\end{lemma}

Insbesondere gilt $(\tr{\Gamma,v})\in\dbVal$ f\"ur alle $v\in\Val$ und $\Gamma\in\Ncx$ mit
$\free{v}\subseteq\dom{\Gamma}$.

\begin{proof}
  Klar.
\end{proof}

\begin{theorem}[\"Aquivalenzsatz]
  Sei $(e,\eta),(e',\eta')\in\Cl$. Dann gilt $(e,\eta) \Downarrow (e',\eta')$ gdw.
  $\tr{e,\eta} \Downarrow \tr{e',\eta'}$.
\end{theorem}

\begin{proof}
  Es sind zwei Richtungen zu zeigen, jeweils per Induktion \"uber die L\"ange der Herleitung des big steps mit
  Fallunterscheidung nach der zuletzt angewandten Regel. Dabei muss man sowohl die {\em Strukturerhaltung} der
  \"Ubersetzung als auch die Tatsache ausnutzen, dass die Closures wohldefiniert sind.
\end{proof}


\section{Codegenerierung}

F\"ur die im vorangegangenen Abschnitt beschriebene Programmiersprache soll Maschinencode erzeugt werden. Die
Zielmaschine ist eine abgewandelte Version der {\em CAM (Categorical Abstract Machine)}, welche in {\em ``The
Categorical Abstrach Machine: Basics and Enhancements''} von Ralf Hinze beschrieben wird.


\subsection{Categorical Abstract Machine}

Wir definieren eine abstrakte Maschine in die die Ausdr\"ucke der funktionalen Programmiersprache \"ubersetzt
werden. Wir nennen die hier beschriebene Maschine {\em LazyCAM}, da es sich um die Zielmaschine f\"ur eine
Programmiersprache mit {\em lazy evaluation Semantik} handelt.

\begin{definition}[Syntax der Categorical Abstract Machine]
  Vorgegeben sei eine (unendliche) Menge $\Loc$ von {\em Programmaddressen} $\ell$. Die Mengen $\Prog$ der g\"ultigen
  {\em (CAM-)Programme} $P$, $\Instr$ der g\"ultigen {\em (CAM-)Instruktionen} $I$, $\Reg$ der g\"ultigen
  {\em (CAM-)Registerinhalte} $R$ und $\Stack$ der g\"ultigen {\em (CAM-)Stackinhalte} $S$ sind wie folgt induktiv
  definiert:
  \bgram
  P \is \ell: I \mid P_1;P_2 \\
  I \is \textsc{Fst} \mid \textsc{Snd} \mid \textsc{Push} \mid \textsc{Swap}
  \mid \textsc{Quote}\,c \mid \textsc{Prim}\,\op
  \al \textsc{Closure}\,\ell \mid \textsc{Abstr}\,\ell \mid \textsc{App} \mid \textsc{Eval} \mid \textsc{Return}
  \al \textsc{GotoFalse}\,\ell \mid \textsc{Goto}\,\ell \mid \textsc{Skip} \mid \textsc{Stop} \\
  R \is c \mid \ell \mid \underbrace{(R_1,R_2)}_{\text{Umgebung}} \mid \underbrace{[R:\ell]}_{\text{Closure}} \\
  S \is [\,] \mid R;S
  \egram
  Die Menge $\locns{P} \subseteq \Loc$ aller Programmadressen von $P$ ist wie folgt induktiv definiert:
  \[\begin{array}{rcl}
    \locns{\ell:I} &=& \{\ell\} \\
    \locns{P_1;P_2} &=& \locns{P_1} \cup \locns{P_2}
  \end{array}\]
  Analog werden die Mengen $\locns{R}$ und $\locns{S}$ induktiv definiert ({\bf TODO}).
\end{definition}

Wir gehen im folgenden davon aus, dass jede Instruktion $I$ eine eindeutige Programmaddresse $\ell$ besitzt.
Letztere werden \"ublicherweise durch ganzzahlige Werte repr\"asentiert, was f\"ur uns an dieser Stelle aber
irrelevant ist. Statt $\ell:I$ schreiben wir kurz $I$, wenn die konkrete Programmaddresse von $I$ nicht interessiert.
Wir schreiben $P[\ell_i]$ f\"ur die Instruktion $I$ an der
Programmaddresse $\ell_i\in\locns{P}$ im Programm $P$. Weiterhin schreiben wir $\ell_{i+1}$ f\"ur die auf $\ell_i$
folgende Programmaddresse in $P$ (so sie existiert).
Die Semantik der CAM und damit die Bedeutung der einzelnen Instruktionen wird nachfolgend beschrieben.

\begin{definition}[Semantik der Categorical Abstract Machine]
  Sei $P\in\Prog$ ein g\"ultiges Programm. Ein {\em (CAM-)Programmzustand} f\"ur $P$ ist ein Tripel der Form
  $(R,S,\ell) \in \Reg \times \Stack \times \Loc$, mit
  \[
  \locns{R}\cup\locns{S}\cup\{\ell\}\subseteq\locns{P}.
  \]
  Die Menge aller g\"ultigen Programmzust\"ande f\"ur $P$ bezeichnen wir mit $\State(P)$, oder kurz $\State$,
  wenn $P$ aus dem Kontext hervorgeht. Die \"Ubergangsrelation $\to$ der CAM ist in 
  Tabelle~\ref{table:CAM_Reductions} beschrieben, wobei die Schreibweise $\ell_i:I$ die Programmaddresse
  $\ell_i$ bezeichnet mit $P[\ell_i] = I$.
\end{definition}

\begin{figure}
  {\footnotesize
  \begin{center}
    \begin{tabular}{|rcl|l|}
      \hline
      Zustand \hfill \quad && Nachfolger & Beschreibung \\
      \hline
      $((R_1,R_2),S,\ell_i:\textsc{Fst})$ & $\to$ & $(R_1,S,\ell_{i+1})$ & Erste Projektion \\
      $((R_1,R_2),S,\ell_i:\textsc{Snd})$ & $\to$ & $(R_2,S,\ell_{i+1})$ & Zweite Projektion \\
      \hline
      $(R,S,\ell_i:\textsc{Push})$ & $\to$ & $(R,R;S,\ell_{i+1})$ & Registerinhalt auf Stack \\
      $(R_1,R_2;S,\ell_i:\textsc{Swap})$ & $\to$ & $(R_2,R_1;S,\ell_{i+1})$ & Registerinhalt und oberstes \\
      &&& Stackelement vertauschen \\
      \hline
      $(R,S,\ell_i:\textsc{Quote}\,c)$ & $\to$ & $(c,S,\ell_{i+1})$ & $c$ in Register laden \\
      $(z_2,z_1;S,\ell_i:\textsc{Prim}\,\op)$ & $\to$ & $(\op^I(z_1,z_2),S,\ell_{i+1})$ & Operation $\op$ ausf\"uhren \\
      $(R,S,\ell_i:\textsc{Closure}\,\ell)$ & $\to$ & $([R:\ell],S,\ell_{i+1})$ & Abschluss bilden \\
      \hline
      $([R_1:\ell],R_2;S,\ell_i:\textsc{App})$ & $\to$ & $((R_1,R_2),\ell_{i+1};S,\ell)$ & Funktionsaufruf \\
      $([R:\ell],S,\ell_i:\textsc{Eval})$ & $\to$ & $(R,\ell_{i+1};S,\ell)$ & Verz\"ogerte Auswertung \\
      &&& einer Closure \\
      $(R,\ell;S,\ell_i:\textsc{Return})$ & $\to$ & $(R,S,\ell)$ & R\"ucksprung aus Closure \\
      $(\true,R;S,\ell_i:\textsc{GotoFalse}\,\ell)$ & $\to$ & $(R,S,\ell_{i+1})$ & Sprung zu $\ell$ wenn Register \\
      $(\false,R;S,\ell_i:\textsc{GotoFalse}\,\ell)$ & $\to$ & $(R,S,\ell)$ & den Wert $\false$ enth\"alt \\
      $(R,S,\ell_i:\textsc{Goto}\,\ell)$ & $\to$ & $(R,S,\ell)$ & Unbedingter Sprung zu $\ell$ \\
      $(R,S,\ell_i:\textsc{Skip})$ & $\to$ & $(R,S,\ell_{i+1})$ & No-op \\
      \hline
    \end{tabular}
  \end{center}}
  \caption{\"Ubergangsrelation}
  \label{table:CAM_Reductions}
\end{figure}

\begin{lemma}[Wohldefiniertheit der \"Ubergangsrelation]
  Sei $P\in\Prog$ ein Programm. Wenn $(R,S,\ell)\in\State(P)$ und $(R,S,\ell) \to (R',S',\ell')$, dann gilt auch
  $(R',S',\ell')\in\State(P)$.
\end{lemma}

\begin{proof}
  Sollte sich per Fallunterscheidung recht einfach zeigen lassen, wobei man immer wieder auf die Annahme zur\"uckkommen
  muss, dass
  der Anfangszustand schon g\"ultig ist, und man muss beachten, dass die Maschine keinen \"Ubergang macht, wenn
  der Folgezustand $\ell_{i+1}$ nicht im Programm liegt (das steckt implizit in der Schreibweise).
\end{proof}

\begin{lemma}[Eindeutigkeit der \"Ubergangsrelation]
  Sei $P\in\Prog$ ein Programm. F\"ur jeden Zustand $s\in\State(P)$ existiert h\"ochstens ein $s'\in\State(P)$, so
  dass $s \to s'$.
\end{lemma}

\begin{definition}[Berechnung]
  Sei $P\in\Prog$ ein Programm. Eine {\em Berechnung} f\"ur $P$ ist eine (m\"oglicherweise unendliche) Folge von
  Zust\"anden
  \[
  (R_0,S_0,\ell_0) \to (R_1,S_1,\ell_1) \to (R_2,S_2,\ell_2) \to \ldots,
  \]
  wobei $\ell_0$ die erste Addresse im Programm $P$ bezeichnet. Eine Berechnung hei"st
  \begin{enumerate}
    \item {\em terminierend}, wenn sie endlich ist und der letzte Zustand die Form $(R_e,S_e,\ell_e)$
      mit $P[\ell_e] = \textsc{Stop}$ hat, oder
    \item {\em divergierend}, wenn sie unendlich ist, oder
    \item {\em stecken bleibend}, sonst.
  \end{enumerate}
\end{definition}


\subsection{Erzeugung von Zielcode}

Zun\"achst \"andern wir die Programmiersprache geringf\"ugig, um die \"Ubersetzung einfacher zu gestalten. Und
zwar entfernen wir die Operatoren aus der Menge der Konstanten, und nehmen stattdessen einen Ausdruck der
Form $e_1\,\op\,e_2$ zur Kernsyntax hinzu, mit folgender Semantik: \\[5mm]
\begin{tabular}{ll}
  \RN{Op} & $\regel{(e_1,\eta) \Downarrow (z_1,\eta_1) \quad (e_2,\eta) \Downarrow (z_2,\eta_2)
                    \quad \op^I(z_1,z_2)=c}
                   {(e_1\,\op\,e_2,\eta) \Downarrow (c,[])}$
\end{tabular} \\[5mm]
Weiterhin entfernen wir den Fixpunktoperator und die \RN{Unfold}-Regel. Stattdessen nehmen wir folgende
Konstrukte als syntaktischen Zucker auf:
\[\begin{array}{rcl}
  (\op) &=_{def}& \abstr{}{\abstr{}{\underline{2}\,\op\,\underline{1}}} \\
  \bfix &=_{def}& \abstr{}{\app{(\abstr{}{\app{\underline{2}}{(\app{\underline{1}}{\underline{1}})}})}
                              {(\abstr{}{\app{\underline{2}}{(\app{\underline{1}}{\underline{1}})}})}}
\end{array}\]
Letztere \"Ubersetzung entspricht dem vom Haskell Curry entdeckten Fixpunkt-Kombinator f\"ur call-by-name:
\[\begin{array}{rcl}
  Y &=_{def}& \abstr{f}{\app{(\abstr{x}{\app{f}}{(\app{x}{x})})}{(\abstr{x}{\app{f}}{(\app{x}{x})})}}
\end{array}\]
Es ist nun basierend auf der big step Semantik zu zeigen, dass diese \"Ubersetzungen korrekt sind, bzgl. der
zuvor benutzten Semantik.

Die {\em LazyCAM}-Codegenerierung f\"ur einen Ausdruck $e\in\Exp$ wird durch die folgenden drei Funktionen erledigt:
\begin{enumerate}
\item $\mathcal{P}\sem{e}$ erzeugt das Programm f\"ur $e$, d.h. den Code zur Berechnung des Wertes von $e$ und
  den abschliessenden $\textsc{Stop}$-Befehl.
\item $\mathcal{C}\sem{e}$ erwartet, dass $R$ die Umgebung enth\"alt, in der $e$ ausgewertet werden soll, und
  generiert Code, welcher eine Closure (mit der zuvor in $R$ befindlichen Umgebung) f\"ur $e$ in $R$ ablegt.
\item $\mathcal{V}\sem{e}$ erwartet, dass $R$ die Umgebung enth\"alt, in der $e$ ausgewertet werden soll, und
  generiert Code, welcher den Wert von $e$ berechnet und in $R$ ablegt.
\end{enumerate}
Diese Funktionen sind wie folgt induktiv definiert:
\[\begin{array}{rcl}
  \mathcal{P}\sem{e} &=& \mathcal{V}\sem{e};\,\textsc{Stop} \\
  \\
  \mathcal{C}\sem{e} &=& \textsc{Goto}\,\ell_2;\,\ell_1:\textsc{Skip};\,
                         \mathcal{V}\sem{e};\,\textsc{Return}; \\
                      && \ell_2:\textsc{Closure}\,\ell_1 \\
  \\
  \mathcal{V}\sem{c} &=& \textsc{Quote}\,c \\
  \mathcal{V}\sem{\underline{i}} &=& \underbrace{\textsc{Fst};\ldots;\,\textsc{Fst}}_{\text{$(i-1)$-mal}};\,
                                     \textsc{Snd};\,\textsc{Eval} \\
  \mathcal{V}\sem{\abstr{}{e}} &=& \mathcal{C}\sem{e} \\
  \mathcal{V}\sem{\app{e_1}{e_2}} &=& \textsc{Push};\,\mathcal{V}\sem{e_1};\,\textsc{Swap};\,
                                      \mathcal{C}\sem{e_2};\,\textsc{App} \\
  \mathcal{V}\sem{e_1\,\op\,e_2} &=& \textsc{Push};\,\mathcal{V}\sem{e_1};\,\textsc{Swap};\,
                                     \mathcal{V}\sem{e_2};\,\textsc{Prim}\,\op \\
  \mathcal{V}\sem{\bifte{e_0}{e_1}{e_2}} &=& \textsc{Push};\,\mathcal{V}\sem{e_0};\,\textsc{GotoFalse}\,\ell_1;\,
                                             \mathcal{V}\sem{e_1}; \\
                                         &&  \textsc{Goto}\,\ell_2;\,\ell_1:\textsc{Skip};\,
                                             \mathcal{V}\sem{e_2};\,\ell_2:\textsc{Skip}
\end{array}\]


Diese \"Ubersetzung ist herzlich ineffizient, denn z.B. werden f\"ur $\lambda$-Ausdr\"ucke Parameter-Position
zwei Closures erzeugt, oder f\"ur einfache Konstanten wird auf Parameter-Position ebenfalls immer eine Closure
erzeugt, obwohl dies nicht notwendig w\"are. Noch sinnloser sind die De Bruijn-Indizes, hier wird dann eine
Closure erzeugt, die die Closure aus der Umgebung holt und auswertet. Letzteres liesse sich durch geschicke
\"Anderung der \"Ubersetzungsfunktionen regeln. Das allgemeine Problem unn\"otiger Closures k\"onnte man dadurch
l\"osen, dass man zwischen Closure und Funktionswert unterscheidet und entsprechend die \textsc{Eval}-Instruktion
ab\"andert, wie dies im Willhelm/Maurer gemacht wird (allerdings dann ohne Call-by-need).

Zun\"achst sollte man aber diese sehr naive \"Ubersetzung nehmen und beweisen, dass die semantikerhaltend ist. Dazu
muss man zun\"achst geeignete Invarianten (wie sie oben schon angedeutet sind) bestimmen. Daraus sollte man dann
auf eine beweisbare Form kommen. Intuitiv muss folgendes gezeigt werden:
\begin{quote}
  Wenn $(e,[\,]) \Downarrow (v,\eta)$, dann existiert f\"ur $P=\mathcal{P}\sem{e}$ eine terminierende Berechnung
  $(R_0,S_0,\ell_0) \xrightarrow* (R,S,\ell:\textsc{Stop})$, so dass $R$ zu $(v\,\eta)$ {\em passt}. Und man
  m\"usste leicht zeigen k\"onnen, dass die Wahl von $R_0$ und $S_0$ egal ist wenn $e$ abgeschlossen ist (genaugenommen
  braucht man irgendwie ein Lemma, welches $R_0$ und $S_0$ mit der initialen Umgebung in Verbindung bringt, um die
  Korrektheit induktiv zu zeigen; dann ist die Invarianz unter der Wahl von $R_0$/$S_0$ eine triviale Folgerung).
\end{quote}


\end{document}

% vi:set ts=2 sw=2 et:
