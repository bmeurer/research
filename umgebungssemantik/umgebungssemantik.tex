\documentclass[12pt,fleqn]{article}
\usepackage{ngerman}
\usepackage{hyperref,german,amssymb,amstext,amsmath,amsthm,array,stmaryrd,color,latexsym}

% TP Macros
\input{TP}

\newcommand{\RN}[1]{\mbox{\textsc{(#1)}}}
\newcommand{\Cl}{\name{Cl}}
\newcommand{\cl}{\name{cl}}

\begin{document}

\section{Substitutionssemantik}

Voraussetzungen:
\begin{itemize}
  \item $\Id \cap \Val = \emptyset$

  \item Ausdr"ucke sind gleich modulo Umbenennung gebundener Namen.

        Geht nat"urlich auch ohne diese Konvention, aber macht Definitionen und Beweise h"asslich.
\end{itemize}

\begin{definition}[Big step Regeln]
Ein {\em big step} in der Substitutionssemantik ist eine Formel der Gestalt $e \Downarrow v$ mit $e\in\Exp$
und $v \in \Val$. Ein solcher big step hei"st {\em g"ultig}, wenn er sich mit den folgenden Regeln herleiten
l"asst: \\[5mm]
\begin{tabular}{ll}
  \RN{Val}        & $v \Downarrow v$ \\[3mm]
  \RN{Beta}       & $\regel{e_1 \Downarrow \abstr{\id}{e} \quad e[e_2/\id] \Downarrow v}
                           {\app{e_1}{e_2} \Downarrow v}$ \\[3mm]
  \RN{Op-1}       & $\regel{e_1 \Downarrow \op \quad e_2 \Downarrow z}
                           {\app{e_1}{e_2} \Downarrow \app{\op}{z}}$ \\[3mm]
  \RN{Op-2}       & $\regel{e_1 \Downarrow \app{\op}{z_1} \quad e_2 \Downarrow z_2 \quad \op^I(z_1,z_2) = z}
                           {\app{e_1}{e_2} \Downarrow z}$ \\[3mm]
  \RN{Cond-True}  & $\regel{e_0 \Downarrow \true \quad e_1 \Downarrow v}
                           {\bifte{e_0}{e_1}{e_2} \Downarrow v}$ \\[3mm]
  \RN{Cond-False} & $\regel{e_0 \Downarrow \false \quad e_2 \Downarrow v}
                           {\bifte{e_0}{e_1}{e_2} \Downarrow v}$ \\[3mm]
  \RN{Unfold}     & $\regel{e_1 \Downarrow \bfix \quad \app{e_2}{(\app{\bfix}{e_2})} \Downarrow v}
                           {\app{e_1}{e_2} \Downarrow v}$
\end{tabular}
\end{definition}


\section{Umgebungssemantik}

\begin{definition}[Closures und Umgebungen]
  Die Menge $\Env$ aller {\em (Laufzeit-)Umgebungen} $\eta$ und die Menge $\Cl$ aller {\em Closures} $\cl$ sind
  durch die folgende kontextfreie Grammatik definiert:
  \bgram
  \eta \is [\,] \mid \id:\cl;\eta \n
  \cl \is (e,\eta)
  \egram
  Der {\em Definitionsbereich} $\dom{\eta}$ einer Umgebung $\eta$ ist wie folgt induktiv definiert:
  \[\begin{array}{rcl}
    \dom{[\,]} &=& \emptyset \\
    \dom{\id:\cl;\eta} &=& \{\id\} \cup \dom{\eta}
  \end{array}\]
  Eine Closure $\cl = (e,\eta)$ hei"st {\em wohldefiniert}, wenn $\free{e} \subseteq \dom{\eta}$ und
  $\eta$ wohldefiniert ist. Eine Umgebung $\eta$ hei"st {\em wohldefiniert}, wenn alle eingetragenen
  Closures wohldefiniert sind.
\end{definition}

\noindent Schreibweisen
\begin{enumerate}
\item F\"ur $(\id_1:\cl_1;\ldots;\id_n:\cl_n;[\,])\in\Env$ schreiben wir
  \[
  [\id_1:\cl_1;\ldots;\id_n:\cl_n]
  \]
\item F\"ur $\eta=(\id_1:\cl_1;\ldots;\id_n:\cl_n;[\,])\in\Env$ und $\id\in\dom{\eta}$ sei
  \[
  \eta(\id) = \cl_i, \text{ wobei } i = \min\{j \in \{1,\ldots,n\}\,|\,\id_j=\id\}
  \]
\end{enumerate}

\begin{definition}[Big step Regeln]
Ein {\em big step} in der Umgebungssemantik ist eine Formel der Gestalt $(e,\eta) \Downarrow (e',\eta')$,
wobei $e,e'\in\Exp$ und $\eta,\eta'\in\Env$. Ein derartiger big step hei"st {\em g"ultig}, wenn er sich mit den
folgenden Regeln herleiten l"asst: \\[5mm]
\begin{tabular}{ll}
  \RN{Val}        & $(v,\eta) \Downarrow (v,\eta)$ \\[3mm]
  \RN{Id}         & $\regel{\eta(\id) \Downarrow \cl}
                           {(\id,\eta) \Downarrow \cl}$ \\[3mm]
  \RN{Beta}       & $\regel{(e_1,\eta) \Downarrow (\abstr{\id}{e},\eta_1)
                            \quad (e,\eta_1[(e_2,\eta)/\id]) \Downarrow \cl}
                           {(\app{e_1}{e_2},\eta) \Downarrow \cl}$ \\[3mm]
  \RN{Op-1}       & $\regel{(e_1,\eta) \Downarrow (\op,\eta_1) \quad (e_2,\eta) \Downarrow (z,\eta_2)}
                           {(\app{e_1}{e_2},\eta) \Downarrow (\app{\op}{z},[])}$ \\[3mm]
  \RN{Op-2}       & $\regel{(e_1,\eta) \Downarrow (\app{\op}{z_1},\eta_1)
                            \quad (e_2,\eta) \Downarrow (z_2,\eta_2)
                            \quad \op^I(z_1,z_2) = z}
                           {(\app{e_1}{e_2},\eta) \Downarrow (z,[])}$ \\[3mm]
  \RN{Cond-True}  & $\regel{(e_0,\eta) \Downarrow (\true,\eta_0) \quad (e_1,\eta) \Downarrow \cl}
                           {(\bifte{e_0}{e_1}{e_2},\eta) \Downarrow \cl}$ \\[3mm]
  \RN{Cond-False} & $\regel{(e_0,\eta) \Downarrow (\false,\eta_0) \quad (e_2,\eta) \Downarrow \cl}
                           {(\bifte{e_0}{e_1}{e_2},\eta) \Downarrow \cl}$ \\[3mm]
  \RN{Unfold}     & $\regel{(e_1,\eta) \Downarrow (\bfix,\eta_1)
                            \quad (\app{e_2}{(\app{\bfix}{e_2})},\eta) \Downarrow \cl}
                           {(\app{e_1}{e_2},\eta) \Downarrow \cl}$
\end{tabular}
\end{definition}

\begin{lemma}[Wohldefiniertheit der Umgebungssemantik] \label{lemma:Wohldefiniertheit}
  Seien $(e,\eta),(\hat{e},\hat{\eta})\in\Cl$. Wenn $(e,\eta)$ wohldefiniert und
  $(e,\eta) \Downarrow (\hat{e},\hat{\eta})$, dann ist auch $(\hat{e},\hat{\eta})$
  wohldefiniert und es gilt $\hat{e}\in \Val$.
\end{lemma}

\begin{proof}
  Vermutlich triviale Induktion.
\end{proof}

Im Weiteren betrachten wir nur noch wohldefinierte Closures und Umgebungen, d.h. wir nehmen an,
$\Cl$ und $\Env$ enthalten nur noch wohldefinierte Elemente.

\begin{definition} \label{definition:Substitution}
  Sei $(e,\eta) \in \Cl$. Der Ausdruck $e\,\eta$ ist wie folgt
  induktiv definiert:
  \[\begin{array}{rcl}
    c\,\eta &=& c \\
    \id\,\eta &=& e'\,\eta', \text{ wobei } \eta(\id) = (e',\eta') \\
    (\app{e_1}{e_2})\,\eta &=& \app{(e_1\,\eta)}{(e_2\,\eta)} \\
    (\abstr{\id}{e})\,\eta &=& \abstr{\id'}{(e[\id'/\id]\,\eta)}, \text{ wobei } \id'\not\in\dom{\eta} \\
    (\bifte{e_0}{e_1}{e_2})\,\eta &=& \bifte{(e_0\,\eta)}{(e_1\,\eta)}{(e_2\,\eta)}
  \end{array}\]
\end{definition}

\begin{lemma} \label{lemma:Substitution}
  Seien $(e,\eta), (e',\eta') \in \Cl$. Dann gilt:
  \begin{enumerate}
    \item $e\in\Val$ impliziert $(e\,\eta)\in\Val$.
    \item $(e\,\eta)\in\Val$, dann entweder $e\in\Val$ oder
          $e=\id\in\Id$ und $\eta(\id) = (e',\eta')$ mit $(e'\,\eta')\in\Val$
    %\item $(e\,\eta) = (e\,\eta')$ wenn $\eta' =_{\free{e}} \eta$
    \item $e\,(\eta[(e',\eta')/\id]) = (e[\id'/\id]\,\eta)[(e'\,\eta')/\id']$ wenn $\id' \not\in \dom{\eta}$
  \end{enumerate}
\end{lemma}


\section{"Aquivalenz der Modelle}

\begin{theorem}[Korrektheit der Umgebungssemantik] \label{theorem:Korrektheit}
  Seien $(e,\eta) \in \Cl$, $v'\in\Val$ und $\eta'\in\Env$. Wenn $(e,\eta) \Downarrow (v',\eta')$, dann
  $(e\,\eta) \Downarrow (v'\,\eta')$.
\end{theorem}

\begin{proof}
  Induktion "uber die L"ange der Herleitung des big steps $(e,\eta) \Downarrow (v',\eta')$ mit Fallunterscheidung
  nach der zuletzt angewandten big step Regel:
  \begin{itemize}
    \item $(v,\eta) \Downarrow (v,\eta)$ mit \RN{Val}, dann ist $(v\,\eta) \in \Val$ und somit folgt
          $(v\,\eta) \Downarrow (v\,\eta)$ mit \RN{Val}.

    \item $(\id,\eta) \Downarrow (v',\eta')$ mit \RN{Id} bedingt $\eta(\id) = (\hat{e},\hat{\eta})$ und
          $(\hat{e},\hat{\eta}) \Downarrow (v',\eta')$. Nach IV muss also $(\hat{e}\,\hat{\eta})\Downarrow(v'\,\eta')$
          gelten, und somit folgt wegen $(\id\,\eta) = (\hat{e}\,\hat{\eta})$ die Behauptung.

    \item $(\app{e_1}{e_2},\eta) \Downarrow (v',\eta')$ mit Regel \RN{Beta} kann nur aus Pr"amissen der Form
          $(e_1,\eta) \Downarrow (\abstr{\id}{e},\hat{\eta})$ und $(e,\hat{\eta}[(e_2,\eta)/\id])\Downarrow(v',\eta')$
          folgen. Mit IV folgt daraus $(e_1\,\eta) \Downarrow (\abstr{\id}{e})\,\hat{\eta}$ und
          $e\,(\hat{\eta}[(e_2,\eta)/\id])\Downarrow(v'\,\eta')$. Nach Definition~\ref{definition:Substitution}
          gilt $(\abstr{\id}{e})\,\hat{\eta} = \abstr{\id'}{(e[\id'/\id]\,\hat{\eta})}$ wobei
          $\id'\not\in\dom{\hat{\eta}}$. Nach Lemma~\ref{lemma:Substitution} folgt dar"uberhinaus
          $e\,(\hat{\eta}[(e_2,\eta)/\id]) = (e[\id'/\id]\,\hat{\eta})[e_2\,\eta/\id]$, und somit
          $(\app{e_1}{e_2})\,\eta \Downarrow (v'\,\eta')$ mit Regel \RN{Beta}.

%     \item $(\rec{\id}{e},\eta) \Downarrow (v',\eta')$ kann ausschliesslich mit \RN{Unfold} aus der Pr"amisse
%           $(e,\eta[(\rec{\id}{e},\eta)/\id]) \Downarrow (v',\eta')$ folgen. Nach IV gilt dann ebenfalls
%           $e\,(\eta[(\rec{\id}{e},\eta)/\id]) \Downarrow (v'\,\eta')$ und nach Definition~\ref{definition:Substitution}
%           gilt $(\rec{\id}{e})\,\eta = \rec{\id'}{(e[\id'/\id]\,\eta)}$ mit $\id'\not\in\dom{\eta}$. Wegen
%           Lemma~\ref{lemma:Substitution} folgt dann
%           $e\,(\eta[(\rec{\id}{e},\eta)/\id]) = (e[\id'/\id]\,\eta)[\rec{\id'}{(e[\id'/\id]\,\eta)}/\id]$ und
%           somit $(\rec{\id}{e})\,\eta \Downarrow (v'\,\eta')$ mit Regel \RN{Unfold}.
  \end{itemize}
  Die "ubrigen F"alle folgen analog.
\end{proof}

\begin{lemma}[Koinzidenz] \label{lemma:Koinzidenz}
  F"ur alle $\eta,\hat{\eta},\eta'\in\Env$, ...
  Wenn $(e[(e_2\,\eta)/\id],[\,]) \Downarrow (v',\eta')$, dann ex. $\eta''$, so dass
  $(e,\hat{\eta}[(e_2,\eta)/\id]) \Downarrow (v',\eta'')$.
\end{lemma}

\begin{proof}
  Sollte gelten, m"usste aber allgemeiner formuliert werden, um einfach beweisbar zu sein.
\end{proof}

\begin{theorem}[Vollst"andigkeit der Umgebungssemantik] \label{theorem:Vollstaendigkeit}
  Seien $(e,\eta)\in\Cl$ und $v \in \Val$.
  Wenn $(e\,\eta) \Downarrow v$, dann ex. $(v',\eta')\in\Cl$ mit $(v'\,\eta') = v$, so dass
  $(e,\eta) \Downarrow (v',\eta')$.
\end{theorem}

Man k"onnte hier vermutlich auch noch eine konkretere Aussage "uber $v'$ und $\eta'$ machen, so man das will.

\begin{proof}
  Offensichtlich gilt $\free{v} = \emptyset$. Die Behauptung folgt
  dann per Induktion "uber die L"ange der Herleitung des big steps $(e\,\eta) \Downarrow v$, wobei jeweils nach der
  zuletzt angewandten Regel unterschieden wird. Hierbei ist in jedem der F"alle zu unterscheiden, ob $e$ selbst
  schon von der f"ur die Regel passenden Form ist, oder ob $e$ ein Identifier ist. Ist $e$ ein Identifier, so
  folgt die Behauptung unmittelbar mit IV und big step Regel \RN{Id}; wir betrachten diesen Fall damit als erledigt
  und konzentrieren uns im Folgenden auf die F"alle f"ur $e\not\in\Id$.
  \begin{itemize}
    \item $v \Downarrow v$ mit $\RN{Val}$, d.h. $(e\,\eta) = v$. Sei o.B.d.A. $e \in \Val$, dann existiert ein
          big step $(e,\eta) \Downarrow (e,\eta)$ mit $\RN{Val}$.
          
%     \item $(\rec{\id}{e})\,\eta \Downarrow v$ mit $\RN{Unfold}$ bedingt o.B.d.A.
%           $(e[\id'/\id]\,\eta)[(\rec{\id}{e})\,\eta/\id'] \Downarrow v$, wobei $\id' \not\in \dom{\eta}$.
%           Nach Lemma~\ref{lemma:Substitution} folgt $e\,(\eta[(\rec{\id}{e})\,\eta/\id])\Downarrow v$ und nach IV
%           existiert dann $(v',\eta') \in \Cl$ mit $(v'\,\eta') = v$, so dass
%           $(e,\eta[(\rec{\id}{e},\eta)/\id]) \Downarrow (v',\eta')$. Die Behauptung folgt unmittelbar mit
%           \RN{Unfold}.

    \item $(\app{e_1}{e_2})\,\eta \Downarrow v$ mit \RN{Beta} kann o.B.d.A. nur aus Pr"amissen der Form
          $(e_1\,\eta) \Downarrow \abstr{\id}{e}$ und $e[(e_2\,\eta)/\id]\Downarrow v$ folgen. Nach IV ex.
          $(\hat{v},\hat{\eta}),(v',\eta')\in\Cl$, so dass $(e_1,\eta) \Downarrow (\hat{v},\hat{\eta})$
          und $(e[(e_2\,\eta)/\id],[\,])\Downarrow (v',\eta')$. Nach Lemma~\ref{lemma:Koinzidenz} ex. $\eta''$
          mit $(e,\hat{\eta}[(e_2,\eta)/\id]) \Downarrow (v',\eta'')$. O.B.d.A. ex. $\hat{\id}\not\in\dom{\hat{\eta}}$,
          so dass $(e_1,\eta) \Downarrow (\abstr{\hat{\id}}{e[\hat{\id}/\id]},\hat{\eta})$ und
          $(e[\hat{\id}/\id],\hat{\eta}[(e_2,\eta)/\hat{\id}]) \Downarrow (v',\eta'')$. Die Behauptung folgt
          unmittelbar mit \RN{Beta}.
  \end{itemize}
  Die restlichen F"alle folgen "ahnlich einfach.
\end{proof}

\begin{theorem}["Aquivalenzsatz]
  Sei $e \in \Exp$, $v \in \Val$ mit $\free{e} = \emptyset$. Die folgenden Aussagen sind "aquivalent:
  \begin{enumerate}
    \item $e \Downarrow v$
    \item ex. $(v',\eta')\in\Cl$ mit $v = (v'\,\eta')$, so dass $(e,[\,]) \Downarrow (v',\eta')$
  \end{enumerate}
\end{theorem}

\begin{proof}
  Folgt leicht aus Satz~\ref{theorem:Korrektheit} und Satz~\ref{theorem:Vollstaendigkeit}.
\end{proof}

\begin{corollary}
  Sei $e \in \Exp$, $c \in \Const$ mit $\free{e} = \emptyset$. Die folgenden Aussagen sind "aquivalent:
  \begin{enumerate}
    \item $e \Downarrow c$
    \item ex. $\eta\in\Cl$, so dass $(e,[\,]) \Downarrow (c,\eta)$
  \end{enumerate}
\end{corollary}


\section{De Bruijn Indizes}

\begin{definition}[Expressions]
  Vorgeben sei eine (unendliche) Menge $\{\underline{1},\underline{2},\ldots\}$ von {\em De Bruijn-Indizes}
  $\iota$. Die Menge $\dbExp$ aller {\em De Bruijn-Ausdr\"ucke} $e$ ist durch die kontextfreie Grammatik
  \bgram
  e \is c \mid \iota \mid \abstr{}{e} \mid \app{e_1}{e_2} \mid \bifte{e_0}{e_1}{e_2}
  \egram
  definiert. Der {\em Rang} $\rank{e} \in \setN$ eines De Bruijn-Ausdrucks $e$ ist wie folgt induktiv definiert:
  \[\begin{array}{rcl}
    \rank{c} &=& 0 \\
    \rank{\iota} &=& \iota \\
    \rank{\abstr{}{e}} &=& \max(\rank{e},1) - 1 \\
    \rank{\app{e_1}{e_2}} &=& \max(\rank{e_1},\rank{e_2}) \\
    \rank{\bifte{e_0}{e_1}{e_2}} &=& \max(\rank{e_0},\rank{e_1},\rank{e_2})
  \end{array}\]
\end{definition}

\begin{definition}[Closures und Umgebungen]
  Die Menge $\dbEnv$ aller {\em De Bruijn-(Laufzeit-)Umgebungen} $\eta$ und die Menge $\dbCl$ aller
  {\em De Bruijn-Closures} $\cl$ sind durch die folgende kontextfreie Grammatik definiert:
  \bgram
  \eta \is [\,] \mid \cl;\eta \n
  \cl \is (e,\eta)
  \egram
  Die {\em L\"ange} $\len{\eta}$ einer De Bruijn-Umgebung $\eta$ ist wie folgt induktiv definiert:
  \[\begin{array}{rcl}
    \len{[\,]} &=& 0 \\
    \len{\cl;\eta} &=& 1 + \len{\eta}
  \end{array}\]
  Eine De Bruijn-Closure $\cl = (e,\eta)$ hei"st {\em wohldefiniert}, wenn $\rank{e} \le \len{\eta}$ und
  $\eta$ wohldefiniert ist. Eine De Bruijn-Umgebung $\eta$ hei"st {\em wohldefiniert}, wenn alle eingetragenen
  Closures wohldefiniert sind.
\end{definition}

\begin{definition}[Big step Regeln]
Ein {\em big step} in der De Bruijn-Umgebungssemantik ist eine Formel der Gestalt $(e,\eta) \Downarrow (e',\eta')$,
wobei $e,e'\in\dbExp$ und $\eta,\eta'\in\dbEnv$. Ein derartiger big step hei"st {\em g"ultig}, wenn er sich mit den
folgenden Regeln herleiten l"asst: \\[5mm]
\begin{tabular}{ll}
  \RN{Val}        & $(v,\eta) \Downarrow (v,\eta)$ \\[3mm]
  \RN{Index}      & $\regel{\eta(\iota) \Downarrow \cl}
                           {(\iota,\eta) \Downarrow \cl}$ \\[3mm]
  \RN{Beta}       & $\regel{(e_1,\eta) \Downarrow (\abstr{\id}{e},\eta_1)
                            \quad (e,(e_2,\eta);\eta_1) \Downarrow \cl}
                           {(\app{e_1}{e_2},\eta) \Downarrow \cl}$ \\[3mm]
  \RN{Op-1}       & $\regel{(e_1,\eta) \Downarrow (\op,\eta_1) \quad (e_2,\eta) \Downarrow (z,\eta_2)}
                           {(\app{e_1}{e_2},\eta) \Downarrow (\app{\op}{z},[])}$ \\[3mm]
  \RN{Op-2}       & $\regel{(e_1,\eta) \Downarrow (\app{\op}{z_1},\eta_1)
                            \quad (e_2,\eta) \Downarrow (z_2,\eta_2)
                            \quad \op^I(z_1,z_2) = z}
                           {(\app{e_1}{e_2},\eta) \Downarrow (z,[])}$ \\[3mm]
  \RN{Cond-True}  & $\regel{(e_0,\eta) \Downarrow (\true,\eta_0) \quad (e_1,\eta) \Downarrow \cl}
                           {(\bifte{e_0}{e_1}{e_2},\eta) \Downarrow \cl}$ \\[3mm]
  \RN{Cond-False} & $\regel{(e_0,\eta) \Downarrow (\false,\eta_0) \quad (e_2,\eta) \Downarrow \cl}
                           {(\bifte{e_0}{e_1}{e_2},\eta) \Downarrow \cl}$ \\[3mm]
  \RN{Unfold}     & $\regel{(e_1,\eta) \Downarrow (\bfix,\eta_1)
                            \quad (\app{e_2}{(\app{\bfix}{e_2})},\eta) \Downarrow \cl}
                           {(\app{e_1}{e_2},\eta) \Downarrow \cl}$
\end{tabular}
\end{definition}

\begin{lemma}[Wohldefiniertheit der De Bruijn-Umgebungssemantik]
  Seien $(e,\eta),(\hat{e},\hat{\eta})\in\dbCl$. Wenn $(e,\eta)$ wohldefiniert und
  $(e,\eta) \Downarrow (\hat{e},\hat{\eta})$, dann ist auch $(\hat{e},\hat{\eta})$
  wohldefiniert und es gilt $\hat{e}\in\dbVal$.
\end{lemma}

\begin{proof}
  Vermutlich triviale Induktion.
\end{proof}

Wie zuvor betrachten wir nun nur noch wohldefinierte De Bruijn-Closures und -Umgebungen, d.h. wir nehmen an,
$\dbCl$ und $\dbEnv$ enthalten nur noch wohldefinierte Elemente.

\begin{definition}[Namenskontext]
  Die Menge $\Ncx$ aller {\em Namenskontexte} $\Gamma$ ist induktiv definiert durch:
  \bgram
  \Gamma \is [\,] \mid \id;\Gamma
  \egram
  Der {\em Definitionsbereich} $\dom{\Gamma}$ eines Namenskontext $\Gamma$ ist wie folgt induktiv definiert:
  \[\begin{array}{rcl}
    \dom{[\,]} &=& \emptyset \\
    \dom{\id;\Gamma} &=& \{\id\} \cup \dom{\Gamma}
  \end{array}\]
\end{definition}

\noindent Schreibweisen
\begin{enumerate}
\item F\"ur $\Gamma=(\id_1;\ldots;\id_n;[\,])\in\Ncx$ schreiben wir $[\id_1;\ldots;\id_n]$.
\item F\"ur $\Gamma=[\id_1;\ldots;\id_n]$ und $\id\in\dom{\Gamma}$ sei
  \[ \Gamma(\id) = \min\{j \in \{1,\ldots,n\}\,|\, \id_j = \id\} \]
\end{enumerate}

\begin{definition}[\"Ubersetzungsfunktion]
  Gegeben $e \in Exp$, $\Gamma\in\Ncx$ mit $\free{e} \subseteq \dom{\Gamma}$. Der {\em De Bruijn-Ausdruck}
  $\tr{\Gamma,e}$, welcher durch Entfernen der Bezeichner aus $e$ entsteht, ist wie folgt induktiv definiert:
  \[\begin{array}{rcl}
    \tr{\Gamma,c} &=& c \\
    \tr{\Gamma,\id} &=& \underline{i} \quad \text{ falls } i = \Gamma(\id) \\
    \tr{\Gamma,\abstr{\id}{e}} &=& \abstr{}{\tr{\id;\Gamma,e}} \\
    \tr{\Gamma,\app{e_1}{e_2}} &=& \app{(\tr{\Gamma,e_1})}{(\tr{\Gamma,e_2})} \\
    \tr{\Gamma,\bifte{e_0}{e_1}{e_2}} &=& \bifte{\tr{\Gamma,e_0}}{\tr{\Gamma,e_1}}{\tr{\Gamma,e_2}}
  \end{array}\]
  Sei weiter $\eta=[\id_1:\cl_1;\ldots;\id_n:\cl_n]\in\Env$ mit $\free{e}\subseteq \dom{\eta}$. Die
  {\em De Bruijn-Closure} $\tr{e,\eta}$, welche durch Entfernen der Bezeichner aus $e$ und $\eta$ entsteht,
  ist wie folgt induktiv definiert:
  \[\begin{array}{rcl}
    \tr{e,\eta} &=& (\tr{[\id_1;\ldots;\id_n],e},[\tr{\cl_1};\ldots;\tr{\cl_n}])
  \end{array}\]
\end{definition}

\begin{lemma}[Wohldefiniertheit der \"Ubersetzung] \
  \begin{enumerate}
  \item Seien $e \in \Exp$ und $\Gamma\in\Ncx$ mit $\free{e}\subseteq \dom{\Gamma}$, \\
    dann gilt $(\tr{\Gamma,e})\in\dbExp$.
  \item Sei $\cl\in\Cl$. Dann gilt $(\tr{\cl})\in\dbCl$.
  \end{enumerate}
\end{lemma}

\begin{proof}
  Straight forward induction.
\end{proof}

\begin{lemma}
  Die \"Ubersetzungsfunktion $\name{tr}$ ist {\em strukturerhaltend}.
\end{lemma}

Insbesondere gilt $(\tr{\Gamma,v})\in\dbVal$ f\"ur alle $v\in\Val$ und $\Gamma\in\Ncx$ mit
$\free{v}\subseteq\dom{\Gamma}$.

\begin{proof}
  Klar.
\end{proof}

\begin{theorem}[\"Aquivalenzsatz]
  Sei $(e,\eta),(e',\eta')\in\Cl$. Dann gilt $(e,\eta) \Downarrow (e',\eta')$ gdw.
  $\tr{e,\eta} \Downarrow \tr{e',\eta'}$.
\end{theorem}

\begin{proof}
  Es sind zwei Richtungen zu zeigen, jeweils per Induktion \"uber die L\"ange der Herleitung des big steps mit
  Fallunterscheidung nach der zuletzt angewandten Regel. Dabei muss man sowohl die {\em Strukturerhaltung} der
  \"Ubersetzung als auch die Tatsache ausnutzen, dass die Closures wohldefiniert sind.
\end{proof}


\section{Codegenerierung}

F\"ur die im vorangegangenen Abschnitt beschriebene Programmiersprache soll Maschinencode erzeugt werden. Die
Zielmaschine ist eine abgewandelte Version der {\em CAM (Categorical Abstract Machine)}, welche in {\em ``The
Categorical Abstrach Machine: Basics and Enhancements''} von Ralf Hinze beschrieben wird.


\subsection{Categorical Abstract Machine}

Wir definieren eine abstrakte Maschine in die die Ausdr\"ucke der funktionalen Programmiersprache \"ubersetzt
werden. Wir nennen die hier beschriebene Maschine {\em LazyCAM}, da es sich um die Zielmaschine f\"ur eine
Programmiersprache mit {\em lazy evaluation Semantik} handelt.

\begin{definition}[Syntax der Categorical Abstract Machine]
  Vorgegeben sei eine Menge $\Loc = \setN$ von {\em Programmaddressen} $\ell$. Die Mengen $\Prog$ aller
  {\em (CAM-)Programme} $P$, $\Instr$ aller {\em (CAM-)Instruktionen} $I$, $\Reg$ aller
  {\em (CAM-)Registerinhalte} $R$ und $\Stack$ aller {\em (CAM-)Stackinhalte} $S$ sind wie folgt induktiv
  definiert:
  \bgram
  P \is I \mid P_1;P_2 \\
  I \is \textsc{Fst} \mid \textsc{Snd} \mid \textsc{Push} \mid \textsc{Swap}
  \mid \textsc{Quote}\,c \mid \textsc{Prim}\,\op
  \al \textsc{Closure}\,\ell \mid \textsc{App} \mid \textsc{Eval} \mid \textsc{Return}
  \al \textsc{GotoFalse}\,\ell \mid \textsc{Goto}\,\ell \mid \textsc{Stop} \\
  R \is c \mid \ell \mid \underbrace{(R_1,R_2)}_{\text{Umgebung}} \mid \underbrace{[R:\ell]}_{\text{Closure}} \\
  S \is [\,] \mid R;S
  \egram
  Die L\"ange $|P| \in \setN$ eines Programms $P$ ist induktiv definiert durch:
  \[\begin{array}{rcl}
    |I| &=& 1 \\
    |P_1;P_2| &=& |P_1| + |P_2|
  \end{array}\]
\end{definition}

Jede Instruktion $I$ eines Programms $P$ besitzt eine eindeutige Programmaddresse $\ell$, identifiziert durch die
Position an der $I$ in $P$ steht, beginnend bei $0$. Die Menge $\dom{P}\subseteq\Loc$ aller g\"ultigen Addressen
eines Programms $P$ ist definiert durch:
\[\begin{array}{rcl}
  \dom{P} &=& \{\ell\in\Loc\,|\,0\le\ell \wedge \ell < |P|\}
\end{array}\]
Wir schreiben $P[\ell]$ f\"ur die Instruktion $I$ an der Programmaddresse $\ell\in\dom{P}$ im Programm $P$.
Weiterhin schreiben wir $\ell:I$ f\"ur die Programmaddresse $\ell\in\dom{P}$ mit $P[\ell]=I$.

\begin{definition}
  Die Menge $\locns{I,\ell}\subseteq\Loc$ aller relativ zu $\ell$ in $I$ vorkommenden Sprungziele (implizit oder
  explizit) ist wie folgt definiert:
  \[\begin{array}{rcl}
    \locns{\textsc{Closure}\,\ell',\ell} &=& \{\ell',\ell+1\} \\
    \locns{\textsc{Return},\ell} &=& \emptyset \\
    \locns{\textsc{Goto}\,\ell',\ell} &=& \{\ell'\} \\
    \locns{\textsc{GotoFalse}\,\ell',\ell} &=& \{\ell',\ell+1\} \\
    \locns{\textsc{Stop},\ell} &=& \emptyset \\
    \locns{I,\ell} &=& \{\ell+1\} \quad \text{f\"ur alle \"ubrigen $I$}
  \end{array}\]
  Die Menge $\locns{P,\ell}\subseteq\Loc$ aller relativ zu $\ell$ in $P$ vorkommenden Sprungziele (implizit oder
  explizit) ist induktiv definiert durch:
  \[\begin{array}{rcl}
    \locns{I,\ell} &=& \locns{I,\ell} \\
    \locns{P_1;P_2,\ell} &=& \locns{P_1,\ell} \cup \locns{P_2,\ell+|P_1|}
  \end{array}\]
  Statt $\locns{P,0}$ schreiben wir kurz $\locns{P}$.
  Ein Programm $P\in\Prog$ hei"st {\em g\"ultig}, wenn $\locns{P} \subseteq \dom{P}$.
\end{definition}

Intuitiv sollte sofort ersichtlich sein, dass ein g\"ultiges Programm immer entweder mit $\textsc{Stop}$,
$\textsc{Return}$ oder $\textsc{Goto}$ enden muss, da in der Sprungmenge sonst die Nachfolgeaddresse des
letzten Befehls enthalten w\"are, die aber nicht mehr zum Programm geh\"ort. Obige Definition ist schon
teilweise ein Vorgriff auf die Semantik der Maschine.

\begin{definition}
  Die Menge $\locns{R} \subseteq \Loc$ aller im Register $R$ vorkommenden Sprungziele ist wie folgt induktiv
  definiert:
  \[\begin{array}{rcl}
    \locns{c} &=& \emptyset \\
    \locns{\ell} &=& \{\ell\} \\
    \locns{(R_1,R_2)} &=& \locns{R_1} \cup \locns{R_2} \\
    \locns{[R:\ell]} &=& \locns{R} \cup \{\ell\}
  \end{array}\]
  Analog ist die Menge $\locns{S} \subseteq \Loc$ aller auf dem Stack $S$ vorkommenden Sprungziele definiert:
  \[\begin{array}{rcl}
    \locns{[\,]} &=& \emptyset \\
    \locns{R;S} &=& \locns{R} \cup \locns{S}
  \end{array}\]
\end{definition}

Die Semantik der CAM und damit die Bedeutung der einzelnen Instruktionen wird nachfolgend beschrieben.

\begin{definition}[Semantik der Categorical Abstract Machine]
  Sei $P\in\Prog$ ein g\"ultiges Programm. Ein {\em g\"ultiger (CAM-)Programmzustand} f\"ur $P$ ist ein Tripel der Form
  $(R,S,\ell) \in \Reg \times \Stack \times \Loc$, mit
  \[
  \locns{R}\cup\locns{S}\cup\{\ell\}\subseteq\dom{P}.
  \]
  Die Menge aller g\"ultigen Programmzust\"ande f\"ur $P$ bezeichnen wir mit $\State(P)$, oder kurz $\State$,
  wenn $P$ aus dem Kontext hervorgeht. Die \"Ubergangsrelation $\to$ der CAM ist in 
  Tabelle~\ref{table:CAM_Reductions} beschrieben.
\end{definition}

\begin{figure}
  {\footnotesize
  \begin{center}
    \begin{tabular}{|rcl|l|}
      \hline
      Zustand \hfill \quad && Nachfolger & Beschreibung \\
      \hline
      $((R_1,R_2),S,\ell:\textsc{Fst})$ & $\to$ & $(R_1,S,\ell+1)$ & Erste Projektion \\
      $((R_1,R_2),S,\ell:\textsc{Snd})$ & $\to$ & $(R_2,S,\ell+1)$ & Zweite Projektion \\
      \hline
      $(R,S,\ell:\textsc{Push})$ & $\to$ & $(R,R;S,\ell+1)$ & Registerinhalt auf Stack \\
      $(R_1,R_2;S,\ell:\textsc{Swap})$ & $\to$ & $(R_2,R_1;S,\ell+1)$ & Registerinhalt und oberstes \\
      &&& Stackelement vertauschen \\
      \hline
      $(R,S,\ell:\textsc{Quote}\,c)$ & $\to$ & $(c,S,\ell+1)$ & $c$ in Register laden \\
      $(z_2,z_1;S,\ell:\textsc{Prim}\,\op)$ & $\to$ & $(\op^I(z_1,z_2),S,\ell+1)$ & Operation $\op$ ausf\"uhren \\
      $(R,S,\ell:\textsc{Closure}\,\ell')$ & $\to$ & $([R:\ell'],S,\ell+1)$ & Abschluss bilden \\
      \hline
      $([R_1:\ell'],R_2;S,\ell:\textsc{App})$ & $\to$ & $((R_1,R_2),\ell+1;S,\ell')$ & Funktionsaufruf \\
      $([R:\ell'],S,\ell:\textsc{Eval})$ & $\to$ & $(R,\ell+1;S,\ell')$ & Verz\"ogerte Auswertung \\
      &&& einer Closure \\
      $(R,\ell';S,\ell:\textsc{Return})$ & $\to$ & $(R,S,\ell')$ & R\"ucksprung aus Closure \\
      $(\true,R;S,\ell:\textsc{GotoFalse}\,\ell')$ & $\to$ & $(R,S,\ell+1)$ & Sprung zu $\ell'$ wenn Register \\
      $(\false,R;S,\ell:\textsc{GotoFalse}\,\ell')$ & $\to$ & $(R,S,\ell')$ & den Wert $\false$ enth\"alt \\
      $(R,S,\ell:\textsc{Goto}\,\ell')$ & $\to$ & $(R,S,\ell')$ & Unbedingter Sprung zu $\ell'$ \\
      \hline
    \end{tabular}
  \end{center}}
  \caption{\"Ubergangsrelation}
  \label{table:CAM_Reductions}
\end{figure}

\begin{lemma}[Wohldefiniertheit der \"Ubergangsrelation]
  Sei $P$ ein g\"ultiges Programm. Wenn $(R,S,\ell)\in\State(P)$ und $(R,S,\ell) \to (R',S',\ell')$, dann
  gilt auch $(R',S',\ell')\in\State(P)$.
\end{lemma}

\begin{proof}
  Sollte sich per Fallunterscheidung recht einfach zeigen lassen, wobei man immer wieder auf die Annahme zur\"uckkommen
  muss, dass der Anfangszustand schon g\"ultig ist, und man muss beachten, dass alle m\"oglichen Folgeaddressen
  im Programm enthalten sind, da $P$ nach Voraussetzung g\"ultig ist.
\end{proof}

\begin{lemma}[Eindeutigkeit der \"Ubergangsrelation]
  Sei $P$ ein g\"ultiges Programm. F\"ur jeden Zustand $s\in\State(P)$ existiert h\"ochstens ein $s'\in\State(P)$, so
  dass $s \to s'$.
\end{lemma}

\begin{definition}[Berechnung]
  Sei $P$ ein g\"ultiges Programm. Eine {\em Berechnung} f\"ur $P$ ist eine (m\"oglicherweise unendliche) Folge von
  Zust\"anden
  \[
  (R_0,S_0,0) \to (R_1,S_1,\ell_1) \to (R_2,S_2,\ell_2) \to \ldots
  \]
  Eine Berechnung hei"st
  \begin{enumerate}
    \item {\em terminierend}, wenn sie endlich ist und der letzte Zustand die Form
      $(R_e,S_e,\ell_e:\textsc{Stop})$ hat, oder
    \item {\em divergierend}, wenn sie unendlich ist, oder
    \item {\em stecken bleibend}, sonst.
  \end{enumerate}
\end{definition}


\subsection{Erzeugung von Zielcode}

Zun\"achst \"andern wir die Programmiersprache geringf\"ugig, um die \"Ubersetzung einfacher zu gestalten. Und
zwar entfernen wir die Operatoren aus der Menge der Konstanten, und nehmen stattdessen einen Ausdruck der
Form $e_1\,\op\,e_2$ zur Kernsyntax hinzu, mit folgender Semantik: \\[5mm]
\begin{tabular}{ll}
  \RN{Op} & $\regel{(e_1,\eta) \Downarrow (z_1,\eta_1) \quad (e_2,\eta) \Downarrow (z_2,\eta_2)
                    \quad \op^I(z_1,z_2)=c}
                   {(e_1\,\op\,e_2,\eta) \Downarrow (c,[])}$
\end{tabular} \\[5mm]
Weiterhin entfernen wir den Fixpunktoperator und die \RN{Unfold}-Regel. Stattdessen nehmen wir folgende
Konstrukte als syntaktischen Zucker auf:
\[\begin{array}{rcl}
  (\op) &=_{def}& \abstr{}{\abstr{}{\underline{2}\,\op\,\underline{1}}} \\
  \bfix &=_{def}& \abstr{}{\app{(\abstr{}{\app{\underline{2}}{(\app{\underline{1}}{\underline{1}})}})}
                              {(\abstr{}{\app{\underline{2}}{(\app{\underline{1}}{\underline{1}})}})}}
\end{array}\]
Letztere \"Ubersetzung entspricht dem vom Haskell Curry entdeckten Fixpunkt-Kombinator f\"ur call-by-name:
\[\begin{array}{rcl}
  Y &=_{def}& \abstr{f}{\app{(\abstr{x}{\app{f}}{(\app{x}{x})})}{(\abstr{x}{\app{f}}{(\app{x}{x})})}}
\end{array}\]
Es ist nun basierend auf der big step Semantik zu zeigen, dass diese \"Ubersetzungen korrekt sind, bzgl. der
zuvor benutzten Semantik.

Die {\em LazyCAM}-Codegenerierung f\"ur einen Ausdruck $e\in\Exp$ wird durch die folgenden drei Funktionen erledigt:
\begin{enumerate}
\item $\mathcal{P}\sem{e}$ erzeugt das Programm f\"ur $e$, d.h. den Code zur Berechnung des Wertes von $e$ und
  den abschliessenden $\textsc{Stop}$-Befehl.
\item $\mathcal{C}\sem{e}\ell$ erzeugt Code, beginnend ab Programmaddresse $\ell$, welcher erwartet, dass $R$ die
  Umgebung enth\"alt, in der $e$ ausgewertet werden soll, und am Ende eine Closure (mit der zuvor in $R$ befindlichen
  Umgebung) f\"ur $e$ in $R$ ablegt.
\item $\mathcal{V}\sem{e}\ell$ erzeugt Code, beginnend ab Programmaddresse $\ell$, welcher erwartet, dass $R$ die
  Umgebung enth\"alt, in der $e$ ausgewertet werden soll, und am Ende den Wert von $e$ in $R$ ablegt.
\end{enumerate}
Diese Funktionen sind wie folgt induktiv definiert:
\[\begin{array}{rcl}
  \mathcal{P}\sem{e}
  &=& \mathcal{V}\sem{e}0;\,\textsc{Stop} \\
  \\
  \mathcal{C}\sem{e}\ell
  &=& \textsc{Goto}\,\ell';\,P;\,\textsc{Return};\,\textsc{Closure}\,(\ell+1) \\
  && \footnotesize{\text{mit $P = \mathcal{V}\sem{e}(\ell+1), \ell' = \ell + |P| + 2$}} \\
  \\
  \mathcal{V}\sem{c}\ell
  &=& \textsc{Quote}\,c \\

  \mathcal{V}\sem{\underline{i}}\ell
  &=& \underbrace{\textsc{Fst};\ldots;\,\textsc{Fst}}_{\text{$(i-1)$-mal}};\,\textsc{Snd};\,\textsc{Eval} \\

  \mathcal{V}\sem{\abstr{}{e}}\ell
  &=& \mathcal{C}\sem{e}\ell \\

  \mathcal{V}\sem{\app{e_1}{e_2}}\ell
  &=& \textsc{Push};\,P_1;\,\textsc{Swap};\,P_2;\,\textsc{Swap};\,\textsc{App} \\
  && {\footnotesize \text{mit $P_1=\mathcal{V}\sem{e_1}(\ell+1),P_2=\mathcal{C}\sem{e_2}(\ell+|P_1|+2)$}} \\

  \mathcal{V}\sem{e_1\,\op\,e_2}\ell
  &=& \textsc{Push};\,P_1;\,\textsc{Swap};\,P_2;\,\textsc{Prim}\,\op \\
  && {\footnotesize \text{mit $P_1=\mathcal{V}\sem{e_1}(\ell+1),P_2=\mathcal{V}\sem{e_2}(\ell+|P_1|+2)$}} \\

  \mathcal{V}\sem{\bifte{e_0}{e_1}{e_2}}\ell
  &=& \textsc{Push};\,P_0;\,\textsc{GotoFalse}\,\ell';\,P_1;\,\textsc{Goto}\,\ell'';\,P_2 \\
  && {\footnotesize \text{mit $P_0=\mathcal{V}\sem{e_0}(\ell+1),P_1=\mathcal{V}\sem{e_1}(\ell+|P_0|+2),$}} \\
  && {\footnotesize \text{$P_2=\mathcal{V}\sem{e_2}\ell',\ell'=\ell+|P_0|+|P_1|+3,\ell''=\ell'+|P_2|$}}
\end{array}\]

\begin{lemma}[Wohldefiniertheit der \"Ubersetzungsfunktion]
  Sei $e\in\Exp$. Dann ist $\mathcal{P}\sem{e}$ ein g\"ultiges Programm.
\end{lemma}

\begin{proof}
  Hier m\"usste man dann erstmal die Sache passend formulieren f\"ur $\mathcal{C}$ und $\mathcal{V}$. Dann
  sollte die Sache anschliessend einfach sein.
\end{proof}

Diese \"Ubersetzung ist herzlich ineffizient, denn z.B. werden f\"ur $\lambda$-Ausdr\"ucke Parameter-Position
zwei Closures erzeugt, oder f\"ur einfache Konstanten wird auf Parameter-Position ebenfalls immer eine Closure
erzeugt, obwohl dies nicht notwendig w\"are. Noch sinnloser sind die De Bruijn-Indizes, hier wird dann eine
Closure erzeugt, die die Closure aus der Umgebung holt und auswertet. Letzteres liesse sich durch geschicke
\"Anderung der \"Ubersetzungsfunktionen regeln. Das allgemeine Problem unn\"otiger Closures k\"onnte man dadurch
l\"osen, dass man zwischen Closure und Funktionswert unterscheidet und entsprechend die \textsc{Eval}-Instruktion
ab\"andert, wie dies im Willhelm/Maurer gemacht wird (allerdings dann ohne Call-by-need).

Zun\"achst sollte man aber diese sehr naive \"Ubersetzung nehmen und beweisen, dass die semantikerhaltend ist. Dazu
muss man zun\"achst geeignete Invarianten (wie sie oben schon angedeutet sind) bestimmen. Daraus sollte man dann
auf eine beweisbare Form kommen. Intuitiv muss folgendes gezeigt werden:
\begin{quote}
  Wenn $(e,[\,]) \Downarrow (v,\eta)$, dann existiert f\"ur $P=\mathcal{P}\sem{e}$ eine terminierende Berechnung
  $(R_0,S_0,0) \xrightarrow* (R,S,\ell:\textsc{Stop})$, so dass $R$ zu $(v\,\eta)$ {\em passt}. Und
  man m\"usste leicht zeigen k\"onnen, dass die Wahl von $R_0$ und $S_0$ egal ist wenn $e$ abgeschlossen ist
  (genaugenommen braucht man irgendwie ein Lemma, welches $R_0$ und $S_0$ mit der initialen Umgebung in Verbindung
  bringt, um die
  Korrektheit induktiv zu zeigen; dann ist die Invarianz unter der Wahl von $R_0$/$S_0$ eine triviale Folgerung).
\end{quote}


\end{document}

% vi:set ts=2 sw=2 et:
