\documentclass[12pt,a4paper]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{array}
\usepackage[american]{babel}
\usepackage{color}
\usepackage{enumerate}
\usepackage[a4paper,%
            colorlinks=false,%
            final,%
            pdfkeywords={},%
            pdftitle={},%
            pdfauthor={Benedikt Meurer},%
            pdfsubject={},%
            pdfdisplaydoctitle=true]{hyperref}
\usepackage[latin1]{inputenc}
\usepackage{latexsym}
\usepackage[final]{listings}
\usepackage{makeidx}
\usepackage[standard,thmmarks]{ntheorem}
\usepackage{stmaryrd}
\usepackage{url}
\usepackage[arrow, matrix, curve]{xy}

%% LaTeX macros
\include{macros}

% TODO
\newcommand{\CAssn}{\sstyle{CAssn}}
\newcommand{\CTerm}{\sstyle{CTerm}}
\newcommand{\CExp}{\sstyle{CExp}}
\newcommand{\CVal}{\sstyle{CVal}}
\newcommand{\Conf}{\sstyle{Conf}}
\newcommand{\Con}{\sstyle{Con}}
\newcommand{\Sto}{\sstyle{Sto}}
\newcommand{\TType}{\sstyle{TType}}
\newcommand{\scon}{\nstyle{con}}
\newcommand{\sexp}{\nstyle{exp}}
\newcommand{\ssto}{\nstyle{sto}}
\newcommand{\senv}{\nstyle{env}}
\newcommand{\z}{\nstyle{int}}
\newcommand{\DEF}{\sstyle{DEF}}
\newcommand{\id}{\nstyle{id}}
\newcommand{\I}{\mathcal{I}}
\newcommand{\Fix}[1]{\nstyle{Fix}\,(#1)}
\newcommand{\returns}[2]{\ensuremath{\mathbf{returns}\,{#1}.\,{#2}}}

\newcommand{\AUX}{\nstyle{AUX}}
\newcommand{\Neg}{\nstyle{Neg}}
\newcommand{\Or}{\nstyle{Or}}
\newcommand{\Cont}{\nstyle{Cont}}
\newcommand{\Disj}{\nstyle{Disj}}
\newcommand{\Exists}{\nstyle{Exists}}

\newcommand{\emp}{\ensuremath{\mathbf{emp}}}


\begin{document}

\section{The programming language}

We assume that disjoint infinite sets of variables $x \in \Var$ and locations $\ell \in \Loc$ are given,
where variables are used to abstract expressions and locations are used to address memory cells.
Expressions are considered equal modulo renaming of bound variables. $\Bool=\{\true,\false\}$ is
the set of boolean constants $b$, $\Int$ is the set of integer constants $z$. We do not distinguish
between integer values their program representation.

\begin{definition}[Expressions]
  The set $\Op$ of {\em operators} $\op$ and the set $\Const$ of {\em constants} $c$ are defined by
  the grammars
  \[\GRbeg
  \op \GRis + \GRmid - \GRmid * \GRmid = \GRmid < \GRmid > \GRmid \le \GRmid \ge \\
  c \GRis z \GRmid b \GRmid \unit \GRmid \cref \GRmid ! \GRmid \assign \GRmid \fix \GRmid \op \GRmid \fst \GRmid \snd,
  \GRend\]
  the set $\Exp$ of {\em expressions} $e$ is defined by
  \[\GRbeg
  e \GRis c \GRmid x \GRmid \ell \GRmid \abstr{x}{e} \GRmid \app{e_1}{e_2}
  \GRmid \ifte{e_0}{e_1}{e_2} \GRmid (e_1,e_2)
  \GRend\]
  and the set $\Val \subseteq \Exp$ of {\em values} $v$ is defined by
  \[\GRbeg
  v \GRis c \GRmid \ell \GRmid \abstr{x}{e} \GRmid \app{\op}{v} \GRmid \app{\assign}{v} \GRmid (v_1,v_2).
  \GRend\]
\end{definition}

$\free{e}$ denotes the set of free variables and $\locns{e}$ denotes the set of locations in the expression $e$.
We say that $e$ is {\em closed} if $\free{e}=\emptyset$. $e$ is called a {\em program} if
$\free{e}\cup\locns{e}=\emptyset$, that is, if $e$ contains neither unbound variables nor locations (i.e.
memory addresses in terms of the underlying machine). We demand that all expressions considered for the
logic later are valid programs (i.e. programmers aren't permitted to access arbitrary memory locations).


\subsection{Operational semantics}

Let $(W,\subseteq) = (\powersetfin{\Loc},\subseteq)$ be a partial order of ``possible worlds''.

\begin{definition}[Store] \
  \begin{enumerate}
  \item A {\em store} is a finite partial mapping $s:\Loc \pto \CVal$. $\Store$ denotes the set of all
    such stores.
  \item For every $L \in W$ a subset $\Store_L = \{s\in\Store\,|\,L\subseteq\dom{s}\}$ is defined.
  \end{enumerate}
\end{definition}

A {\em configuration} is a pair $(e,s)$. $\Conf$ denotes the set of all configurations.

\begin{figure}[ht]
  \centering
  \begin{tabular}{rl}
    \RN{App-Left} & $\RULE{(e_1,s) \to (e_1',s')}{(\app{e_1}{e_2},s)\to(\app{e_1'}{e_2},s')}$ \\[3mm]
    \RN{App-Right} & $\RULE{(e,s) \to (e',s')}{(\app{v}{e},s)\to(\app{v}{e'},s')}$ \\[3mm]
    \RN{Op} & $(\app{\app{\op}{z_1}}{z_2},s) \to (\op^I(z_1,z_2),s)$ \\[1mm]
    \RN{Beta-V} & $(\app{(\abstr{x}{e})}{v},s) \to (e[v/x],s)$ \\[1mm]
    \RN{Unfold} & $(\app{\fix}{(\abstr{x}{e})},s) \to (e[\app{\fix}{(\abstr{x}{e})}/x],s)$ \\[1mm]
    \RN{Fst} & $(\app{\fst}{(v_1,v_2)},s) \to (v_1,s)$ \\[1mm]
    \RN{Snd} & $(\app{\snd}{(v_1,v_2)},s) \to (v_2,s)$ \\[1mm]
    \RN{Deref} & $\RULE{s(\ell) = v}{(\app{!}{\ell},s) \to (v,s)}$ \\[3mm]
    \RN{Assign} & $\RULE{\ell\in\dom{s}}{(\app{\app{\assign}{\ell}}{v},s) \to (\unit,s[v/\ell])}$ \\[3mm]
    \RN{Ref} & $\RULE{\ell \not\in \dom{s}}{(\app{\cref}{v},s) \to (\ell,s[v/\ell])}$ \\[3mm]
    \RN{Cond-Eval} & $\RULE{(e_0,s) \to (e_0',s')}{(\ifte{e_0}{e_1}{e_2},s)\to(\ifte{e_0'}{e_1}{e_2},s')}$ \\[3mm]
    \RN{Cond-True} & $(\ifte{\true}{e_1}{e_2},s) \to (e_1,s)$ \\[1mm]
    \RN{Cond-False} & $(\ifte{\false}{e_1}{e_2},s) \to (e_2,s)$ \\[1mm]
    \RN{Pair-Left} & $\RULE{(e_1,s)\to(e_1',s')}{((e_1,e_2),s) \to ((e_1',e_2),s')}$ \\[3mm]
    \RN{Pair-Right} & $\RULE{(e,s)\to(e',s')}{((v,e),s) \to ((v,e'),s')}$
  \end{tabular}
  \caption{Small step rules}
  \label{fig:Small_step_rules}
\end{figure}

\begin{definition}[Small step relation]
  The {\em small step relation}, written $k \to k'$, is the smallest binary relation between configurations
  satisfying all instances of the rules in figure~\ref{fig:Small_step_rules}.
\end{definition}

Obviously the small step relation is well-defined. Let's say we have $(e,s)\to(e',s')$. Then
\begin{itemize}
\item if $(e,s)\in\Conf$ then $(e',s')\in\Conf$, and
\item if $\free{e'} \subseteq \free{e}$.
\end{itemize}


\section{Assertions}

\begin{definition}[Assertions]
  Let $\mathcal{F}$ be some predefined set of {\em function symbols} $f$.
  The sets $\Term$ of {\em terms} $t$ and $\Assn$ of {\em assertions} $p$ are defined by the following grammar:
  \[\GRbeg
  t \GRis v \GRmid x \GRmid f\,(t_1,\ldots,t_n)
  \\
  p \GRis t_1 = t_2 \GRmid \neg p \GRmid p_1 \wedge p_2 \GRmid \exists x.\,p
  \GRal \emp \GRmid t_1 \mapsto t_2 \GRmid p_1 \sepcon p_2 \GRmid p_1 \sepimp p_2
  \GRend\]
\end{definition}


\subsection{Meaning of assertions}

Let $D = \bigcup_{L\in W} D_L$ with $D_L = \{v\in\CVal\,|\,\locns{v} \subseteq L\}$.
For each $n$-ary function symbol $f\in\mathcal{F}$ let
$\semantic{f}: D^n \to D$ be the interpretation of $f$ satisfying
\[
\semantic{f}(D_{L_1},\ldots,D_{L_n}) \subseteq D_{L_1 \cup \ldots \cup L_n}.
\]
An {\em environment} is a partial finite mapping $\eta:\Var \pto D$.

\begin{definition}[Meaning of terms]
  Let $t$ be a term and $\eta$ a suitable environment with $\free{t} \subseteq \dom{\eta}$.
  The {\em meaning of $t$} wrt. $\eta$, written $\semantic{t}\,\eta$, is defined by:
  \[\begin{array}{rcl}
    \semantic{v}\,\eta
    &=& v\,\eta \\
    \semantic{x}\,\eta
    &=& \eta(x) \\
    \semantic{f\,(t_1,\ldots,t_n)}\,\eta
    &=& \semantic{f}(\semantic{t_1}\,\eta,\ldots,\semantic{t_n}\,\eta)
  \end{array}\]
\end{definition}

\begin{lemma}
  $\free{t} \subseteq \dom{\eta} \ \Rightarrow\  (\semantic{t}\,\eta)\in D$
\end{lemma}

\begin{definition}[Meaning of assertions]
  The {\em satisfaction relation}, written $\eta,s \models p$, is the smallest relation between 
  environments, stores and assertions, satisfying $\free{p} \subseteq \dom{\eta}$ and all of the
  following properties:
  \[\begin{array}{rcl}
    \eta,s \models t_1 = t_2
    &\text{iff}& \semantic{t_1}\,\eta = \semantic{t_2}\,\eta \\
    \eta,s \models \neg p
    &\text{iff}& \eta,s \not\models p \\
    \eta,s \models p_1 \wedge p_2
    &\text{iff}& \eta,s \models p_1 \text{ and } \eta,s \models p_2 \\
    \eta,s \models \exists x.\,p
    &\text{iff}& \exists d \in D.\,\eta[d/x],s \models p \\
    \eta,s \models \emp
    &\text{iff}& \grph{s} = \emptyset \\
    \eta,s \models t_1 \mapsto t_2
    &\text{iff}& \grph{s} = \{(\semantic{t_1}\,\eta,\semantic{t_2}\,\eta)\} \\
    \eta,s \models p_1 \sepcon p_2
    &\text{iff}& \exists s_1,s_2.\,s=s_1 \oplus s_2 \text{ and } \eta,s_1 \models p_1 \\
    && \text{and } \eta,s_2 \models p_2 \\
    \eta,s \models p_1 \sepimp p_2
    &\text{iff}& \forall s_1,s_2.\,(s_2 = s \oplus s_1 \text{ and } \eta,s_1 \models p_1) \\
    && \text{implies } \eta,s_2 \models p_2
  \end{array}\]
\end{definition}


\section{Hoare triples}

\noindent Given $\free{p}\cup\free{e}\cup\free{q} \subseteq \dom{\eta}$:
\[\begin{array}{rcl}
  \eta \models \triple{p}{e_{:x}}{q}
  &\text{iff}&
  \text{for all $s\in\Store$ with $\eta,s \models p$, all} \\
  && \text{computations for $(e,s)$ terminate with} \\
  && \text{some $(v',s')$ such that $\eta[v'/x],s' \models q$}
\end{array}\]


\subsection{Inference rules}

\begin{tabular}{rl}
  \RN{Val} & $\triple{\emp}{x_{:y}}{y = x \wedge \emp}$ \\[1mm]
  \RN{App} & $\RULE{\triple{p}{{e_1}_{:x}}{p'} \quad \triple{p'}{{e_2}_{:y}}{q'} \quad \triple{q'}{{\app{x}{y}}_{:z}}{q}}{\triple{p}{{\app{e_1}{e_2}}_{:z}}{q}}$ \\[3mm]
  \RN{Op} & $\triple{\emp}{\app{\app{\op}{x}}{y}_{:z}}{z = f_{\op}(x,y) \wedge \emp}$ \\[1mm]
  \RN{Beta-V} & $\RULE{\triple{p}{e_{:y}}{q}}{\triple{p}{{\app{(\abstr{x}{e})}{x}}_{:y}}{q}}$ \\[3mm]
  \RN{Unfold} & $\RULE{\triple{p}{{e[\app{\fix}{(\abstr{x}{e})}/x]}_{:y}}{q}}{\triple{p}{{\app{\fix}{(\abstr{x}{e})}}_{:y}}{q}}$ \\[3mm]
  \RN{Fst} & $\triple{\emp}{{\app{\fst}{(x,y)}}_{:z}}{z = x \wedge \emp}$ \\[1mm]
  \RN{Snd} & $\triple{\emp}{{\app{\snd}{(x,y)}}_{:z}}{z = y \wedge \emp}$ \\[1mm]
  \RN{Deref} & $\triple{x \mapsto y}{{!x}_{:z}}{z = y \wedge x \mapsto y}$ \\[1mm]
  \RN{Assign} & $\triple{x \mapsto \_}{{\app{\app{\assign}{x}}{y}}_{:u}}{u = \unit \wedge x \mapsto y}$ \\[1mm]
  \RN{Ref} & $\triple{\emp}{{\cref\,y}_{:x}}{x \mapsto y}$ \\[1mm]
  \RN{Cond-True} & $\RULE{\triple{p}{{e_0}_{:x}}{x = \true \wedge p'} \quad \triple{p'}{{e_1}_{:y}}{q}}{\triple{p}{{\ifte{e_0}{e_1}{e_2}}_{:y}}{q}}$ \\[3mm]
  \RN{Cond-False} & $\RULE{\triple{p}{{e_0}_{:x}}{x = \false \wedge p'} \quad \triple{p'}{{e_2}_{:y}}{q}}{\triple{p}{{\ifte{e_0}{e_1}{e_2}}_{:y}}{q}}$ \\[3mm]
  \RN{Pair} & $\RULE{\triple{p}{{e_1}_{:x}}{p'} \quad \triple{p'}{{e_2}_{:y}}{q'} \quad \triple{q'}{{(x,y)}_{:z}}{q}}{\triple{p}{{(e_1,e_2)}_{:z}}{q}}$ \\[3mm]
\end{tabular}

\subsubsection{Structural rules}

\begin{tabular}{rl}
  \RN{Consequence} & $\RULE{p' \Rightarrow p \quad \triple{p}{e_{:x}}{q} \quad q \Rightarrow q'}{\triple{p'}{e_{:x}}{q'}}$ \\[3mm]
  \RN{Aux-Var-Elimination} & $\RULE{\triple{p}{e_{:x}}{q}}{\triple{\exists y.\,p}{e_{:x}}{\exists y.\,q}}$ $\quad\text{where } y \not\in \free{e}$ \\[3mm]
  \RN{Substitution} & $\RULE{\triple{p}{e_{:x}}{q}}{(\triple{p}{e_{:x}}{q})[t/y]}$ $\quad\text{where } (e[t/y]) \in \Exp$ \\[3mm]
  \RN{Frame} & $\RULE{\triple{p}{{e}_{:x}}{q}}{\triple{p \sepcon r}{{e}_{:x}}{q \sepcon r}}$ $\quad\text{where } x \not\in\free{r}$ \\[3mm]
\end{tabular}


\end{document}
