\documentclass[12pt,a4paper]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{array}
\usepackage[american]{babel}
\usepackage{color}
\usepackage{enumerate}
\usepackage[a4paper,%
            colorlinks=false,%
            final,%
            pdfkeywords={},%
            pdftitle={},%
            pdfauthor={Benedikt Meurer},%
            pdfsubject={},%
            pdfdisplaydoctitle=true]{hyperref}
\usepackage[latin1]{inputenc}
\usepackage{latexsym}
\usepackage[final]{listings}
\usepackage{makeidx}
\usepackage[standard,thmmarks]{ntheorem}
\usepackage{stmaryrd}
\usepackage{url}
\usepackage[arrow, matrix, curve]{xy}

%% LaTeX macros
\include{macros}

% TODO
\newcommand{\CAssn}{\sstyle{CAssn}}
\newcommand{\CTerm}{\sstyle{CTerm}}
\newcommand{\CExp}{\sstyle{CExp}}
\newcommand{\CVal}{\sstyle{CVal}}
\newcommand{\Conf}{\sstyle{Conf}}
\newcommand{\Con}{\sstyle{Con}}
\newcommand{\Sto}{\sstyle{Sto}}
\newcommand{\scon}{\nstyle{con}}
\newcommand{\sexp}{\nstyle{exp}}
\newcommand{\ssto}{\nstyle{sto}}
\newcommand{\senv}{\nstyle{env}}
\newcommand{\z}{\nstyle{int}}
\newcommand{\DEF}{\sstyle{DEF}}
\newcommand{\id}{\nstyle{id}}
\newcommand{\I}{\mathcal{I}}
\newcommand{\Fix}[1]{\nstyle{Fix}\,(#1)}
\newcommand{\returns}[2]{\ensuremath{\mathbf{returns}\,{#1}.\,{#2}}}

\newcommand{\AUX}{\nstyle{AUX}}
\newcommand{\Neg}{\nstyle{Neg}}
\newcommand{\Or}{\nstyle{Or}}
\newcommand{\Cont}{\nstyle{Cont}}
\newcommand{\Disj}{\nstyle{Disj}}
\newcommand{\Exists}{\nstyle{Exists}}

\newcommand{\emp}{\ensuremath{\mathbf{emp}}}


\begin{document}

\section{The programming language}

We assume that disjoint infinite sets $\Var$ of variables $x$ and $\Loc$ of locations $\ell$ are given, where
variables are used to abstract expressions and locations are used to identify memory cells.
Expressions are considered equal modulo renaming of bound variables. $\Bool=\{\true,\false\}$ is
the set of boolean constants $b$, $\Int$ is the set of integer constants $z$. We do not distinguish
between integer values their program representation.

\begin{definition}[Expressions]
  The set $\Op$ of {\em operators} $\op$ and the set $\Const$ of {\em constants} $c$ are defined by
  the grammars
  \[\GRbeg
  \op \GRis + \GRmid - \GRmid * \GRmid = \GRmid < \GRmid > \GRmid \le \GRmid \ge \\
  c \GRis z \GRmid b \GRmid \unit \GRmid \cref \GRmid ! \GRmid \assign \GRmid \fix \GRmid \op \GRmid \fst \GRmid \snd,
  \GRend\]
  the set $\Exp$ of {\em expressions} $e$ is defined by
  \[\GRbeg
  e \GRis c \GRmid x \GRmid \ell \GRmid \abstr{x}{e} \GRmid \app{e_1}{e_2}
  \GRmid \ifte{e_0}{e_1}{e_2} \GRmid \pair{e_1}{e_2}
  \GRend\]
  and the set $\Val \subseteq \Exp$ of {\em values} $v$ is defined by
  \[\GRbeg
  v \GRis c \GRmid \ell \GRmid \abstr{x}{e} \GRmid \app{\op}{v} \GRmid \app{\assign}{v} \GRmid \pair{v_1}{v_2}
  \GRend\]
\end{definition}

$\free{e}$ denotes the set of free variables and $\locns{e}$ denotes the set of locations in the expression $e$.
We say that $e$ is {\em closed} if $\free{e}=\emptyset$. $e$ is called a {\em program} if
$\free{e}\cup\locns{e}=\emptyset$, that is, if $e$ contains neither unbound variables nor locations (i.e.
memory addresses in terms of the underlying machine). We demand that all expressions considered for the
logic later are valid programs (i.e. programmers aren't permitted to access arbitrary memory locations).


\subsection{Operational semantics}

Let $(W,\subseteq) = (\powersetfin{\Loc},\subseteq)$ be a partial order of ``possible worlds''.

\begin{definition}[Store]
  A {\em store} is a finite partial mapping $s:\Loc \pto \CVal$.
  $\Store$ denotes the set of all such stores.
\end{definition}

A {\em configuration} is a pair $(e,s)$.
$\Conf$ denotes the set of all configurations.

\begin{figure}[ht]
  \centering
  \begin{tabular}{rl}
    \RN{App-Left} & $\RULE{(e_1,s) \to (e_1',s')}{(\app{e_1}{e_2},s)\to(\app{e_1'}{e_2},s')}$ \\[3mm]
    \RN{App-Right} & $\RULE{(e,s) \to (e',s')}{(\app{v}{e},s)\to(\app{v}{e'},s')}$ \\[3mm]
    \RN{Op} & $(\app{\app{\op}{z_1}}{z_2},s) \to (\op^I(z_1,z_2),s)$ \\[1mm]
    \RN{Beta-V} & $(\app{(\abstr{x}{e})}{v},s) \to (e[v/x],s)$ \\[1mm]
    \RN{Unfold} & $(\app{\fix}{(\abstr{x}{e})},s) \to (e[\app{\fix}{(\abstr{x}{e})}/x],s)$ \\[1mm]
    \RN{Fst} & $(\app{\fst}{\pair{v_1}{v_2}},s) \to (v_1,s)$ \\[1mm]
    \RN{Snd} & $(\app{\snd}{\pair{v_1}{v_2}},s) \to (v_2,s)$ \\[1mm]
    \RN{Deref} & $\RULE{s(\ell) = v}{(\app{!}{\ell},s) \to (v,s)}$ \\[3mm]
    \RN{Assign} & $\RULE{\ell\in\dom{s}}{(\app{\app{\assign}{\ell}}{v},s) \to (\unit,s[v/\ell])}$ \\[3mm]
    \RN{Ref} & $\RULE{\ell \in \Loc \setminus \dom{s}}{(\app{\cref}{v},s) \to (\ell,s[v/\ell])}$ \\[3mm]
    \RN{Cond-Eval} & $\RULE{(e_0,s) \to (e_0',s')}{(\ifte{e_0}{e_1}{e_2},s)\to(\ifte{e_0'}{e_1}{e_2},s')}$ \\[3mm]
    \RN{Cond-True} & $(\ifte{\true}{e_1}{e_2},s) \to (e_1,s)$ \\[1mm]
    \RN{Cond-False} & $(\ifte{\false}{e_1}{e_2},s) \to (e_2,s)$ \\[1mm]
    \RN{Pair-Left} & $\RULE{(e_1,s) \to (e_1',s')}{(\pair{e_1}{e_2},s) \to (\pair{e_1'}{e_2},s')}$ \\[3mm]
    \RN{Pair-Right} & $\RULE{(e,s) \to (e',s')}{(\pair{v}{e},s) \to (\pair{v}{e'},s')}$
  \end{tabular}
  \caption{Small step rules}
  \label{fig:Small_step_rules}
\end{figure}

\begin{definition}[Small step relation]
  The {\em small step relation}, written $k \to k'$, is the smallest binary relation between configurations
  satisfying all instances of the rules in figure~\ref{fig:Small_step_rules}.
\end{definition}

Obviously the small step relation is well-defined. Let's say we have $(e,s)\to(e',s')$. Then
\begin{itemize}
%\item if $(e,s)\in\Conf$ then $(e',s')\in\Conf$, and
\item if $\locns{e} \subseteq \dom{s}$ then $\locns{e'} \subseteq \dom{s'}$, and
\item if $\free{e'} \subseteq \free{e}$.
\end{itemize}


\section{Assertions}

\begin{definition}[Assertions]
  Let $\mathcal{F}$ be some predefined set of {\em function symbols} $f$.
  The sets $\Term$ of {\em terms} $t$ and $\Assn$ of {\em assertions} $p,q$ are defined by the following grammar:
  \[\GRbeg
  t \GRis x \GRmid v \GRmid \app{f}{t} \GRmid \pair{t_1}{t_2}
  \\
  p \GRis t_1 = t_2 \GRmid \neg p \GRmid p \wedge q \GRmid \exists x.\,p \GRmid \exists X.\,p \GRmid \app{X}{t}
  \GRal \emp \GRmid t_1 \mapsto t_2 \GRmid p \sepcon q \GRmid p \sepimp q  \GRmid \triplex{p}{e}{x}{q}
  \GRend\]
\end{definition}

Some obvious abbreviations:
\[\begin{array}{rcl}
  \btrue &=_{def}& \true = \true \\
  \bfalse &=_{def}& \neg \btrue
\end{array}\]
It is useful to introduce several more complex forms as abbreviations:
\[\begin{array}{rcl}
  \forall x.\,p &=_{def}& \neg \exists x.\,\neg p \\
  \forall X.\,p &=_{def}& \neg \exists X.\,\neg p \\
  t \mapsto - &=_{def}& \exists x.\,t \mapsto x \quad \text{where $x\not\in\free{t}$} \\
  t_1 \hookrightarrow t_2 &=_{def}& t_1 \mapsto t_2 \sepcon \btrue \\
  \{p\} &=_{def}& \triplex{\btrue}{\unit}{u}{p} \quad \text{where $x\not\in\free{p}$}
\end{array}\]


\subsection{Meaning of assertions}

Let $D = \bigcup_{L\in W} D_L$ with $D_L = \{v\in\CVal\,|\,\locns{v} \subseteq L\}$.
For each function symbol $f\in\mathcal{F}$ let
$\semantic{f}: D \to D$ be the interpretation of $f$ satisfying
\[
\semantic{f}(D_L) \subseteq D_L.
\]
An {\em environment} is a partial finite mapping $\eta:\Var \pto D$. {\bf TODO:} Relation variables.

\begin{definition}[Meaning of terms]
  Let $t$ be a term and $\eta$ a suitable environment with $\free{t} \subseteq \dom{\eta}$.
  The {\em meaning of $t$} wrt. $\eta$, written $\semantic{t}\,\eta$, is defined by:
  \[\begin{array}{rcl}
    \semantic{v}\,\eta
    &=& v\,\eta \\
    \semantic{x}\,\eta
    &=& \eta(x) \\
    \semantic{\app{f}{t}}\,\eta
    &=& \semantic{f}(\semantic{t}\,\eta) \\
    \semantic{\pair{t_1}{t_2}}\,\eta
    &=& \pair{\semantic{t_1}\,\eta}{\semantic{t_2}\,\eta}
  \end{array}\]
\end{definition}

\begin{lemma}
  $\free{t} \subseteq \dom{\eta} \ \Rightarrow\  (\semantic{t}\,\eta)\in D$
\end{lemma}

\begin{definition}[Meaning of assertions]
  The {\em satisfaction relation}, written $\eta,s \models p$, is the smallest relation between 
  environments, stores and assertions, satisfying $\free{p} \subseteq \dom{\eta}$ and all of the
  following properties:
  \[\begin{array}{lcl}
    \eta,s \models t_1 = t_2
    &\text{iff}& \semantic{t_1}\,\eta = \semantic{t_2}\,\eta \\
    \eta,s \models \neg p
    &\text{iff}& \eta,s \not\models p \\
    \eta,s \models p \wedge q
    &\text{iff}& \eta,s \models p \text{ and } \eta,s \models q \\
    \eta,s \models \exists x.\,p
    &\text{iff}& \exists d \in D.\,\eta[d/x],s \models p \\
    \eta,s \models \exists X.\,p
    &\text{iff}& \exists d \subseteq D \times \Store.\,\eta[d/X],s \models p \\
    \eta,s \models \app{X}{t}
    &\text{iff}& (\semantic{t}\,\eta,s) \in \eta(X) \\
    \eta,s \models \emp
    &\text{iff}& \grph{s} = \emptyset \\
    \eta,s \models t_1 \mapsto t_2
    &\text{iff}& \grph{s} = \{(\semantic{t_1}\,\eta,\semantic{t_2}\,\eta)\} \\
    \eta,s \models p \sepcon q
    &\text{iff}& \exists s_1,s_2.\,s=s_1 \oplus s_2 \text{ and } \eta,s_1 \models p \text{ and } \eta,s_2 \models q \\
    \eta,s \models p \sepimp q
    &\text{iff}& \forall s_1,s_2.\,(s_2 = s \oplus s_1 \text{ and } \eta,s_1 \models p) \text{ implies } \eta,s_2 \models q \\
    \eta,s \models \triplex{p}{e}{x}{q}
    &\text{iff}& \forall s'.\,\eta,s' \models p \text{ implies that all computations for } (e\,\eta,s') \\
    && \text{terminate with some $(v,s'')$ such that } \eta[v/x],s'' \models q
  \end{array}\]
\end{definition}

Meaning of abbreviations:
\[\begin{array}{lcl}
  \eta,s \models \forall x.\,p
  &\text{iff}& \forall d\in D.\,\eta[d/x],s \models p \\
  \eta,s \models \forall X.\,p
  &\text{iff}& \forall d \subseteq D \times \Store.\,\eta[d/X],s \models p \\
  \eta,s \models t \mapsto -
  &\text{iff}& \dom{s} = \{\semantic{t}\,\eta\} \\
  \eta,s \models t_1 \hookrightarrow t_2
  &\text{iff}& (\semantic{t_1}\,\eta,\semantic{t_2}\,\eta)\in\grph{s} \\
  \eta,s \models \{p\}
  &\text{iff}& \forall s'.\,\eta,s' \models p
\end{array}\]


\subsection{The calculus}

\subsubsection{Rules for the programming language}

{\small
\begin{tabular}{rl}
  \RN{Val} & $\triple{\emp}{x_{:y}}{y = x \wedge \emp}$ \\[1mm]
  \RN{App} & $\triplex{p}{e_1}{x}{p'} \wedge (\forall x.\,\triplex{p'}{e_2}{y}{q'}) \wedge (\forall x,y.\,\triplex{q'}{\app{x}{y}}{z}{q})$ \\
  & $\Rightarrow \triplex{p}{\app{e_1}{e_2}}{z}{q}$ \\
  & {\footnotesize where $x \not\in \free{e_2}$, $x,y \not\in\free{q}$} \\[1mm]
  \RN{Op} & $\triplex{\emp}{\app{\app{\op}{x}}{y}}{z}{z = \app{f_{\op}}{\tuple{x,y}} \wedge \emp}$ \\[1mm]
  \RN{Beta-V} & $\forall x.\,\triplex{p}{e}{y}{q} \Rightarrow \triplex{p}{\app{(\abstr{x}{e})}{x}}{y}{q}$ \\[1mm]
  \RN{Unfold} & $\triplex{p}{e[\app{\fix}{(\abstr{x}{e})}/x]}{y}{q} \Rightarrow \triplex{p}{\app{\fix}{(\abstr{x}{e})}}{y}{q}$ \\[1mm]
  \RN{Fst} & $\forall x,y.\,\triplex{\emp}{\app{\fst}{\pair{x}{y}}}{z}{z = x \wedge \emp}$ \\[1mm]
  \RN{Snd} & $\forall x,y.\,\triplex{\emp}{\app{\snd}{\pair{x}{y}}}{z}{z = y \wedge \emp}$ \\[1mm]
  \RN{Deref} & $\forall x,y.\,\triplex{x \mapsto y}{!x}{z}{z = y \wedge x \mapsto y}$ \\[1mm]
  \RN{Assign} & $\forall x,y.\,\triplex{x \mapsto -}{\app{\app{\assign}{x}}{y}}{u}{u = \unit \wedge x \mapsto y}$ \\[1mm]
  \RN{Ref} & $\forall x.\,\triplex{\emp}{\cref\,x}{y}{y \mapsto x}$ \\[1mm]
  \RN{Cond-True} & $\triplex{p}{e_0}{x}{x = \true \wedge r} \wedge \triplex{r}{e_1}{y}{q}$ \\
  & $\Rightarrow \triplex{p}{\ifte{e_0}{e_1}{e_2}}{y}{q}$ \\
  & {\footnotesize where $x \not\in \free{r}$} \\[1mm]
  \RN{Cond-False} & $\triplex{p}{e_0}{x}{x = \false \wedge r} \wedge \triplex{r}{e_2}{y}{q}$ \\
  & $\Rightarrow \triplex{p}{\ifte{e_0}{e_1}{e_2}}{y}{q}$ \\
  & {\footnotesize where $x \not\in \free{r}$} \\[1mm]
  \RN{Pair} & $\triplex{p}{e_1}{x}{p'} \wedge (\forall x.\,\triplex{p'}{e_2}{y}{q'}) \wedge (\forall x,y.\,\triplex{q'}{\pair{x}{y}}{z}{q})$ \\
  & $\Rightarrow \triplex{p}{\pair{e_1}{e_2}}{z}{q}$ \\
  & \footnotesize{where $x \not\in \free{e_2}$, $x,y \not\in \free{q}$}
\end{tabular}}

\subsubsection{Rules for separation}

{\small
\begin{tabular}{rl}
  \RN{Sep-1} & $p_1 \sepcon p_2 \Leftrightarrow p_2 \sepcon p_1$ \\[1mm]
  \RN{Sep-2} & $(p_1 \sepcon p_2) \sepcon p_3 \Leftrightarrow p_1 \sepcon (p_2 \sepcon p_3)$ \\[1mm]
  \RN{Sep-3} & $p \sepcon \emp \Leftrightarrow p$ \\[1mm]
  \RN{Sep-4} & $(p_1 \vee p_2) \sepcon q \Leftrightarrow (p_1 \vee q) \sepcon (p_2 \vee q)$ \\[1mm]
  \RN{Sep-5} & $(p_1 \wedge p_2) \sepcon q \Rightarrow (p_1 \wedge q) \sepcon (p_2 \wedge q)$ \\[1mm]
  \RN{Sep-6} & $(\exists x.\,p) \sepcon q \Leftrightarrow \exists x.\,p \sepcon q$ $\quad$ where $x\not\in\free{q}$ \\[1mm]
  \RN{Sep-7} & $(\exists X.\,p) \sepcon q \Leftrightarrow \exists X.\,p \sepcon q$ $\quad$ where $X\not\in\free{q}$ \\[1mm]
  \RN{Sep-8} & $(\forall x.\,p) \sepcon q \Rightarrow \forall x.\,p \sepcon q$ $\quad$ where $x\not\in\free{q}$ \\[1mm]
  \RN{Sep-9} & $(\forall X.\,p) \sepcon q \Rightarrow \forall X.\,p \sepcon q$ $\quad$ where $X\not\in\free{q}$ \\[1mm]
  \RN{Sep-10} & $\{p_1 \Rightarrow p_2\} \wedge \{q_1 \Rightarrow q_2\} \Rightarrow \{p_1 \sepcon q_1 \Rightarrow p_2 \sepcon q_2\}$ \\[1mm]
  \RN{Sep-11} & $\{p_1 \sepcon p_2 \Rightarrow p_3\} \Leftrightarrow \{p_1 \Rightarrow (p_2 \sepimp p_3)\}$ 
\end{tabular}}

\subsubsection{Rules for total correctness}

{\small
\begin{tabular}{rl}
  \RN{Conseq} & $(\{p \Rightarrow p'\} \wedge \triplex{p'}{e}{x}{q'} \wedge \forall x.\,\{q' \Rightarrow q\}) \Rightarrow \triplex{p}{e}{x}{q}$ \\[1mm]
  \RN{Frame} & $\triplex{p}{e}{x}{q} \Rightarrow \triplex{p \sepcon r}{e}{x}{q \sepcon r}$ \\
  & {\footnotesize where $x \not\in \free{r}$}
\end{tabular}}

\subsubsection{Structural rules}

{\small
\begin{tabular}{rl}
  \RN{Refl-Term} & $\forall x.\,x = x$ \\[1mm]
  \RN{Subst-Term} & $t_1 = t_2 \Rightarrow (p[t_1/x] \Leftrightarrow p[t_2/x])$ \\
  & {\footnotesize where $(p[t_1/x]), (p[t_2/x]) \in \Assn$} \\[1mm]
  \RN{Spec-Term} & $(\forall x.\,p) \Rightarrow p[t/x]$ \\
  & {\footnotesize where $(p[t/x])\in\Assn$} \\[1mm]
\end{tabular}}

\end{document}
