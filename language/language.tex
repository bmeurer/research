\documentclass[12pt,a4paper]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{array}
\usepackage[american]{babel}
\usepackage{color}
\usepackage{enumerate}
\usepackage[a4paper,%
            colorlinks=false,%
            final,%
            pdfkeywords={},%
            pdftitle={},%
            pdfauthor={Benedikt Meurer},%
            pdfsubject={},%
            pdfdisplaydoctitle=true]{hyperref}
\usepackage{ifthen}
\usepackage[latin1]{inputenc}
\usepackage{latexsym}
\usepackage[final]{listings}
\usepackage{makeidx}
\usepackage{ngerman}
\usepackage[standard,thmmarks]{ntheorem}
\usepackage{stmaryrd}

%% LaTeX macros
\include{macros}

\begin{document}


\section{Semantik von Programmiersprachen}

\begin{definition}[Syntax]
  Eine \emph{Syntax} ist eine Menge $\L$ von syntaktisch korrekten Programmen.
\end{definition}

\begin{definition}[Semantik]
  Sei $\L$ eine Syntax. Eine \emph{$\L$-Semantik} ist ein Paar $S = (\Obs,\beh)$.
  Hierbei ist
  \begin{enumerate}
  \item $\Obs$ eine Menge von \emph{beobachtbaren Verhalten}, und
  \item $\beh: \L \to \powerset{\Obs}$ eine \emph{Beobachtungsfunktion}, die jedem $\L$-Programm
    beobachtbares Verhalten zuordnet.
  \end{enumerate}
\end{definition}

\begin{definition}[Implementierung]
  Sei $\L$ eine Syntax und sei $\Obs$ eine Menge von beobachtbaren Verhalten.
  Eine \emph{$(\L,\Obs)$-Implementierung} ist ein Tupel $M = (\Exp,D,\semantic{\cdot},\obs)$,
  bestehend aus
  \begin{enumerate}
  \item der Menge $\Exp \supseteq \L$ von \emph{Ausdr"ucken},
  \item dem \emph{semantischen Bereich} $D$,
  \item der \emph{Semantikfunktion} $\semantic{\cdot}:\Exp \to D$, welche jedem Ausdruck
    ein Element des semantischen Bereichs zuordnet, und
  \item der \emph{Bewertungsfunktion} $\obs:D \to \powerset{\Obs}$, welche jedes Element
    des semantischen Bereichs als beobachtbares Verhalten bewertet.
  \end{enumerate}
  Eine Implementierung hei"st \emph{ad"aquat} f"ur eine $\L$-Semantik $S=(\Obs,\beh)$,
  wenn $\obs(\semantic{e}) = \beh(e)$ f"ur alle $e \in \L$ gilt.
\end{definition}

\begin{lemma}
  Sei $(\L,S)$ eine Programmiersprache mit $S = (\Obs,\beh)$ und $M_1 = (\Exp,D_1,\semantic{\cdot}_1,\obs_1)$
  eine ad"aquate $(\L,\Obs)$-Implementierung f"ur $S$.
  Eine weitere $(\L,\Obs)$-Implementierung $M_2=(\Exp,D_2,\semantic{\cdot}_2,\obs_2)$
  ist ad"aquat f"ur $S$, wenn $\obs_1(\semantic{e}_1) = \obs_2(\semantic{e}_2)$ f"ur alle $e \in \Exp$.
\end{lemma}

\begin{definition}
  Eine Menge $A$ hei"st \emph{induktiv definiert} durch eine Familie $C = (C_n)_{n\in\N}$ von
  \emph{Konstruktoren} $\zeta_n$, wenn $A$ der induktive Abschluss von $C$ ist.
\end{definition}

\begin{definition}[Kompositionalit"at]
  Sei $\Exp$ induktiv definiert durch die Familie $C=(C_n)_{n\in\N}$.
  Eine Implementierung $M=(\Exp,D,\semantic{\cdot},\obs)$ hei"st \emph{$C$-kompositional},
  wenn zu jedem $\zeta_n \in C_n$ eine Funktion $\semantic{\zeta_n}: D^n \to D$ existiert, so dass gilt:
  Wenn $e = \zeta_n (e_1 \ldots e_n)$, dann 
  $\semantic{e} = \semantic{\zeta_n}(\semantic{e_1} \ldots \semantic{e_n})$.
\end{definition}

\begin{theorem}
  Sei $(\L,S)$ eine Programmiersprache mit $S=(\Obs,\beh)$, $\Exp$ induktiv definiert durch
  $C=(C_n)_{n\in\N}$, und seien $M_1=(\Exp,D_1,\semantic{\cdot}_1,\obs_1)$ und
  $M_2 = (\Exp,D_2,\semantic{\cdot}_2,\obs_2)$ $C$-kompositionale $(\L,\Obs)$-Implementierungen.
  $M_2$ ist ad"aquat f"ur $S$, wenn $M_1$ ad"aquat f"ur $S$ und eine Relation $\sim\ \subseteq D_1 \times D_2$
  existiert, so dass gilt:
  \begin{enumerate}
  \item Wenn $d_{1,i} \sim d_{2,i}$ f"ur $i=1,\ldots,n$, dann gilt
    \[\semantic{\zeta_n}_1 (d_{1,1} \ldots d_{1,n}) \sim \semantic{\zeta_n}_2 (d_{2,1} \ldots d_{2,n})\]
    f"ur alle $n \ge 0$ und $\zeta_n \in C_n$.
  \item Wenn $d_1 \sim d_2$, dann gilt $\obs_1(d_1) = \obs_2(d_2)$.
  \end{enumerate}
\end{theorem}

\end{document}